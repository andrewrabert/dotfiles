#!/usr/bin/env python3
"""Sandbox claude using bubblewrap with filesystem isolation."""

import argparse
import os
import pathlib
import shutil
import sys

YELLOW = "\033[1;33m"
RED = "\033[1;31m"
RESET = "\033[0m"


def log(msg):
    print(f"{YELLOW}{msg}{RESET}")


def error(msg):
    print(f"{RED}{msg}{RESET}", file=sys.stderr)
    sys.exit(1)


def make_parser():
    parser = argparse.ArgumentParser(
        description="Sandbox claude using bubblewrap with filesystem isolation.",
        add_help=False,
    )
    parser.add_argument(
        "-h", "--help", action="store_true", help="Show this help"
    )
    parser.add_argument(
        "--help-claude", action="store_true", help="Show claude --help"
    )
    parser.add_argument(
        "-n", "--no-net", action="store_true", help="Disable network access"
    )
    parser.add_argument(
        "-w",
        "--workdir",
        dest="work_dir",
        type=pathlib.Path,
        default=pathlib.Path.cwd(),
        help="Working directory (default: current)",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Show bwrap command before running",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print bwrap command without executing",
    )
    parser.add_argument(
        "--no-dangerously-skip-permissions",
        action="store_true",
        help="Don't pass --dangerously-skip-permissions to claude",
    )
    return parser


def build_command(args, claude_args):
    work_dir = args.work_dir.resolve()
    if not work_dir.is_dir():
        error(f"directory not found: {work_dir}")

    home = pathlib.Path.home()
    uid = os.getuid()
    claude_dir = (
        pathlib.Path(os.environ.get("DOTFILES_PRIVATE", "")) / "claude"
    )

    cmd = [
        "bwrap",
        "--ro-bind",
        "/usr",
        "/usr",
        "--ro-bind",
        "/bin",
        "/bin",
        "--ro-bind",
        "/etc",
        "/etc",
        "--ro-bind",
        "/opt",
        "/opt",
    ]

    # Handle /lib and /lib64 - may be real dirs or symlinks (usrmerge)
    for lib in ["/lib", "/lib64"]:
        p = pathlib.Path(lib)
        if p.is_symlink():
            cmd += ["--symlink", os.readlink(lib), lib]
        elif p.is_dir():
            cmd += ["--ro-bind", lib, lib]

    cmd += [
        "--proc",
        "/proc",
        "--dev",
        "/dev",
        "--tmpfs",
        "/tmp",
        "--tmpfs",
        "/run",
        "--ro-bind",
        "/run/systemd/resolve",
        "/run/systemd/resolve",
        "--dir",
        f"/run/user/{uid}",
        "--bind",
        str(claude_dir),
        str(claude_dir),
        "--bind",
        str(home / ".config"),
        str(home / ".config"),
        "--ro-bind",
        str(home / ".local/bin"),
        str(home / ".local/bin"),
        "--ro-bind",
        str(home / ".local/share/nvim"),
        str(home / ".local/share/nvim"),
        "--bind",
        str(work_dir),
        str(work_dir),
        "--setenv",
        "HOME",
        str(home),
        "--setenv",
        "USER",
        os.environ.get("USER", ""),
        "--setenv",
        "TERM",
        os.environ.get("TERM", "xterm-256color"),
        "--setenv",
        "PATH",
        f"{home}/.local/bin:/usr/local/bin:/usr/bin:/bin",
        "--setenv",
        "TMPDIR",
        "/tmp",
        "--setenv",
        "CLAUDE_CONFIG_DIR",
        str(claude_dir),
        "--chdir",
        str(work_dir),
        "--unshare-pid",
        "--die-with-parent",
    ]

    if args.no_net:
        cmd += ["--unshare-net"]

    cmd += ["/usr/bin/claude"]
    if not args.no_dangerously_skip_permissions:
        cmd += ["--dangerously-skip-permissions"]
    cmd += claude_args
    return cmd


def main():
    parser = make_parser()
    args, claude_args = parser.parse_known_args()

    if args.help:
        parser.print_help()
        return

    if args.help_claude:
        claude_args = ["--help"]

    if not shutil.which("bwrap"):
        error("bubblewrap (bwrap) not found")
    if not shutil.which("claude"):
        error("claude not found")

    cmd = build_command(args, claude_args)

    if args.verbose or args.dry_run:
        log(f"Running: {' '.join(cmd)}")

    if args.dry_run:
        return

    os.execvp(cmd[0], cmd)


if __name__ == "__main__":
    main()
