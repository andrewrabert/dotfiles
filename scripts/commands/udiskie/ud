#!/usr/bin/env python3
import argparse
import json
import pathlib
import subprocess
import sys


class cdemu:

    @classmethod
    def info(cls):
        status = cls._status()
        devmap = cls._device_mapping()
        mounted = []
        for cdemu_id, path in status.items():
            if path is not None:
                info = {
                    'cdemu_id': cdemu_id,
                    'device': devmap[cdemu_id],
                    'ui_label': str(path),
                }
                mounted.append(info)
        return mounted

    @staticmethod
    def _device_mapping():
        proc = subprocess.run(
            ['cdemu', 'device-mapping'],
            stdout=subprocess.PIPE,
            check=True)
        devmap = {}
        for line in proc.stdout.decode().splitlines()[2:]:
            parts = line.split(maxsplit=2)
            cdemu_id = parts[0]
            device = parts[1]
            devmap[cdemu_id] = device
        return devmap

    @staticmethod
    def _status():
        proc = subprocess.run(
            ['cdemu', 'status'],
            stdout=subprocess.PIPE,
            check=True)
        devmap = {}
        for line in proc.stdout.decode().splitlines()[2:]:
            parts = line.split(maxsplit=2)
            cdemu_id = parts[0]
            match parts[1]:
                case 'True':
                    is_loaded = True
                case 'False':
                    is_loaded = False
                case _:
                    raise ValueError(parts)
            path = None
            if is_loaded:
                path = pathlib.Path(parts[2])
                assert path.is_file()
            devmap[cdemu_id] = path
        return devmap

    @classmethod
    def load(cls, path):
        status = cls._status()
        target_cdemu_id = None
        for cdemu_id, loaded_path in status.items():
            if loaded_path is None:
                target_cdemu_id = cdemu_id
                break
        if target_cdemu_id is None:
            raise NotImplementedError
        subprocess.run(
            ['cdemu', 'load', cdemu_id, '--', path],
            check=True)

    @staticmethod
    def unload(cdemu_id):
        subprocess.run(
            ['cdemu', 'unload', cdemu_id],
            check=True)


class sshfs:

    @staticmethod
    def info():
        mounted = []
        for line in pathlib.Path('/proc/mounts').read_text().splitlines():
            device, mount_point, fs_type, *_ = line.split(maxsplit=4)
            if fs_type != 'fuse.sshfs':
                continue
            info = {
                'device': device,
                'mount_point': mount_point,
            }
            mounted.append(info)
        return mounted

    @staticmethod
    def unmount(mount_point):
        subprocess.run(
            ['fusermount3', '-quz', '--', mount_point],
            check=True)


class udiskie:

    @staticmethod
    def info():
        columns = [
            'autoclear',
            'device_file',
            'device_id',
            'device_presentation',
            'device_size',
            'drive_label',
            'drive_model',
            'drive_vendor',
            'has_media',
            'id_label',
            'id_type',
            'id_usage',
            'id_uuid',
            'in_use',
            'is_block',
            'is_crypto',
            'is_detachable',
            'is_drive',
            'is_ejectable',
            'is_external',
            'is_filesystem',
            'is_ignored',
            'is_loop',
            'is_luks',
            'is_luks_cleartext',
            'is_mounted',
            'is_partition',
            'is_partition_table',
            'is_systeminternal',
            'is_toplevel',
            'is_unlocked',
            'loop_file',
            'mount_path',
            'mount_paths',
            'setup_by_uid',
            'should_automount',
            'symlinks',
            'ui_device_label',
            'ui_device_presentation',
            'ui_id_label',
            'ui_id_uuid',
            'ui_label',
        ]
        output_arg = '\t'.join('{' + c + '}' for c in columns)
        proc = subprocess.run(
            ['udiskie-info', '--all', '--output', output_arg],
            stdout=subprocess.PIPE,
            check=True)

        items = []
        for line in proc.stdout.decode().splitlines():
            items.append({
                key: value
                for key, value in zip(columns, line.split('\t'))
            })
        return items

    @staticmethod
    def unmount(device):
        subprocess.run(
            ['udiskie-umount', device],
            check=True)

    @staticmethod
    def mount(device, options='', recursive=False):
        args = []
        if options:
            args.extend(['--options', options])
        if recursive:
            args.append('--recursive')
        else:
            args.append('--no-recursive')
        subprocess.run(
            ['udiskie-mount', *args, device],
            check=True)


def fzf(data):
    proc = subprocess.run(
        ['fzf', '--black', '--prompt=', '--no-info', '--exact', '--no-sort',
         '--no-extended', '-i', '--layout=reverse', '--print-query'],
        input='\n'.join(data).encode(),
        stdout=subprocess.PIPE,
    )
    try:
        result = proc.stdout.decode().splitlines()[-1]
    except IndexError:
        result = None

    return result


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('image', type=pathlib.Path, nargs='?')
    parser.add_argument('--json', action='store_true')
    parser.add_argument('-o', '--options', default='')
    args = parser.parse_args()

    if args.json:
        print(json.dumps(udiskie.info(), indent=2, sort_keys=True))
        return

    if args.image is not None:
        if args.image.name.lower().endswith('.cue'):
            cdemu.load(args.image)
        else:
            udiskie.mount(args.image, options=args.options)
        return

    items = {}
    for item in udiskie.info():
        if item['is_filesystem'] == 'True':
            key = '\t'.join([
                'mount' if item['is_mounted'] == 'False' else 'unmount',
                item['ui_label'] + ' ' + (item['mount_path'] or ''),
            ])
        elif item['is_loop'] == 'True' and item['is_toplevel'] == 'True':
            key = '\t'.join(['detach', item['ui_label']])
        else:
            continue

        if key in items:
            raise RuntimeError
        items[key] = ['udiskie', item]

    for item in cdemu.info():
        print(item)
        key = '\t'.join(['detach', item['device'] + ' ' + item['ui_label']])
        items[key] = ['cdemu', item]
        pass

    for item in sshfs.info():
        key = '\t'.join(['unmount', item['mount_point']])
        items[key] = ['sshfs', item]

    if not items:
        sys.exit(1)
    result = fzf(sorted(items))
    if not result:
        sys.exit(1)

    item_type, item = items[result]
    action, _ = result.split('\t')
    if item_type == 'udiskie':
        if action == 'mount':
            udiskie.mount(item['device_file'],
                          options=args.options)
        elif action == 'unmount':
            udiskie.unmount(item['device_file'])
        elif action == 'detach':
            udiskie.unmount(item['device_file'])
    elif item_type == 'sshfs':
        if action == 'unmount':
            sshfs.unmount(item['mount_point'])
    elif item_type == 'cdemu':
        if action == 'detach':
            cdemu.unload(item['cdemu_id'])


if __name__ == '__main__':
    main()
