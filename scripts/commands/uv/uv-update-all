#!/usr/bin/env python3
"""Update all PEP 723 scripts managed by uv in a directory."""

import argparse
import asyncio
import pathlib
import sys


def shebang_to_sync_cmd(shebang: str, script_path: str) -> list[str] | None:
    """Convert uv run shebang to uv sync command args."""
    # Extract args after "env -S " or "env "
    if shebang.startswith("#!/usr/bin/env -S "):
        args_str = shebang[len("#!/usr/bin/env -S "):]
    elif shebang.startswith("#!/usr/bin/env "):
        args_str = shebang[len("#!/usr/bin/env "):]
    else:
        return None
    # Split into args, replace 'run' with 'sync', append filepath
    cmd = []
    replaced_run = False
    for arg in args_str.split():
        if not replaced_run and arg == "run":
            cmd.append("sync")
            replaced_run = True
        else:
            cmd.append(arg)
    if not replaced_run:
        return None
    cmd.append(script_path)
    return cmd


def all_files(*paths):
    stack = []
    files = set()
    for path in paths:
        if not path.exists():
            raise ValueError(f"path does not exist: {path}")
        elif path.is_file():
            files.add(path)
        elif path.is_dir():
            stack.append(path)
    while stack:
        for path in stack.pop().iterdir():
            if path.is_dir():
                stack.append(path)
            else:
                files.add(path)
    return sorted(files)


HEADER_READ_SIZE = 1024


async def find_uv_scripts(
    directory: pathlib.Path, verbose: bool = False, seen: set | None = None
) -> list[pathlib.Path]:
    """Find all executable files with uv run shebang and PEP 723 metadata."""
    if seen is None:
        seen = set()
    uv_scripts = []

    for file_path in all_files(directory):
        resolved = file_path.resolve().absolute()
        if resolved in seen:
            continue
        seen.add(resolved)

        try:
            with file_path.open("r") as f:
                header = f.read(HEADER_READ_SIZE)
        except (UnicodeDecodeError, OSError):
            continue

        # Must have a shebang with uv run
        shebang = header.split("\n", 1)[0]
        if not shebang.startswith("#!"):
            continue
        if "uv" not in shebang or "run" not in shebang:
            continue

        # Only include scripts with PEP 723 metadata block
        if "# /// script" not in header:
            if verbose:
                print(f"skipping: no PEP 723 metadata: {resolved}")
            continue

        if verbose:
            print(f"found: {resolved}")
        uv_scripts.append((file_path.absolute(), shebang))

    return sorted(set(uv_scripts))


async def update_script(
    script_path: pathlib.Path, shebang: str, verbose: bool = False
) -> bool:
    """Update dependencies for a single PEP 723 script."""
    cmd = shebang_to_sync_cmd(shebang, str(script_path))
    if not cmd:
        return False
    cmd.append("--upgrade")
    if not verbose:
        cmd.append("--quiet")
    try:
        proc = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=None if verbose else asyncio.subprocess.DEVNULL,
            stderr=None if verbose else asyncio.subprocess.DEVNULL,
        )
        await proc.wait()
        return proc.returncode == 0
    except Exception:
        return False


async def update_all_scripts(
    scripts: list[tuple[pathlib.Path, str]], verbose: bool = False
) -> bool:
    """Update all scripts concurrently."""
    tasks = []
    for script, shebang in scripts:
        task = asyncio.create_task(update_script(script, shebang, verbose))
        tasks.append((script, task))

    had_error = False

    for script, task in tasks:
        script_name = script.name
        try:
            success = await task
            if success:
                print(f"updated: {script_name}")
            else:
                print(f"failed: {script_name}")
                had_error = True
        except Exception:
            print(f"failed: {script_name}")
            had_error = True

    return had_error


async def main():
    """Main function."""
    parser = argparse.ArgumentParser(description="update all PEP 723 scripts")
    parser.add_argument(
        "paths",
        nargs="*",
        default=["."],
        type=pathlib.Path,
        help="files or directories to process",
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="show detailed output",
    )
    parser.add_argument(
        "--show-cache",
        action="store_true",
        help="show cache paths for detected scripts and exit",
    )
    args = parser.parse_args()

    scripts = set()
    warnings = []
    seen = set()

    for path in args.paths:
        resolved = path.resolve().absolute()
        if resolved in seen:
            continue
        seen.add(resolved)

        if not path.exists():
            warnings.append(f"path not found: {path}")
            continue

        if path.is_dir():
            for script in await find_uv_scripts(path, args.verbose, seen):
                scripts.add(script)
        elif path.is_file():
            # For explicit files, check if valid uv script
            try:
                with path.open("r") as f:
                    header = f.read(HEADER_READ_SIZE)
            except (UnicodeDecodeError, OSError):
                warnings.append(f"cannot read: {path}")
                continue

            shebang = header.split("\n", 1)[0]
            if not shebang.startswith("#!") or "uv" not in shebang or "run" not in shebang:
                warnings.append(f"not a uv script: {resolved}")
                continue
            if "# /// script" not in header:
                warnings.append(f"no PEP 723 metadata: {resolved}")
                continue

            scripts.add((path.absolute(), shebang))

    scripts = sorted(scripts)

    if args.show_cache:
        for script, _ in scripts:
            proc = await asyncio.create_subprocess_exec(
                "uv", "sync", "--dry-run", "--offline", "--script", str(script),
                stdout=asyncio.subprocess.DEVNULL,
                stderr=asyncio.subprocess.PIPE,
            )
            _, stderr = await proc.communicate()
            import re
            match = re.search(r"Would \w+ script environment at: (.+)", stderr.decode())
            if match:
                print(match.group(1))
        return

    had_error = False
    if scripts:
        had_error = await update_all_scripts(scripts, args.verbose)

    for warning in warnings:
        print(f"warning: {warning}", file=sys.stderr)

    if had_error or warnings:
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
