#!/usr/bin/env python3
import asyncio
import dataclasses
import argparse
from collections.abc import AsyncIterable


@dataclasses.dataclass
class OptionalDependency:
    name: str
    parent_name: str
    description: str
    installed: bool


async def pacman_query_opt_depends(packages):
    proc = await asyncio.create_subprocess_exec(
            'pacman', '-Qi', '--', *set(packages),
            stdout=asyncio.subprocess.PIPE)
    stdout, _ = await proc.communicate()

    opt_depends = {}

    inside_optdepends = False
    parent_package = None
    for line in stdout.decode().splitlines():
        if line.startswith('Name            : '):
            parent_package = line.split(':', maxsplit=1)[1].strip()

        if line.startswith('Optional Deps   : '):
            inside_optdepends = True
            parts = line.split(':', maxsplit=2)
            match len(parts):
                case 2:
                    if parts[1].strip() == 'None':
                        # no opt depends
                        continue
                case 3:
                    package_name = parts[1]
                    description = parts[2]
        elif inside_optdepends and line.startswith('                  '):
            package_name, description = line.split(':', maxsplit=1)
        else:
            inside_optdepends = False
            package_name = None

        if package_name is not None:
            package_name = package_name.strip()
            description2 = description.removesuffix('[installed]')
            installed = description != description2
            optdep = OptionalDependency(
                parent_name=parent_package,
                name=package_name,
                description=description,
                installed=installed,
            )
            opt_depends.setdefault(parent_package, [])
            opt_depends[parent_package].append(optdep)
    return opt_depends


async def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-q', '--quiet', action='store_true')
    parser.add_argument('package', nargs='+')
    state_mutex = parser.add_mutually_exclusive_group()
    state_mutex.add_argument('-m', '--missing', action='store_true')
    state_mutex.add_argument('-i', '--installed', action='store_true')
    args = parser.parse_args()

    all_opt_depends = {}
    opt_depends_by_parent = await pacman_query_opt_depends(args.package)
    for parent, opt_depends in opt_depends_by_parent.items():
        for dep in opt_depends:
            if args.installed and not dep.installed:
                continue
            if args.missing and dep.installed:
                continue
            all_opt_depends.setdefault(dep.name, [])
            all_opt_depends[dep.name].append(dep)

    for name in sorted(all_opt_depends):
        print(name)
        if not args.quiet:
            for dep in sorted(all_opt_depends[name], key=lambda x: x.parent_name):
                print(f'    {dep.parent_name}: {dep.description}')


if __name__ == '__main__':
    asyncio.run(main())

r"""
usage() {
    echo 'usage: PACKAGE'
}
PACKAGE=''
case $# in
    1)
        PACKAGE="$1"
        ;;
    *)
        usage >&2
        echo 'error: missing package name'
        exit 1
        ;;
esac
#pacman -Qi "$PACKAGE" | sed -n '/Optional Deps/{:l s/.* \([a-zA-Z0-9.\-]\+\):.*/\1/p; n; /Required By/!bl}'
pacman -Qi "$PACKAGE" | grep -v -E '\[installed\]$' | sed -n '/Optional Deps/{:l s/.* \([a-zA-Z0-9.\-]\+\):.*/\1/p; n; /Required By/!bl}'
"""
