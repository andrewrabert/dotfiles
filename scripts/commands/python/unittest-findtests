#!/usr/bin/env python3
import argparse
import contextlib
import logging
import pathlib
import subprocess
import unittest

LOGGER = logging.getLogger("unittest-findtests")


def find_tests(name):
    tests = set()
    try:
        name_str = str(name)
        for suite in unittest.defaultTestLoader.discover(name_str, top_level_dir=name_str):
            LOGGER.debug("suite %r", suite)
            for case in suite:
                LOGGER.debug("case %r", case)
                # Handle failed test discovery results
                if 'unittest.loader._FailedTest' in str(type(case)):
                    LOGGER.debug("handling failed test %r", case)
                    # Extract module name from failed test
                    if hasattr(case, '_testMethodName'):
                        test_name = case._testMethodName
                        # test_name is like "acceptance.test_delete_user"
                        if test_name:
                            tests.add(test_name)
                            LOGGER.debug("found failed test %s", test_name)
                    continue
                    
                # Handle single test case
                if hasattr(case, '_testMethodName') and hasattr(case, '__module__'):
                    # This is a single test case
                    fullname = ".".join([
                        case.__module__,
                        case.__class__.__qualname__,
                        case._testMethodName,
                    ])
                    LOGGER.debug("found %s", fullname)
                    tests.add(fullname)
                    continue
                    
                try:
                    iter_case = iter(case)
                except TypeError as e:
                    LOGGER.debug("case error %r", e)
                    continue
                for test in iter_case:
                    fullname = ".".join(
                        [
                            test.__module__,
                            test.__class__.__qualname__,
                            test._testMethodName,
                        ]
                    )
                    LOGGER.debug("found %s", fullname)
                    tests.add(fullname)
    except (AssertionError, ImportError) as e:
        LOGGER.debug("loader error %r", e)
    try:
        relative = name.relative_to(pathlib.Path())
        prefix = ".".join(relative.parts)
    except ValueError:
        # Handle absolute paths by using just the directory name
        prefix = name.name
    
    return {f"{prefix}.{test}" if prefix else test for test in tests}


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", action="store_true")
    parser.add_argument("--prefix", help="Only show test modules starting with this prefix")
    parser.add_argument("path", type=pathlib.Path, nargs="?")
    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)

    # fixes discovery when both local tests and unrelated acceptance tests
    # reside in current directory.
    if args.path is None:
        paths = []
        for path in pathlib.Path().iterdir():
            if path.is_dir():
                paths.append(path)
    else:
        paths = [args.path.absolute()]

    tests = set()
    # redirect output to make loud imports stfu
    with contextlib.redirect_stdout(subprocess.DEVNULL):
        with contextlib.redirect_stderr(subprocess.DEVNULL):
            for path in paths:
                tests.update(find_tests(path))

    # Filter tests by prefix if provided
    if args.prefix:
        filtered_tests = set()
        for test in tests:
            # Handle both "test_module" and "test.test_module" patterns
            test_parts = test.split('.')
            for i, part in enumerate(test_parts):
                if part.startswith(args.prefix):
                    filtered_tests.add(test)
                    break
        tests = filtered_tests

    print("\n".join(sorted(tests)))


if __name__ == "__main__":
    main()
