#!/usr/bin/env python3
import argparse
import functools
import json
import os
import sys


def __write(obj, mode, value):
    try:
        if mode != 'bytes':
            if mode == 'json':
                value = json.dumps(value)
            if isinstance(value, str):
                value = value.encode()
            elif not isinstance(value, bytes):
                value = str(value).encode()
        obj.buffer.write(value)
    except TypeError as e:
        print(f'error: unable to write output. {str(e)}', file=sys.stderr)
        sys.exit(1)
    obj.flush()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('command')
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        '-b',
        action='store_const',
        const='bytes',
        default=False,
        dest='mode',
        help='Read/write in bytes'
    )
    group.add_argument(
        '-j',
        action='store_const',
        const='json',
        default=False,
        dest='mode',
        help='Read/write in bytes'
    )
    args = parser.parse_args()
    exec_command(args.command, args.mode)


def exec_command(command, mode):
    if not sys.stdin.isatty():
        inp = sys.stdin.buffer.read()
        if mode != 'bytes':
            inp = inp.decode()
            if mode == 'json':
                try:
                    inp = json.loads(inp)
                except json.JSONDecodeError:
                    print(
                        'error: stdin is not valid json',
                        file=sys.stderr
                    )
                    sys.exit(1)

    # convenience variables
    out = functools.partial(__write, sys.stdout, mode)
    err = functools.partial(__write, sys.stderr, mode)
    env = dict(os.environ)
    exit = sys.exit

    exec(command)


if __name__ == '__main__':
    main()
