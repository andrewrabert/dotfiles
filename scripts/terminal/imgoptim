#!/usr/bin/env -S uv run --script
"""
Image optimization tool with support for multiple formats.

System commands executed by this script:
- cjpegli: JPEG XL to JPEG conversion with high quality
- cjxl: Encode images to JPEG XL format
- djxl: Decode JPEG XL images
- exiftool: Read and write EXIF metadata
- exiv2: Read, write, and manipulate EXIF metadata
- gifsicle: GIF optimization and manipulation
- inkscape: SVG to PNG conversion
- jpegoptim: JPEG optimization
- krita: Export KRA (Krita native) images
- systemd-run: Optional, sandbox krita via transient service
- magick: ImageMagick for various image operations
- oxipng: PNG optimization
- sha256sum: Calculate SHA-256 checksums
- svgo: SVG optimization
- tiffcp: TIFF image copying and compression
- vips: VIPS image processing library operations
- vipsheader: Extract metadata from images using VIPS

# /// script
# dependencies = [
#     "async_executor",
#     "mozjpeg_lossless_optimization",
# ]
# ///
"""

import argparse
import asyncio
import contextlib
import hashlib
import json
import os
import pathlib
import shutil
import signal
import sqlite3
import sys
import tempfile
import types

import async_executor
import mozjpeg_lossless_optimization

CONFIG = types.SimpleNamespace(
    jpeg=types.SimpleNamespace(
        quality="90",
    ),
    jxl=types.SimpleNamespace(
        distance="0.0",
        effort="10",
        lossless=True,
    ),
)


class ImageOptimCache:
    SCHEMA = """
    CREATE TABLE IF NOT EXISTS images(
        sha256 TEXT PRIMARY KEY,
        type TEXT,
        fast INTEGER DEFAULT 0,
        strip INTEGER DEFAULT 0,
        inserted_at REAL DEFAULT (unixepoch('now', 'subsec'))
    );
    CREATE TABLE IF NOT EXISTS paths(
        path TEXT PRIMARY KEY,
        sha256 TEXT,
        size INTEGER,
        mtime REAL,
        FOREIGN KEY(sha256) REFERENCES images(sha256)
    );
    """

    def __init__(self, path):
        self.path = path.absolute()
        self.path.parent.mkdir(parents=True, exist_ok=True)
        self.conn = sqlite3.connect(self.path)
        self.conn.row_factory = self._dict_factory
        cur = self.conn.cursor()
        cur.executescript(self.SCHEMA)
        cur.close()

    def close(self):
        self.conn.close()

    @staticmethod
    def _dict_factory(cursor, row):
        fields = [column[0] for column in cursor.description]
        return {key: value for key, value in zip(fields, row)}

    def get(self, path):
        cur = self.conn.cursor()
        cur.execute(
            """
            SELECT p.path, p.size, p.mtime, i.sha256, i.type, i.fast, i.strip
            FROM paths p
            JOIN images i ON p.sha256 = i.sha256
            WHERE p.path = :path
            """,
            {"path": path},
        )
        row = cur.fetchone()
        cur.close()
        return row

    def get_by_sha256(self, sha256):
        cur = self.conn.cursor()
        cur.execute(
            "SELECT * FROM images WHERE sha256 = :sha256",
            {"sha256": sha256},
        )
        row = cur.fetchone()
        cur.close()
        return row

    def upsert_path(self, path, sha256, size, mtime):
        cur = self.conn.cursor()
        cur.execute(
            """
            INSERT INTO paths(path, sha256, size, mtime)
            VALUES(:path, :sha256, :size, :mtime)
            ON CONFLICT DO UPDATE
                SET sha256 = :sha256,
                    size = :size,
                    mtime = :mtime
            """,
            {"path": path, "sha256": sha256, "size": size, "mtime": mtime},
        )
        self.conn.commit()
        cur.close()

    def upsert(self, path, size, mtime, img_type, sha256, fast, strip):
        cur = self.conn.cursor()
        cur.execute(
            """
            INSERT INTO images(sha256, type, fast, strip, inserted_at)
            VALUES(:sha256, :type, :fast, :strip, unixepoch('now', 'subsec'))
            ON CONFLICT DO UPDATE
                SET type = :type,
                    fast = :fast,
                    strip = :strip,
                    inserted_at = unixepoch('now', 'subsec')
            """,
            {
                "sha256": sha256,
                "type": img_type,
                "fast": int(fast),
                "strip": int(strip),
            },
        )
        cur.execute(
            """
            INSERT INTO paths(path, sha256, size, mtime)
            VALUES(:path, :sha256, :size, :mtime)
            ON CONFLICT DO UPDATE
                SET sha256 = :sha256,
                    size = :size,
                    mtime = :mtime
            """,
            {
                "path": path,
                "sha256": sha256,
                "size": size,
                "mtime": mtime,
            },
        )
        self.conn.commit()
        cur.close()


@contextlib.contextmanager
def TempPath(**kwargs):
    """Wrapper around tempfile.NamedTemporaryFile which returns a path object

    Unlike tempfile.NamedTemporaryFile, the FileNotFoundError exception is not
    raised if the file is deleted before the context closes.

    :rtype: pathlib.Path
    """
    with tempfile.NamedTemporaryFile(**kwargs, delete=False) as tmp:
        temp_path = pathlib.Path(tmp.name)
        try:
            yield temp_path
        finally:
            try:
                temp_path.unlink()
            except FileNotFoundError:
                pass


def all_files(*paths):
    stack = []
    files = set()
    for path in paths:
        if not path.exists():
            raise ValueError(f"path does not exist: {path}")
        elif path.is_file():
            files.add(path)
        elif path.is_dir():
            stack.append(path)
    while stack:
        for path in stack.pop().iterdir():
            if path.is_dir():
                stack.append(path)
            else:
                files.add(path)
    return sorted(files)


async def optimize_jpeg(source, dest, fast=False, strip=False):
    args = [
        "jpegoptim",
        "--quiet",
        "--all-progressive",
        "--force",
        "--stdout",
    ]

    if strip:
        args.append("--strip-all")
    else:
        args.append("--strip-none")

    args.extend(["--", source])
    proc = await asyncio.create_subprocess_exec(
        *args, stdout=asyncio.subprocess.PIPE
    )
    stdout, _ = await proc.communicate()
    if proc.returncode != 0:
        raise ProcessError(proc)

    data = await asyncio.to_thread(
        mozjpeg_lossless_optimization.optimize, stdout
    )

    dest.write_bytes(data)

    # lossless rotation is not always possible - use EXIF instead
    if strip:
        orientation = await exiv2.get_orientation(source)

        # 1 is the default, "correct" orientation
        if orientation and orientation != 1:
            await exiv2.set_orientation(dest, orientation)
    else:
        await exiv2.copy_metadata(source, dest)


async def optimize_jxl(source, dest, fast=False, strip=False):
    args = [
        "cjxl",
        "--quiet",
        "--distance=0.0",
        "--effort=10",
        "--lossless_jpeg=1",
        "--",
        source,
        dest,
    ]
    proc = await asyncio.create_subprocess_exec(
        *args,
        stderr=asyncio.subprocess.DEVNULL,
    )
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def optimize_png(source, dest, fast=False, strip=False):
    args = ["oxipng", "--quiet", "--out", dest]
    if fast:
        args.append("--fast")
    else:
        args.extend(["--zopfli", "--opt", "max"])

    if strip:
        args.extend(["--strip", "safe"])

    args.extend(["--", source])
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def optimize_gif(source, dest, fast=False, strip=False):
    args = [
        "gifsicle",
        "--output=-",
        "--same-loopcount",
        "--same-delay",
        "--no-warnings",
        "--optimize=3",
        "--output",
        dest,
    ]

    if strip:
        args.extend(["--no-comments", "--no-names", "--no-extensions"])

    args.extend(["--", source])
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def optimize_svg(source, dest, fast=False, strip=False):
    args = [
        "svgo",
        "--quiet",
        "--multipass",
        "--input",
        source,
        "--output",
        dest,
    ]
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def optimize_tiff(source, dest, fast=False, strip=False, bigtiff=False):
    # some metadata is stripped?
    if not strip:
        raise RuntimeError("TIFF requires strip")

    args = [
        "tiffcp",
        "-c",
        "zstd",
    ]
    if bigtiff:
        args.append("-8")
    args.extend(
        [
            "--",
            source,
            dest,
        ]
    )
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


class exiftool:
    TIFF_TAGS = [
        "Make",
        "Model",
        "ResolutionUnit",
        "Software",
        "XResolution",
        "YResolution",
    ]

    TIFF_TAG_MAP = {
        "SubSecCreateDate": "CreateDate",
        "SubSecDateTimeOriginal": "DateTimeOriginal",
        "SubSecModifyDate": "ModifyDate",
    }

    @staticmethod
    async def to_json(path):
        proc = await asyncio.create_subprocess_exec(
            "exiftool",
            "-overwrite_original",
            "-quiet",
            "-json",
            "--",
            path,
            stdout=asyncio.subprocess.PIPE,
        )
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc)
        return json.loads(stdout)

    @staticmethod
    async def from_json(path, json_data):
        with TempPath() as tmp:
            tmp.write_text(json.dumps(json_data))
            proc = await asyncio.create_subprocess_exec(
                "exiftool",
                "-overwrite_original",
                "-quiet",
                f"-json={tmp}",
                "--",
                path,
                stdout=asyncio.subprocess.PIPE,
            )
            await proc.wait()
            if proc.returncode:
                raise ProcessError(proc)


class exiv2:
    EXIF_ORIENTATION = {
        "top, left": 1,
        "top, right": 2,
        "bottom, right": 3,
        "bottom, left": 4,
        "left, top": 5,
        "right, top": 6,
        "right, bottom": 7,
        "left, bottom": 8,
    }

    @classmethod
    async def get_orientation(cls, path):
        proc = await asyncio.create_subprocess_exec(
            "exiv2",
            "--key",
            "Exif.Image.Orientation",
            "--",
            path,
            stderr=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await proc.communicate()

        # Exif.Image.Orientation not present in file
        if proc.returncode == 1 and not stderr:
            return None
        elif proc.returncode != 0:
            raise ProcessError(proc)

        _, _, _, value = stdout.decode().split(maxsplit=3)
        value = value.strip()
        if value != "(0)":
            return cls.EXIF_ORIENTATION[value.strip()]

    @staticmethod
    async def set_orientation(path, orientation):
        proc = await asyncio.create_subprocess_exec(
            "exiv2",
            "--Modify",
            f"set Exif.Image.Orientation {orientation}",
            "mo",
            path,
            stderr=asyncio.subprocess.PIPE,
        )
        _, stderr = await proc.communicate()
        if stderr or proc.returncode != 0:
            raise ProcessError(proc)

    @staticmethod
    async def copy_metadata(source, target):
        read, write = os.pipe()
        proc1 = await asyncio.create_subprocess_exec(
            "exiv2",
            "-ea-",
            "--",
            source,
            stderr=asyncio.subprocess.PIPE,
            stdout=write,
        )
        os.close(write)
        proc2 = await asyncio.create_subprocess_exec(
            "exiv2",
            "-ia-",
            "--",
            target,
            stderr=asyncio.subprocess.PIPE,
            stdin=read,
        )
        os.close(read)
        for proc in (proc1, proc2):
            _, stderr = await proc.communicate()
            # treat warnings as errors
            if stderr or proc.returncode != 0:
                raise ProcessError(proc)


class magick_convert:
    @staticmethod
    async def get_number_of_frames(path):
        proc = await asyncio.create_subprocess_exec(
            "magick",
            "convert",
            path,
            "-format",
            "%n\n",
            "info:",
            stderr=asyncio.subprocess.DEVNULL,
            stdout=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc)
        # macos dynamic wallpaper SequoiaDynamic.heic results in two lines, each being 2
        # not sure why
        stdout = set(int(v) for v in stdout.decode().splitlines())
        if len(stdout) != 1:
            raise RuntimeError
        return stdout.pop()


class ProcessError(Exception):
    def __init__(self, process, message=None):
        self.process = process
        self.message = message

    def __str__(self):
        proc = self.process

        text = f"exit {proc.returncode}"
        if self.message is not None:
            text = f"{text} - {self.message}"

        try:
            args = proc._transport._extra["subprocess"].args
        except (AttributeError, KeyError):
            pass
        else:
            text = f"{text}: {args}"
        return text


class InvalidSourceImage(Exception):
    """Raised when a source image is not valid"""

    def __init__(self, path, message=None):
        self.path = path
        self.message = message

    def __str__(self):
        return f"{self.message}: {self.path}"


_MIME_OPTIM = {
    "image/gif": optimize_gif,
    "image/jpeg": optimize_jpeg,
    "image/jxl": optimize_jxl,
    "image/png": optimize_png,
    "image/svg+xml": optimize_svg,
    "image/tiff": optimize_tiff,
}

_TYPE_TO_MIME = {
    "bmp": "image/bmp",
    "gif": "image/gif",
    "heic": "image/heif",
    "jpeg": "image/jpeg",
    "jxl": "image/jxl",
    "png": "image/png",
    "ppm": "image/x-portable-pixmap",
    "svg": "image/svg+xml",
    "tiff": "image/tiff",
}


_MIME_SUFFIXES = {
    "application/x-krita": (".kra",),
    "image/bmp": (".bmp",),
    "image/gif": (".gif",),
    "image/heif": (".heic",),
    "image/jpeg": (".jpg", ".jpeg"),
    "image/jxl": (".jxl",),
    "image/png": (".png",),
    "image/svg+xml": (".svg",),
    "image/tiff": (".tiff", ".tif"),
    "image/webp": (".webp",),
    "image/x-portable-pixmap": (".ppm",),
}

# tiff support is experimental
_DEFAULT_TYPES = {
    "gif",
    "jpeg",
    "png",
}


def determine_mime(path):
    # roughly 2.5x faster than using libmagic
    with open(path, "rb") as f:
        start = f.read(12)
        if start[0:8] == b"\x89PNG\r\n\x1a\n":
            return "image/png", {}
        elif start[0:3] == b"P6\x0a":
            return "image/x-portable-pixmap", {}
        elif start[0:3] == b"\xff\xd8\xff":
            return "image/jpeg", {}
        elif start[0:6] in (b"GIF87a", b"GIF89a"):
            return "image/gif", {}
        elif start[0:4] == b"\x49\x49\x2b\x00":
            # little endian, bigtiff
            return "image/tiff", {"bigtiff": True}
        elif start[0:4] == b"\x49\x49\x2a\x00":
            # little endian
            return "image/tiff", {"bigtiff": False}
        elif start[0:4] == b"\x4d\x4d\x00\x2a":
            # big endian
            return "image/tiff", {"bigtiff": False}
        elif start[0:5] == b"<svg ":
            return "image/svg+xml", {}
        elif start[0:6] == b"<?svg ":
            return "image/svg+xml", {}
        elif (
            start[0:12] == b"\x00\x00\x00\x0c\x4a\x58\x4c\x20\x0d\x0a\x87\x0a"
        ):
            return "image/jxl", {}
        elif start[4:12] == b"ftypheic":
            return "image/heif", {}

        # start[4:8] contains the file size
        elif start[0:4] == b"RIFF" and start[8:12] == b"WEBP":
            return "image/webp", {}

        elif start[0:2] == b"\xff\x0a":
            return "image/jxl", {}
        elif start[0:2] == b"\x42\x4d":
            return "image/bmp", {}
        elif path.suffix.lower() == ".svg":
            return "image/svg+xml", {}
        elif path.suffix.lower() == ".kra":
            return "application/x-krita", {}
    return None, None


def _sigint_handler(*_):
    sys.exit(130)


async def is_animated_gif(path):
    proc = await asyncio.create_subprocess_exec(
        "vipsheader",
        "--all",
        "----field=vips-loader",
        "--field=n-pages",
        "--",
        path,
        stdout=asyncio.subprocess.PIPE,
    )
    stdout, _ = await proc.communicate()
    if proc.returncode:
        raise ProcessError(proc)
    vips_loader, n_pages = stdout.decode().splitlines()
    if vips_loader != "gifloader":
        raise ValueError("not a gif file")
    return int(n_pages) > 1


async def convert_to_jpeg(*args, **kwargs):
    if shutil.which("cjpegli"):
        return await convert_to_jpeg_cjpegli(*args, **kwargs)
    else:
        return await convert_to_jpeg_cjpeg(*args, **kwargs)


async def convert_to_jpeg_cjpeg(source, dest):
    args = [
        "cjpeg",
        "-quality",
        str(CONFIG.jpeg.quality),
        source,
        dest,
    ]
    proc = await asyncio.create_subprocess_exec(
        *args,
        stderr=asyncio.subprocess.DEVNULL,
    )
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)

    data = await asyncio.to_thread(
        mozjpeg_lossless_optimization.optimize, dest.read_bytes()
    )
    dest.write_bytes(data)


async def convert_to_jpeg_cjpegli(source, dest):
    args = [
        "cjpegli",
        f"--quality={CONFIG.jpeg.quality}",
        "--",
        source,
        dest,
    ]
    proc = await asyncio.create_subprocess_exec(
        *args,
        stderr=asyncio.subprocess.DEVNULL,
    )
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)

    data = await asyncio.to_thread(
        mozjpeg_lossless_optimization.optimize, dest.read_bytes()
    )
    dest.write_bytes(data)


async def convert_djxl(source, dest):
    args = [
        "djxl",
        "--",
        source,
        dest,
    ]
    proc = await asyncio.create_subprocess_exec(
        *args,
        stderr=asyncio.subprocess.DEVNULL,
    )
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def convert_to_ppm(source, dest):
    args = [
        "vips",
        "ppmsave",
        "--keep=none",
        "--",
        source,
        dest,
    ]
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def convert_to_bmp(source, dest, fast=True):
    args = [
        "vips",
        "magicksave",
        "--format=BMP",
        "--",
        source,
        dest,
    ]
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def convert_to_png(source, dest, fast=True):
    args = [
        "vips",
        "pngsave",
        "--compression=0",
        "--",
        source,
        dest,
    ]
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def convert_svg_to_png(source, dest, max_w, max_h):
    args = [
        "inkscape",
        "--export-type=png",
        "--export-area-page",
    ]
    if max_w:
        args.append(f"--export-width={max_w}")
    if max_h:
        args.append(f"--export-height={max_h}")
    args.extend(["-o", dest, "--", source])
    proc = await asyncio.create_subprocess_exec(
        *args,
        stderr=asyncio.subprocess.DEVNULL,
    )
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def convert_to_jxl(source, dest, fast=False):
    args = [
        "cjxl",
        "--quiet",
        f"--distance={CONFIG.jxl.distance}",
        f"--effort={CONFIG.jxl.effort}",
        f"--lossless_jpeg={1 if CONFIG.jxl.distance == '0.0' else 0}",
    ]

    args.extend(
        [
            "--",
            source,
            dest,
        ]
    )
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def convert_to_tiff_vips(source, dest):
    args = [
        "vips",
        "tiffsave",
        source,
        dest,
    ]
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def convert_to_jxl_vips(source, dest):
    args = [
        "vips",
        "jxlsave",
        source,
        dest,
        "--lossless=true",
    ]
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def convert_from_kra(source, dest):
    args = []
    if shutil.which("systemd-run"):
        args.extend(
            ["systemd-run", "--user", "--pty", "--same-dir", "--collect", "--"]
        )
    args.extend(
        [
            "krita",
            "--platform",
            "offscreen",
            "--export",
            "--export-filename",
            dest,
            "--",
            source,
        ]
    )
    proc = await asyncio.create_subprocess_exec(
        *args,
        stdout=asyncio.subprocess.DEVNULL,
        stderr=asyncio.subprocess.DEVNULL,
    )
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def _process_optim(
    func, path, fast, strip, compute_hash=False, **options
):
    before = path.stat().st_size

    with TempPath(
        dir=path.parent, prefix=".imgoptim_", suffix=path.name + ".tmp"
    ) as temp_path:
        await func(path, temp_path, fast=fast, strip=strip, **options)

        after = temp_path.stat().st_size
        if after < before:
            temp_path.replace(path)
        else:
            after = before

    sha256 = None
    if compute_hash:
        data = await asyncio.to_thread(path.read_bytes)
        sha256 = await asyncio.to_thread(
            lambda: hashlib.sha256(data).hexdigest()
        )

    return path, before, after, sha256


_SUPPORTED_CONVERT_SUFFIXES = {
    "image/jpeg": [
        "image/png",
        "image/ppm",
    ],
    "image/jxl": [
        "image/heif",
        "image/jpeg",
        "image/png",
        "image/ppm",
    ],
}


async def _process_convert(path, source_mimetype, target_mimetype, **options):
    source_suffixes = _MIME_SUFFIXES[source_mimetype]
    name = path.name
    if path.suffix.lower() in source_suffixes:
        name = path.stem

    target_suffixes = _MIME_SUFFIXES[target_mimetype]
    has_proper_suffix = False
    for suffix in target_suffixes:
        if name.lower().endswith(suffix):
            has_proper_suffix = True
            break

    if not has_proper_suffix:
        name = name + target_suffixes[0]

    match source_mimetype:
        case "image/gif":
            if await is_animated_gif(path):
                raise NotImplementedError("gif is animated")
        case "image/heif":
            num_frames = await magick_convert.get_number_of_frames(path)
            if num_frames != 1:
                raise InvalidSourceImage(
                    path, "heif must contain exactly one frame"
                )

    dest = path.parent / name
    with contextlib.ExitStack() as stack:
        temp_path = stack.enter_context(
            TempPath(
                dir=path.parent,
                prefix=".imgconvert_",
                suffix=path.name + ".tmp",
            )
        )
        match target_mimetype:
            case "image/bmp":
                match source_mimetype:
                    case "application/x-krita":
                        kra_png = stack.enter_context(
                            TempPath(
                                dir=path.parent,
                                prefix=".imgconvert_",
                                suffix=".png",
                            )
                        )
                        await convert_from_kra(path, kra_png)
                        await convert_to_bmp(kra_png, temp_path)
                    case _:
                        await convert_to_bmp(path, temp_path)
                temp_path.replace(dest)
            case "image/x-portable-pixmap":
                match source_mimetype:
                    case "application/x-krita":
                        kra_png = stack.enter_context(
                            TempPath(
                                dir=path.parent,
                                prefix=".imgconvert_",
                                suffix=".png",
                            )
                        )
                        await convert_from_kra(path, kra_png)
                        await convert_to_ppm(kra_png, temp_path)
                    case _:
                        await convert_to_ppm(path, temp_path)
                temp_path.replace(dest)
            case "image/png":
                match source_mimetype:
                    case "image/svg+xml":
                        max_w = options.get("max_w")
                        max_h = options.get("max_h")
                        png_temp = stack.enter_context(
                            TempPath(
                                dir=path.parent,
                                prefix=".imgconvert_",
                                suffix=".png",
                            )
                        )
                        await convert_svg_to_png(path, png_temp, max_w, max_h)
                        png_temp.replace(dest)
                    case "application/x-krita":
                        kra_png = stack.enter_context(
                            TempPath(
                                dir=path.parent,
                                prefix=".imgconvert_",
                                suffix=".png",
                            )
                        )
                        await convert_from_kra(path, kra_png)
                        kra_png.replace(dest)
                    case _:
                        await convert_to_png(path, temp_path)
                        temp_path.replace(dest)
            case "image/tiff":
                match source_mimetype:
                    case "image/jxl":
                        metadata = await exiftool.to_json(path)
                        if len(metadata) != 1:
                            raise RuntimeError
                        metadata = metadata[0]
                        await convert_to_tiff_vips(path, temp_path)
                        new_metadata = {}
                        for key in exiftool.TIFF_TAGS:
                            if key in metadata:
                                new_metadata[key] = metadata[key]
                        for k1, k2 in exiftool.TIFF_TAG_MAP.items():
                            if k1 in metadata:
                                v = metadata[k1]
                            elif k2 in metadata:
                                v = metadata[k2]
                            else:
                                continue
                            new_metadata[k1] = v
                        await exiftool.from_json(temp_path, new_metadata)
                    case "application/x-krita":
                        kra_png = stack.enter_context(
                            TempPath(
                                dir=path.parent,
                                prefix=".imgconvert_",
                                suffix=".png",
                            )
                        )
                        await convert_from_kra(path, kra_png)
                        await convert_to_tiff_vips(kra_png, temp_path)
                    case _:
                        await convert_to_tiff_vips(path, temp_path)
                temp_path.replace(dest)
            case "image/jxl":
                match source_mimetype:
                    case "image/heif":
                        temp_path_2 = stack.enter_context(
                            TempPath(
                                dir=path.parent,
                                prefix=".imgconvert_",
                                suffix=path.name + ".tmp",
                            )
                        )
                        await convert_to_ppm(path, temp_path_2)
                        await convert_to_jxl(temp_path_2, temp_path)
                    case "image/tiff":
                        metadata = await exiftool.to_json(path)
                        if len(metadata) != 1:
                            raise RuntimeError
                        metadata = metadata[0]
                        await convert_to_jxl_vips(path, temp_path)
                        new_metadata = {}
                        for key in exiftool.TIFF_TAGS:
                            if key in metadata:
                                new_metadata[key] = metadata[key]
                        for k1, k2 in exiftool.TIFF_TAG_MAP.items():
                            if k1 in metadata:
                                v = metadata[k1]
                            elif k2 in metadata:
                                v = metadata[k2]
                            else:
                                continue
                            new_metadata[k1] = v
                        await exiftool.from_json(temp_path, new_metadata)
                    case "application/x-krita":
                        kra_png = stack.enter_context(
                            TempPath(
                                dir=path.parent,
                                prefix=".imgconvert_",
                                suffix=".png",
                            )
                        )
                        await convert_from_kra(path, kra_png)
                        await convert_to_jxl(kra_png, temp_path)
                    case _:
                        await convert_to_jxl(path, temp_path)
                temp_path.replace(dest)
            case "image/jpeg":
                match source_mimetype:
                    case "image/heif" | "image/webp":
                        temp_path_2 = stack.enter_context(
                            TempPath(
                                dir=path.parent,
                                prefix=".imgconvert_",
                                suffix=path.name + ".tmp",
                            )
                        )
                        await convert_to_ppm(path, temp_path_2)
                        await convert_to_jpeg(temp_path_2, temp_path)
                    case "image/jxl":
                        temp_path_2 = stack.enter_context(
                            TempPath(
                                dir=path.parent,
                                prefix=".imgconvert_",
                                suffix=path.name + ".jpg",
                            )
                        )
                        await convert_djxl(path, temp_path_2)
                        temp_path_2.replace(temp_path)
                    case "application/x-krita":
                        kra_png = stack.enter_context(
                            TempPath(
                                dir=path.parent,
                                prefix=".imgconvert_",
                                suffix=".png",
                            )
                        )
                        await convert_from_kra(path, kra_png)
                        await convert_to_jpeg(kra_png, temp_path)
                    case _:
                        await convert_to_jpeg(path, temp_path)
                temp_path.replace(dest)
            case _:
                raise RuntimeError("invalid target_type")
    return path, dest


class SizeDiffPrinter:
    def __init__(self, num_items):
        self._before_total = 0
        self._after_total = 0
        self._num_items = num_items
        self._num_printed = 0
        self._printed = False

    @staticmethod
    def format_diff(before, after):
        diff = ((before - after) / before) * 100
        if diff:
            diff = "{:.2f}".format(diff)
            if not float(diff):
                diff = f"<{diff}"
        return diff

    @staticmethod
    def sizeof_fmt(num):
        for unit in ["B", "KB", "MB", "GB", "TB", "PB"]:
            if abs(num) < 1024.0:
                break
            num /= 1024.0
        return f"{num:.1f}{unit}"

    def print(self, before, after, name):
        self._num_printed += 1
        self._before_total += before
        self._after_total += after
        diff = self.format_diff(before, after)

        s = f"{diff:>6}%" if diff else 7 * "-"
        num_printed = str(self._num_printed).rjust(len(str(self._num_items)))
        print(f"({num_printed}/{self._num_items})\t{s}\t{name}")

    def print_total(self):
        if self._num_printed:
            if diff := self.format_diff(self._before_total, self._after_total):
                fmt = self.sizeof_fmt(self._before_total - self._after_total)
                print(f"Total: {diff}% ({fmt})")
            else:
                print("Total: -")


def _num_procs(value):
    value = int(value)
    if value == 0:
        return os.cpu_count()
    elif value > 0:
        return value
    else:
        raise argparse.ArgumentError("invalid num_procs")


def _parser_path_file(value):
    path = pathlib.Path(value)
    if path.is_file():
        return path
    elif path.is_dir():
        raise argparse.ArgumentError("path must be file")
    else:
        raise argparse.ArgumentError("invalid path")


def _positive_int(value):
    v = int(value)
    if v <= 0:
        raise argparse.ArgumentTypeError("must be positive")
    return v


async def sha256sum(pipe):
    proc = await asyncio.create_subprocess_exec(
        "sha256sum", stdin=pipe, stdout=asyncio.subprocess.PIPE
    )
    os.close(pipe)
    stdout, _ = await proc.communicate()
    if proc.returncode:
        raise ProcessError(proc)
    return stdout.split()[0].decode()


async def sha256sum_djxl(source):
    read, write = os.pipe()
    proc = await asyncio.create_subprocess_exec(
        "djxl",
        "--quiet",
        "--output_format=ppm",
        "--",
        source,
        "-",
        stdout=write,
    )
    os.close(write)
    sha256 = await sha256sum_vips_copy(read)
    await proc.wait()
    if proc.returncode:
        raise ProcessError(proc)
    return sha256


async def sha256sum_vips_copy(source):
    read1, write1 = os.pipe()
    if isinstance(source, int):
        proc1 = await asyncio.create_subprocess_exec(
            "vips", "copy", "stdin[]", ".ppm[]", stdin=source, stdout=write1
        )
        os.close(source)
    else:
        proc1 = await asyncio.create_subprocess_exec(
            "vips", "copy", source, ".ppm[]", stdout=write1
        )
    os.close(write1)

    read2, write2 = os.pipe()
    proc2 = await asyncio.create_subprocess_exec(
        "magick",
        "ppm:-",
        "-set",
        "comment",
        "",
        "ppm:-",
        stdin=read1,
        stdout=write2,
    )
    os.close(write2)

    sha256 = await sha256sum(read2)
    for proc in (proc1, proc2):
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc)
    return sha256


async def main_compare():
    parser = argparse.ArgumentParser()
    parser.add_argument("paths", metavar="path", nargs=2)
    args = parser.parse_args()

    for path in args.paths:
        mimetype, _ = determine_mime(path)
        match mimetype:
            case "image/jxl":
                res = await sha256sum_djxl(path)
                print(res)
            case "image/jpeg":
                res = await sha256sum_vips_copy(path)
                print(res)
            case _:
                raise NotImplementedError
    # vips copy 'stdin[]' '.ppm[]' < "$1" | tail -n+3 | sha256sum | awk '{print $1}'


async def main_convert():
    parser = argparse.ArgumentParser(
        formatter_class=lambda prog: argparse.HelpFormatter(
            prog,
            max_help_position=30,  # Position where help text starts
            width=80,  # Total width of output
        )
    )
    parser.add_argument(
        "-n",
        metavar="NUM",
        dest="num_procs",
        type=_num_procs,
        default=None,
        help="number of parallel jobs (default: %(default)s)",
    )
    parser.add_argument("--rm", action="store_true")
    parser.add_argument(
        "-f",
        "--format",
        dest="format",
        choices=("bmp", "jpeg", "jxl", "png", "ppm", "tiff"),
        required=True,
    )
    parser.add_argument("--fast", action="store_true")
    parser.add_argument(
        "paths", metavar="path", nargs="+", type=_parser_path_file
    )

    jpeg_group = parser.add_argument_group("JPEG Options")
    jpeg_group.add_argument(
        "--jpeg-quality",
        metavar="[0-100]",
        type=int,
        default=CONFIG.jpeg.quality,
        help="default: %(default)s",
    )

    jxl_group = parser.add_argument_group("JXL Options")
    jxl_group.add_argument(
        "--jxl-lossy",
        action="store_true",
        default=False,
        help="default: %(default)s",
    )

    png_group = parser.add_argument_group("PNG Options (SVG source)")
    png_group.add_argument(
        "-W",
        "--width",
        type=_positive_int,
        default=None,
        help="output width in pixels",
    )
    png_group.add_argument(
        "-H",
        "--height",
        type=_positive_int,
        default=None,
        help="output height in pixels",
    )

    args = parser.parse_args()

    CONFIG.jpeg.quality = args.jpeg_quality

    if args.jxl_lossy:
        CONFIG.jxl.distance = "1.0"  # visually lossless

    if args.fast:
        CONFIG.jxl.effort = "7"

    executor = async_executor.AsyncExecutor(args.num_procs)
    for path in args.paths:
        try:
            mimetype, _ = determine_mime(path)
        except (FileNotFoundError, IsADirectoryError):
            # broken symlink can cause this
            continue

        executor.submit(
            _process_convert,
            path,
            source_mimetype=mimetype,
            target_mimetype=_TYPE_TO_MIME[args.format],
            max_w=args.width,
            max_h=args.height,
        )

    has_error = False
    async for result in executor:
        try:
            source, dest = result.result()
        except ProcessError as e:
            # TODO give this a competent error message
            print(f"error: {e}", file=sys.stderr)
            has_error = True
            continue
        except InvalidSourceImage as e:
            print(f"error: {e}", file=sys.stderr)
            has_error = True
            continue
        print(source, "->", dest)
        try:
            if args.rm and source != dest:
                source.unlink()
        except FileNotFoundError:
            pass
    if has_error:
        sys.exit(1)


async def main_optim():
    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--strip", action="store_true")
    parser.add_argument(
        "-t",
        "--type",
        dest="types",
        action="append",
        default=[],
        choices=_TYPE_TO_MIME,
        help="filetypes to process. may be specified more than once.",
    )
    parser.add_argument("--fast", action="store_true")
    parser.add_argument(
        "-n",
        metavar="NUM",
        dest="num_procs",
        type=_num_procs,
        default=None,
        help="number of parallel jobs (default: %(default)s)",
    )
    parser.add_argument("-q", "--quiet", action="store_true")
    parser.add_argument(
        "--cache",
        action="store_true",
        help="skip files already processed with same options",
    )
    parser.add_argument(
        "--cache-path",
        type=pathlib.Path,
        default=pathlib.Path.home() / ".cache" / "imgoptim.db",
        help="path to cache database (default: ~/.cache/imgoptim.db)",
    )
    parser.add_argument("paths", metavar="path", nargs="+", type=pathlib.Path)

    args = parser.parse_args()

    mimetypes = set(_TYPE_TO_MIME[t] for t in (args.types or _DEFAULT_TYPES))

    cache = None
    if args.cache:
        cache = ImageOptimCache(args.cache_path)

    executor = async_executor.AsyncExecutor(args.num_procs)
    future_to_file = {}
    for file in all_files(*args.paths):
        try:
            mimetype, options = determine_mime(file)
        except (FileNotFoundError, IsADirectoryError):
            # broken symlink can cause this
            continue

        if mimetype not in mimetypes:
            continue

        if cache:
            abs_path = str(file.absolute())
            stat = file.stat()
            cached = cache.get(abs_path)

            def should_skip(rec):
                # fast=0 strip=1 is most thorough, always skip
                if rec["fast"] == 0 and rec["strip"] == 1:
                    return True
                # otherwise skip only if args match
                if rec["fast"] == int(args.fast) and rec["strip"] == int(
                    args.strip
                ):
                    return True
                return False

            if cached:
                if (
                    cached["size"] == stat.st_size
                    and cached["mtime"] == stat.st_mtime
                    and cached["type"] == mimetype
                    and should_skip(cached)
                ):
                    continue
            else:
                # path not in cache, check if content already optimized
                data = file.read_bytes()
                sha256 = hashlib.sha256(data).hexdigest()
                img_rec = cache.get_by_sha256(sha256)
                if img_rec and img_rec["type"] == mimetype:
                    cache.upsert_path(
                        abs_path, sha256, stat.st_size, stat.st_mtime
                    )
                    if should_skip(img_rec):
                        continue

        if func := _MIME_OPTIM.get(mimetype):
            future = executor.submit(
                _process_optim,
                func,
                file,
                fast=args.fast,
                strip=args.strip,
                compute_hash=bool(cache),
                **options,
            )
            future_to_file[future] = (file, mimetype)

    size_diff_printer = SizeDiffPrinter(num_items=len(executor))
    async for future in executor:
        try:
            path, before, after, sha256 = future.result()
        except ProcessError as e:
            # TODO give this a competent error message
            print(f"error: {e}", file=sys.stderr)
            continue

        if cache:
            _, mimetype = future_to_file[future]
            stat = path.stat()
            cache.upsert(
                str(path.absolute()),
                stat.st_size,
                stat.st_mtime,
                mimetype,
                sha256,
                args.fast,
                args.strip,
            )

        if not args.quiet:
            size_diff_printer.print(before, after, path)

    if cache:
        cache.close()

    if not args.quiet:
        size_diff_printer.print_total()


async def _has_incorrect_colorspace(path):
    proc = await asyncio.create_subprocess_exec(
        "magick",
        "identify",
        "-quiet",
        "-format",
        "%[colorspace]",
        path,
        stdout=asyncio.subprocess.PIPE,
    )
    stdout, _ = await proc.communicate()
    if proc.returncode:
        raise ProcessError(proc)

    colorspace = stdout.decode()
    if colorspace == "Gray":
        return False

    proc = await asyncio.create_subprocess_exec(
        "magick",
        path,
        "-colorspace",
        "HSB",
        "-channel",
        "green",
        "-separate",
        "+channel",
        "-format",
        "%[fx:100*mean>0?1:0]",
        "info:",
        stdout=asyncio.subprocess.PIPE,
    )
    stdout, _ = await proc.communicate()
    if proc.returncode:
        raise ProcessError(proc)
    return stdout.decode() == "0"


async def _fix_colorspace(path):
    with TempPath(
        dir=path.parent, prefix=".imgfixcolorspace", suffix=".png"
    ) as tmp:
        proc = await asyncio.create_subprocess_exec(
            "magick",
            path,
            "-depth",
            "4",
            "-colorspace",
            "Gray",
            "-define",
            "png:compression-level=0",
            tmp,
        )
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc)
        tmp.replace(path)


async def main_fixcolorspace():
    parser = argparse.ArgumentParser()
    parser.add_argument("paths", metavar="path", nargs="+", type=pathlib.Path)
    args = parser.parse_args()

    executor = async_executor.AsyncExecutor()
    executor2 = async_executor.AsyncExecutor()

    fut_to_path = {}
    for path in all_files(*args.paths):
        if determine_mime(path)[0] == "image/png":
            fut = executor.submit(_has_incorrect_colorspace, path)
            fut_to_path[fut] = path

    print("Checking for incorrect colorspaces")
    done = 0
    total = 0
    async for fut in executor:
        path = fut_to_path[fut]
        if fut.result():
            executor2.submit(_fix_colorspace, path)
            total += 1
        done += 1
        print(f"{done} / {len(fut_to_path)}")

    print("Fixing incorrect colorspaces")
    done = 0
    async for fut in executor2:
        fut.result()
        done += 1
        print(f"{done} / {total}")


if __name__ == "__main__":
    signal.signal(signal.SIGINT, _sigint_handler)
    match pathlib.Path(sys.argv[0]).name:
        case "imgcompare":
            asyncio.run(main_compare())
        case "imgconvert":
            asyncio.run(main_convert())
        case "imgfixcolorspace":
            asyncio.run(main_fixcolorspace())
        case "imgoptim" | _:
            asyncio.run(main_optim())
