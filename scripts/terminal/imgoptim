#!/usr/bin/env python
import argparse
import asyncio
import contextlib
import os
import pathlib
import signal
import sys
import tempfile

import async_executor
import mozjpeg_lossless_optimization


@contextlib.contextmanager
def TempPath(**kwargs):
    """Wrapper around tempfile.NamedTemporaryFile which returns a path object

    Unlike tempfile.NamedTemporaryFile, the FileNotFoundError exception is not
    raised if the file is deleted before the context closes.

    :rtype: pathlib.Path
    """
    with tempfile.NamedTemporaryFile(**kwargs, delete=False) as tmp:
        temp_path = pathlib.Path(tmp.name)
        try:
            yield temp_path
        finally:
            try:
                temp_path.unlink()
            except FileNotFoundError:
                pass


def all_files(*paths):
    stack = []
    files = set()
    for path in paths:
        if not path.exists():
            raise ValueError(f'path does not exist: {path}')
        elif path.is_file():
            files.add(path)
        elif path.is_dir():
            stack.append(path)
    while stack:
        for path in stack.pop().iterdir():
            if path.is_dir():
                stack.append(path)
            else:
                files.add(path)
    return sorted(files)


async def optimize_jpeg(source, dest, fast=False, strip=False):
    args = [
        'jpegoptim', '--quiet', '--all-progressive',
        '--force', '--stdout',
    ]

    if strip:
        args.append('--strip-all')
    else:
        args.append('--strip-none')

    args.extend(['--', source])
    proc = await asyncio.create_subprocess_exec(
        *args,
        stdout=asyncio.subprocess.PIPE)
    stdout, _ = await proc.communicate()
    if proc.returncode != 0:
        raise ProcessError(proc)

    data = await asyncio.to_thread(
            mozjpeg_lossless_optimization.optimize, stdout)

    dest.write_bytes(data)

    # lossless rotation is not always possible - use EXIF instead
    if strip:
        orientation = await exiv2.get_orientation(source)

        # 1 is the default, "correct" orientation
        if orientation and orientation != 1:
            await exiv2.set_orientation(dest, orientation)
    else:
        await exiv2.copy_metadata(source, dest)


async def optimize_jxl(source, dest, fast=False, strip=False):
    args = [
        'cjxl',
        '--quiet',
        '--distance=0.0',
        '--effort=10',
        '--lossless_jpeg=1',
        '--', source, dest,
    ]
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def optimize_png(source, dest, fast=False, strip=False):
    args = ['oxipng', '--quiet', '--out', dest]
    if fast:
        args.append('--fast')
    else:
        args.extend(['--zopfli', '--opt', 'max'])

    if strip:
        args.extend(['--strip', 'safe'])

    args.extend(['--', source])
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def optimize_gif(source, dest, fast=False, strip=False):
    args = [
        'gifsicle', '--output=-', '--same-loopcount', '--same-delay',
        '--no-warnings', '--optimize=3', '--output', dest,
    ]

    if strip:
        args.extend(['--no-comments', '--no-names', '--no-extensions'])

    args.extend(['--', source])
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def optimize_svg(source, dest, fast=False, strip=False):
    args = [
        'svgo',
        '--quiet',
        '--multipass',
        '--input', source,
        '--output', dest,
    ]
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def optimize_tiff(source, dest, fast=False, strip=False, bigtiff=False):
    # some metadata is stripped?
    if not strip:
        raise RuntimeError('TIFF requires strip')

    args = [
        'tiffcp',
        '-c', 'zstd',
    ]
    if bigtiff:
        args.append('-8')
    args.extend([
        '--',
        source,
        dest,
    ])
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


class exiv2:

    EXIF_ORIENTATION = {
        'top, left': 1,
        'top, right': 2,
        'bottom, right': 3,
        'bottom, left': 4,
        'left, top': 5,
        'right, top': 6,
        'right, bottom': 7,
        'left, bottom': 8,
    }

    @classmethod
    async def get_orientation(cls, path):
        proc = await asyncio.create_subprocess_exec(
            'exiv2', '--key', 'Exif.Image.Orientation', '--', path,
            stderr=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE)
        stdout, stderr = await proc.communicate()

        # Exif.Image.Orientation not present in file
        if proc.returncode == 1 and not stderr:
            return None
        elif proc.returncode != 0:
            raise ProcessError(proc)

        _, _, _, value = stdout.decode().split(maxsplit=3)
        value = value.strip()
        if value != '(0)':
            return cls.EXIF_ORIENTATION[value.strip()]

    @staticmethod
    async def set_orientation(path, orientation):
        proc = await asyncio.create_subprocess_exec(
            'exiv2', '--Modify', f'set Exif.Image.Orientation {orientation}',
            'mo', path,
            stderr=asyncio.subprocess.PIPE)
        _, stderr = await proc.communicate()
        if stderr or proc.returncode != 0:
            raise ProcessError(proc)

    @staticmethod
    async def copy_metadata(source, target):
        read, write = os.pipe()
        proc1 = await asyncio.create_subprocess_exec(
            'exiv2', '-ea-', '--', source,
            stderr=asyncio.subprocess.PIPE,
            stdout=write)
        os.close(write)
        proc2 = await asyncio.create_subprocess_exec(
            'exiv2', '-ia-', '--', target,
            stderr=asyncio.subprocess.PIPE,
            stdin=read)
        os.close(read)
        for proc in (proc1, proc2):
            _, stderr = await proc.communicate()
            # treat warnings as errors
            if stderr or proc.returncode != 0:
                raise ProcessError(proc)


class ProcessError(Exception):
    def __init__(self, process, message=None):
        self.process = process
        self.message = message

    def __str__(self):
        proc = self.process

        text = f'exit {proc.returncode}'
        if self.message is not None:
            text = f'{text} - {self.message}'

        try:
            args = proc._transport._extra['subprocess'].args
        except (AttributeError, KeyError):
            pass
        else:
            text = f'{text}: {args}'
        return text


_MIME_OPTIM = {
    'image/gif': optimize_gif,
    'image/jpeg': optimize_jpeg,
    'image/jxl': optimize_jxl,
    'image/png': optimize_png,
    'image/svg+xml': optimize_svg,
    'image/tiff': optimize_tiff,
}

_TYPE_TO_MIME = {
    'gif': 'image/gif',
    'jpeg': 'image/jpeg',
    'jxl': 'image/jxl',
    'png': 'image/png',
    'ppm': 'image/x-portable-pixmap',
    'svg': 'image/svg+xml',
    'tiff': 'image/tiff',
}


_MIME_SUFFIXES = {
    'image/bmp': ('.bmp',),
    'image/jpeg': ('.jpg', '.jpeg'),
    'image/jxl': ('.jxl',),
    'image/png': ('.png',),
    'image/x-portable-pixmap': ('.ppm',),
    'image/tiff': ('.tiff',),
}

# tiff support is experimental
_DEFAULT_TYPES = {
    'gif', 'jpeg', 'png',
}


def determine_mime(path):
    # roughly 2.5x faster than using libmagic
    with open(path, 'rb') as f:
        start = f.read(12)
        if start == b'\x89PNG\r\n\x1a\n':
            return 'image/png', {}
        elif start[0:3] == b'\xff\xd8\xff':
            return 'image/jpeg', {}
        elif start[0:6] in (b'GIF87a', b'GIF89a'):
            return 'image/gif', {}
        elif start[0:4] == b'\x49\x49\x2b\x00':
            # little endian, bigtiff
            return 'image/tiff', {'bigtiff': True}
        elif start[0:4] == b'\x49\x49\x2a\x00':
            # little endian
            return 'image/tiff', {'bigtiff': False}
        elif start[0:4] == b'\x4d\x4d\x00\x2a':
            # big endian
            return 'image/tiff', {'bigtiff': False}
        elif start[0:5] == b'<svg ':
            return 'image/svg+xml', {}
        elif start[0:6] == b'<?svg ':
            return 'image/svg+xml', {}
        elif start[0:12] == b'\x00\x00\x00\x0c\x4a\x58\x4c\x20\x0d\x0a\x87\x0a':
            return 'image/jxl', {}
        elif start[0:2] == b'\xff\x0a':
            return 'image/jxl', {}
        elif path.suffix.lower() == '.svg':
            return 'image/svg+xml', {}
    return None, None


def _sigint_handler(*_):
    sys.exit(130)


async def convert_to_jpeg(source, dest):
    args = [
        'cjpegli',
        '--', source, dest,
    ]
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def convert_to_ppm(source, dest):
    args = [
        'vips',
        'ppmsave',
        '--',
        source,
        dest,
    ]
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def convert_to_jxl(source, dest, fast=False):
    args = [
        'cjxl',
        '--quiet',
        '--distance=0.0',
        '--lossless_jpeg=1',
    ]
    if not fast:
        args.append('--effort=10')

    args.extend([
        '--', source, dest,
    ])
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode != 0:
        raise ProcessError(proc)


async def _process_optim(func, path, fast, strip, **options):
    before = path.stat().st_size

    with TempPath(dir=path.parent, prefix='.imgoptim_',
                  suffix=path.name + '.tmp') as temp_path:
        await func(path, temp_path, fast=fast, strip=strip, **options)

        after = temp_path.stat().st_size
        if after < before:
            temp_path.rename(path)
        else:
            after = before

    return path, before, after


_SUPPORTED_CONVERT_SUFFIXES = {
    'image/jpeg': [
        'image/png',
        'image/ppm',
    ],
    'image/jxl': [
        'image/jpeg',
        'image/png',
        'image/ppm',
    ],
    'image/jxl': [
        'image/jpeg',
        'image/png',
        'image/ppm',
    ],
}


async def _process_convert(path, source_mimetype, target_mimetype):
    dest = path.parent / (path.stem or path.name)
    suffixes = _MIME_SUFFIXES[target_mimetype]
    if dest.suffix.lower() not in suffixes:
        dest = dest.with_name(dest.stem + suffixes[0])

    with contextlib.ExitStack() as stack:
        temp_path = stack.enter_context(TempPath(
            dir=path.parent, prefix='.imgconvert_', suffix=path.name + '.tmp'))
        match target_mimetype:
            case 'image/x-portable-pixmap':
                await convert_to_ppm(path, temp_path)
                temp_path.rename(dest)
            case 'image/jxl':
                await convert_to_jxl(path, temp_path)
                temp_path.rename(dest)
            case 'image/jpeg':
                await convert_to_jpeg(path, temp_path)
                temp_path.rename(dest)
            case _:
                raise RuntimeError('invalid target_type')
    return path, dest


class SizeDiffPrinter:
    def __init__(self, num_items):
        self._before_total = 0
        self._after_total = 0
        self._num_items = num_items
        self._num_printed = 0
        self._printed = False

    @staticmethod
    def format_diff(before, after):
        diff = ((before - after) / before) * 100
        if diff:
            diff = '{:.2f}'.format(diff)
            if not float(diff):
                diff = f'<{diff}'
        return diff

    @staticmethod
    def sizeof_fmt(num):
        for unit in ['B', 'KB', 'MB', 'GB', 'TB', 'PB']:
            if abs(num) < 1024.0:
                break
            num /= 1024.0
        return f'{num:.1f}{unit}'

    def print(self, before, after, name):
        self._num_printed += 1
        self._before_total += before
        self._after_total += after
        diff = self.format_diff(before, after)

        s = f'{diff:>6}%' if diff else 7 * '-'
        num_printed = str(self._num_printed).rjust(len(str(self._num_items)))
        print(f'({num_printed}/{self._num_items})\t{s}\t{name}')

    def print_total(self):
        if self._num_printed:
            if diff := self.format_diff(self._before_total, self._after_total):
                fmt = self.sizeof_fmt(self._before_total - self._after_total)
                print(f'Total: {diff}% ({fmt})')
            else:
                print('Total: -')


def _num_procs(value):
    value = int(value)
    if value == 0:
        return os.cpu_count()
    elif value > 0:
        return value
    else:
        raise argparse.ArgumentError('invalid num_procs')


def _parser_path_file(value):
    path = pathlib.Path(value)
    if path.is_file():
        return path
    elif path.is_dir():
        raise argparse.ArgumentError('path must be file')
    else:
        raise argparse.ArgumentError('invalid path')


async def sha256sum(pipe):
    proc = await asyncio.create_subprocess_exec(
        'sha256sum',
        stdin=pipe,
        stdout=asyncio.subprocess.PIPE)
    os.close(pipe)
    stdout, _ = await proc.communicate()
    if proc.returncode:
        raise ProcessError(proc)
    return stdout.split()[0].decode()


async def sha256sum_djxl(source):
    read, write = os.pipe()
    proc = await asyncio.create_subprocess_exec(
        'djxl', '--quiet', '--output_format=ppm', '--', source, '-',
        stdout=write)
    os.close(write)
    sha256 = await sha256sum_vips_copy(read)
    await proc.wait()
    if proc.returncode:
        raise ProcessError(proc)
    return sha256


async def sha256sum_vips_copy(source):
    read1, write1 = os.pipe()
    if isinstance(source, int):
        proc1 = await asyncio.create_subprocess_exec(
            'vips', 'copy', 'stdin[]', '.ppm[]',
            stdin=source,
            stdout=write1)
        os.close(source)
    else:
        proc1 = await asyncio.create_subprocess_exec(
            'vips', 'copy', source, '.ppm[]',
            stdout=write1)
    os.close(write1)

    read2, write2 = os.pipe()
    proc2 = await asyncio.create_subprocess_exec(
        'magick', 'ppm:-', '-set', 'comment', '', 'ppm:-',
        stdin=read1,
        stdout=write2)
    os.close(write2)

    sha256 = await sha256sum(read2)
    for proc in (proc1, proc2):
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc)
    return sha256


async def main_compare():
    parser = argparse.ArgumentParser()
    parser.add_argument('paths', metavar='path', nargs=2)
    args = parser.parse_args()

    hashes = []
    for path in args.paths:
        mimetype, _ = determine_mime(path)
        match mimetype:
            case 'image/jxl':
                res = await sha256sum_djxl(path)
                print(res)
            case 'image/jpeg':
                res = await sha256sum_vips_copy(path)
                print(res)
            case _:
                raise NotImplementedError
    # vips copy 'stdin[]' '.ppm[]' < "$1" | tail -n+3 | sha256sum | awk '{print $1}'


async def main_convert():
    parser = argparse.ArgumentParser()
    parser.add_argument('-n', metavar='NUM', dest='num_procs',
                        type=_num_procs, default=None,
                        help='number of parallel jobs (default: %(default)s)')
    parser.add_argument('--rm', action='store_true')
    parser.add_argument(
        '-f', '--format', dest='format',
        choices=('jpeg', 'jxl', 'ppm'), required=True)
    parser.add_argument(
        'paths', metavar='path', nargs='+', type=_parser_path_file)
    args = parser.parse_args()

    executor = async_executor.AsyncExecutor(args.num_procs)
    for path in args.paths:
        try:
            mimetype, _ = determine_mime(path)
        except (FileNotFoundError, IsADirectoryError):
            # broken symlink can cause this
            continue

        executor.submit(_process_convert, path,
                        source_mimetype=mimetype,
                        target_mimetype=_TYPE_TO_MIME[args.format])

    async for result in executor:
        try:
            source, dest = result.result()
        except ProcessError as e:
            # TODO give this a competent error message
            print(f'error: {e}', file=sys.stderr)
            continue
        print(source, '->', dest)


async def main_optim():
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--strip', action='store_true')
    parser.add_argument(
        '-t', '--type', dest='types', action='append', default=[],
        choices=_TYPE_TO_MIME,
        help='filetypes to process. may be specified more than once.')
    parser.add_argument('--fast', action='store_true')
    parser.add_argument('-n', metavar='NUM', dest='num_procs',
                        type=_num_procs, default=None,
                        help='number of parallel jobs (default: %(default)s)')
    parser.add_argument('-q', '--quiet', action='store_true')
    parser.add_argument('paths', metavar='path', nargs='+', type=pathlib.Path)
    args = parser.parse_args()

    mimetypes = set(_TYPE_TO_MIME[t] for t in (args.types or _DEFAULT_TYPES))

    executor = async_executor.AsyncExecutor(args.num_procs)
    for f in all_files(*args.paths):
        try:
            mimetype, options = determine_mime(f)
        except (FileNotFoundError, IsADirectoryError):
            # broken symlink can cause this
            continue

        if mimetype not in mimetypes:
            continue

        if func := _MIME_OPTIM.get(mimetype):
            executor.submit(
                _process_optim, func, f, fast=args.fast, strip=args.strip,
                **options)

    size_diff_printer = SizeDiffPrinter(num_items=len(executor))
    async for result in executor:
        try:
            path, before, after = result.result()
        except ProcessError as e:
            # TODO give this a competent error message
            print(f'error: {e}', file=sys.stderr)
            continue

        if not args.quiet:
            size_diff_printer.print(before, after, path)

    if not args.quiet:
        size_diff_printer.print_total()


if __name__ == '__main__':
    signal.signal(signal.SIGINT, _sigint_handler)
    match pathlib.Path(sys.argv[0]).name:
        case 'imgcompare':
            asyncio.run(main_compare())
        case 'imgconvert':
            asyncio.run(main_convert())
        case 'imgoptim' | _:
            asyncio.run(main_optim())
