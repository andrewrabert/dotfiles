#!/usr/bin/env python3
import argparse
import asyncio
import contextlib
import functools
import getpass
import io
import logging
import os
import pathlib
import re
import shutil
import subprocess
import sys
import tempfile
import zipfile


LOGGER = logging.getLogger('archive-extract')


@contextlib.contextmanager
def TempPath(**kwargs):
    """Wrapper around tempfile.NamedTemporaryFile which returns a path object

    Unlike tempfile.NamedTemporaryFile, the FileNotFoundError exception is not
    raised if the file is deleted before the context closes.

    :rtype: pathlib.Path
    """
    with tempfile.NamedTemporaryFile(**kwargs, delete=False) as tmp:
        temp_path = pathlib.Path(tmp.name)
        try:
            yield temp_path
        finally:
            try:
                temp_path.unlink()
            except FileNotFoundError:
                pass


def _all_paths(root):
    stack = [root]
    paths = {root}

    if root.is_dir() and not root.is_symlink():
        while stack:
            for path in stack.pop().iterdir():
                paths.add(path)
                if path.is_dir() and not path.is_symlink():
                    stack.append(path)
    # sorted for deterministic archives ex. tar
    return sorted(paths)


async def create_zip(path, dest, fast=False):
    if path.is_dir():
        cwd = path
        paths = sorted(
            path.relative_to(cwd)
            for path in _all_paths(path)
            if path != cwd
        )
    else:
        cwd = path.parent
        paths = (path.relative_to(cwd),)

    level = '-0' if fast else '-9'

    # zip cli thinks existing file means
    dest.unlink()

    proc = await asyncio.create_subprocess_exec(
        'zip',
        level,
        '-nw',  # treat wildcards as regular characters
        '-X',  # exclude extra file attributes, prevents EpubCheck error
        '-@',  # read paths from stdin
        '-q',  # quiet
        dest,
        cwd=cwd,
        stdin=asyncio.subprocess.PIPE)
    proc.stdin.write(b'\n'.join(bytes(p) for p in paths))
    proc.stdin.close()
    await proc.wait()
    if proc.returncode != 0:
        raise RuntimeError('exit code {proc.returncode}')
    if not fast:
        await optimize_zip(dest)


async def create_7z(path, dest, fast=False):
    # 7z barfs on existing file
    dest.unlink()

    level = '-mx=0' if fast else '-mx=9'

    if path.is_dir():
        # avoid having all archive nested under a single folder
        cwd = path
        source = '.'
    else:
        cwd = path.parent
        source = path

    proc = await asyncio.create_subprocess_exec(
        '7zz',
        'a',  # create archive
        level,
        '--', dest, source,
        cwd=cwd,
        stdout=asyncio.subprocess.PIPE)
    await proc.wait()
    if proc.returncode != 0:
        raise RuntimeError('exit code {proc.returncode}')


async def create_epub(path, dest, fast=False):
    if path.is_dir():
        cwd = path
        paths = sorted(
            path.relative_to(cwd)
            for path in _all_paths(path)
            if path != cwd
        )
    else:
        raise RuntimeError('epub requires source directory')

    level = '-0' if fast else '-9'

    # zip cli thinks existing file means
    dest.unlink()

    def _path_rank(x):
        x = str(x)
        if x == 'mimetype':
            rank = 0
        elif x.startswith('META-INF/') or x == 'META-INF':
            rank = 1
        elif x.startswith('OEBPS/') or x == 'OEBPS':
            rank = 2
        else:
            rank = 3
        return rank, x

    paths = sorted(paths, key=_path_rank)

    proc = await asyncio.create_subprocess_exec(
        'zip',
        level,
        '-nw',  # treat wildcards as regular characters
        '-X',  # exclude extra file attributes, prevents EpubCheck error
        '-@',  # read paths from stdin
        '-q',  # quiet
        dest,
        cwd=cwd,
        stdin=asyncio.subprocess.PIPE)
    proc.stdin.write(b'\n'.join(bytes(p) for p in paths))
    proc.stdin.close()
    await proc.wait()
    if proc.returncode != 0:
        raise RuntimeError('exit code {proc.returncode}')
    if not fast:
        await optimize_zip(dest)


async def create_gzip(path, dest, fast=False):
    if path.is_dir():
        raise RuntimeError

    with open(dest, 'wb') as dest_handle:
        proc = await asyncio.create_subprocess_exec(
            'gzip',
            '-c',  # stdout
            '-1' if fast else '-9',
            path,
            stdout=dest_handle)
        await proc.wait()
    assert proc.returncode == 0


async def create_xz(path, dest, fast=False):
    if path.is_dir():
        raise RuntimeError

    args = []
    if fast:
        args.append('-0')
    else:
        args.extend(['-9', '--extreme'])

    with open(dest, 'wb') as dest_handle:
        proc = await asyncio.create_subprocess_exec(
            'xz',
            '-c',  # stdout
            '--threads=0',  # as many as processor cores
            *args,
            path,
            stdout=dest_handle)
        await proc.wait()
    assert proc.returncode == 0


async def create_zstd(path, dest, fast=False):
    if path.is_dir():
        raise RuntimeError

    level = '-1' if fast else '-22'

    zstd_proc = await asyncio.create_subprocess_exec(
        'zstd', '--quiet', '-f', '-T0', '--ultra', level, '-o', dest,
        '--', path)
    await zstd_proc.wait()
    assert zstd_proc.returncode == 0


async def create_rvz(path, dest, fast=False):
    if path.is_dir():
        raise RuntimeError

    level = '1' if fast else '22'

    # need tempdir to allow for concurrent processes
    with tempfile.TemporaryDirectory(
            dir=dest.parent, prefix='.archive_',
            suffix=dest.name + '.tmp') as tmp:
        proc = await asyncio.create_subprocess_exec(
            'dolphin-tool', 'convert',
            f'--user={tmp}',
            f'--compression_level={level}',
            '--format=rvz',
            '--block_size=131072',
            '--compression=zstd',
            f'--input={path}',
            f'--output={dest}')
        await proc.wait()
        assert proc.returncode == 0
        raise NotImplementedError


async def create_nsz(path, dest, fast=False):
    if path.is_dir():
        raise RuntimeError

    level = '1' if fast else '22'

    # need tempdir to allow for concurrent processes
    with tempfile.TemporaryDirectory(
            dir=dest.parent, prefix='.archive_',
            suffix=dest.name + '.tmp') as tmp:
        proc = await asyncio.create_subprocess_exec(
            'nsz',
            '-C',  # compress
            '--long',
            f'--level={level}',
            f'--output={tmp}',
            path,
            # DEVNULL causes issues, idk why
            stdout=asyncio.subprocess.PIPE)
        await proc.communicate()
        assert proc.returncode == 0
        tmp_files = list(pathlib.Path(tmp).iterdir())
        assert len(tmp_files) == 1
        tmp_file = tmp_files[0]
        assert tmp_file.is_file()
        tmp_file.rename(dest)


async def create_tar(path, dest, fast=False):
    if path.is_dir():
        cwd = path
        paths = _all_paths(path)
    else:
        cwd = path.parent
        paths = (path,)

    tar_proc = await asyncio.create_subprocess_exec(
        'tar', 'cf', dest, '-C', cwd, '--no-recursion',
        '--verbatim-files-from', '--null', '-T', '-',
        stdin=asyncio.subprocess.PIPE)

    tar_proc.stdin.write(b'\0'.join(
        bytes(p.relative_to(cwd))
        for p in paths
        if p != cwd
    ))
    tar_proc.stdin.close()

    await asyncio.gather(tar_proc.wait())
    assert tar_proc.returncode == 0


async def create_tar_gz(path, dest, fast=False):
    if path.is_dir():
        cwd = path
        paths = _all_paths(path)
    else:
        cwd = path.parent
        paths = (path,)

    if fast:
        gzip_arg = 'gzip --fast'
    else:
        gzip_arg = 'gzip --best'

    # TODO specify gzip compression level
    tar_proc = await asyncio.create_subprocess_exec(
        'tar', 'cf', dest, '-C', cwd, '--no-recursion',
        '-I', gzip_arg,
        '--verbatim-files-from', '--null', '-T', '-',
        stdin=asyncio.subprocess.PIPE)

    tar_proc.stdin.write(b'\0'.join(
        bytes(p.relative_to(cwd))
        for p in paths
        if p != cwd
    ))
    tar_proc.stdin.close()

    await tar_proc.wait()
    assert tar_proc.returncode == 0


async def create_tar_xz(path, dest, fast=False):
    if path.is_dir():
        cwd = path
        paths = _all_paths(path)
    else:
        cwd = path.parent
        paths = (path,)

    args = []
    if fast:
        args.append('-0')
    else:
        args.extend(['-9', '--extreme'])

    # TODO specify xz compression level
    tar_proc = await asyncio.create_subprocess_exec(
        'tar', 'czf', dest, '-C', cwd, '--no-recursion',
        '--verbatim-files-from', '--null', '--threads=0', *args, '-',
        stdin=asyncio.subprocess.PIPE)

    tar_proc.stdin.write(b'\0'.join(
        bytes(p.relative_to(cwd))
        for p in paths
        if p != cwd
    ))
    tar_proc.stdin.close()

    await tar_proc.wait()
    assert tar_proc.returncode == 0


async def create_tar_zstd(path, dest, fast=False):
    if path.is_dir():
        cwd = path
        paths = _all_paths(path)
    else:
        cwd = path.parent
        paths = (path,)

    level = '-1' if fast else '-22'

    read, write = os.pipe()

    tar_proc = await asyncio.create_subprocess_exec(
        'tar', 'cf', '-', '-C', cwd, '--no-recursion',
        '--verbatim-files-from', '--null', '-T', '-',
        stdin=asyncio.subprocess.PIPE,
        stdout=write)
    os.close(write)

    zstd_proc = await asyncio.create_subprocess_exec(
        'zstd', '--quiet', '-f', '-T0', '--ultra', level, '-o', dest,
        stdin=read)
    os.close(read)

    tar_proc.stdin.write(b'\0'.join(
        bytes(p.relative_to(cwd))
        for p in paths
        if p != cwd
    ))
    tar_proc.stdin.close()

    await asyncio.gather(tar_proc.wait(), zstd_proc.wait())
    assert tar_proc.returncode == zstd_proc.returncode == 0


async def optimize_zip(path):
    proc = await asyncio.create_subprocess_exec(
        'advzip', '--recompress', '--shrink-insane', '--quiet', path)
    await proc.wait()
    assert proc.returncode == 0


def _build_archive_dest(source, suffix, parent=None):
    parent = parent if parent is not None else source.parent
    increment = 0
    while True:
        dest = parent / pathlib.Path(
            ''.join([
                source.name,
                f'_{increment}' if increment else '',
                suffix]))

        if not dest.exists():
            dest.parent.mkdir(exist_ok=True, parents=True)
            return dest.absolute()

        increment += 1


def _build_archive_dest_nsz(source, suffix, parent=None):
    if source.suffix.lower() == '.nsp':
        source = source.with_suffix('')
    return _build_archive_dest(source, suffix, parent)


_FORMATS = {
    '7z': {
        'func': create_7z,
        'suffix': '.7z',
    },
    'cbz': {
        'func': create_zip,
        'suffix': '.cbz',
    },
    'epub': {
        'func': create_epub,
        'suffix': '.epub',
    },
    'gz': {
        'func': create_gzip,
        'suffix': '.gz',
    },
    'nsz': {
        'func': create_nsz,
        'suffix': '.nsz',
        'build_dest': _build_archive_dest_nsz,
    },
    'rvz': {
        'func': create_rvz,
        'suffix': '.rvz'
    },
    'tar': {
        'func': create_tar,
        'suffix': '.tar'
    },
    'tar.gz': {
        'func': create_tar_gz,
        'suffix': '.tar.gz'
    },
    'tar.xz': {
        'func': create_tar_xz,
        'suffix': '.tar.xz'
    },
    'tar.zst': {
        'func': create_tar_zstd,
        'suffix': '.tar.zst'
    },
    'xz': {
        'func': create_xz,
        'suffix': '.xz',
    },
    'zip': {
        'func': create_zip,
        'suffix': '.zip',
    },
    'zst': {
        'func': create_zstd,
        'suffix': '.zst'
    },
}


async def process(source, archive_format, remove, fast=False, parent=None):
    formats = _FORMATS[archive_format]

    source = source.absolute()
    suffix = formats['suffix']
    build_dest = formats.get('build_dest', _build_archive_dest)

    dest = build_dest(source, suffix, parent=parent)

    before = sum(path.lstat().st_size for path in _all_paths(source))
    with TempPath(dir=dest.parent, prefix='.archive_',
                  suffix=source.name + '.tmp') as tmp:
        await formats['func'](source, tmp, fast)
        tmp.rename(dest)
    after = dest.lstat().st_size

    if remove:
        if source.is_dir():
            shutil.rmtree(source)
        else:
            source.unlink()

    return dest, before, after


def _num_procs(value):
    value = int(value)
    if value == 0:
        return os.cpu_count()
    elif value > 0:
        return value
    else:
        raise argparse.ArgumentError('invalid num_procs')


class SizeDiffPrinter:
    def __init__(self, num_items):
        self._before_total = 0
        self._after_total = 0
        self._num_items = num_items
        self._num_printed = 0
        self._printed = False

    @staticmethod
    def format_diff(before, after):
        diff = ((before - after) / before) * 100
        if diff:
            diff = '{:.2f}'.format(diff)
            if not float(diff):
                diff = f'<{diff}'
        return diff

    @staticmethod
    def sizeof_fmt(num):
        for unit in ['B', 'KB', 'MB', 'GB', 'TB', 'PB']:
            if abs(num) < 1024.0:
                break
            num /= 1024.0
        return f'{num:.1f}{unit}'

    def print(self, before, after, name):
        self._num_printed += 1
        self._before_total += before
        self._after_total += after
        diff = self.format_diff(before, after)

        s = f'{diff:>6}%' if diff else 7 * '-'
        num_printed = str(self._num_printed).rjust(len(str(self._num_items)))
        print(f'({num_printed}/{self._num_items})\t{s}\t{name}')

    def print_total(self):
        if self._num_printed:
            if diff := self.format_diff(self._before_total, self._after_total):
                fmt = self.sizeof_fmt(self._before_total - self._after_total)
                print(f'Total: {diff}% ({fmt})')
            else:
                print('Total: -')


def archive_main():
    parser = argparse.ArgumentParser(
        usage='%(prog)s [OPTIONS] source [source ...]')

    group_format = parser.add_argument_group('format')
    group_format.add_argument(
        '-f', metavar='FORMAT', choices=_FORMATS,
        dest='format', default='tar.zst',
        help='archive format: %(choices)s (default: %(default)s)')
    group_format.add_argument(
        '--fast', default=False, action='store_true',
        help='increase archiving speed at the expense of compression')

    parser.add_argument(
        '--rm', default=False, action='store_true',
        help='remove source after success')
    parser.add_argument(
        '-n', metavar='NUM', dest='num_procs',
        type=_num_procs, default=1,
        help='number of parallel jobs (default: %(default)s)')
    parser.add_argument(
        '-p', dest='parent', metavar='DIR', type=pathlib.Path,
        help='parent directory to save the archive in')
    parser.add_argument(
        'source', type=lambda p: pathlib.Path(p).absolute(), nargs='+')

    args = parser.parse_args()

    async def run(args):
        has_error = False

        executor = AsyncExecutor(args.num_procs)

        sources = []
        for source in args.source:
            if source in sources:
                continue
            else:
                sources.append(source)

            executor.submit(process, source, args.format, args.rm, args.fast,
                            parent=args.parent)

        size_diff_printer = SizeDiffPrinter(num_items=len(executor))
        async for future in executor:
            try:
                dest, before, after = future.result()
            except FileExistsError as e:
                print(f'error: file exists {e}', file=sys.stderr)
                has_error = True
            except Exception as e:
                print(e, file=sys.stderr)
            else:
                size_diff_printer.print(before, after, dest)
        size_diff_printer.print_total()
        return has_error

    sys.exit(1 if asyncio.run(run(args)) else 0)


class nsz:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('nsz'):
            raise KeyError

    @classmethod
    async def contents(cls, path):
        cls._check_is_nsz(path)
        return [path.with_suffix('.nsp').name.encode()]

    @classmethod
    async def extract(cls, path, dest, paths=None, password=None, overwrite=False):
        cls._check_is_nsz(path)
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('.nsp')
        if target.exists():
            raise RuntimeError
        with tempfile.TemporaryDirectory(
                dir=dest, prefix='.extract_',
                suffix=dest.name + '.tmp') as tmp:
            proc = await asyncio.create_subprocess_exec(
                'nsz',
                '-D',  # decompress
                f'--output={tmp}',
                path,
                # DEVNULL causes issues, idk why
                stdout=asyncio.subprocess.PIPE)
            await proc.communicate()
            assert proc.returncode == 0
            tmp_files = list(pathlib.Path(tmp).iterdir())
            assert len(tmp_files) == 1
            tmp_file = tmp_files[0]
            assert tmp_file.is_file()
            if target.exists():
                raise RuntimeError
            tmp_file.rename(target)

    @classmethod
    async def volumes(cls, path, password=''):
        cls._check_is_nsz(path)
        return [path]

    @staticmethod
    def _check_is_nsz(path):
        if path.suffix.lower() != '.nsz':
            raise ValueError('does not end with .nsz')


class cli_7zip:
    _PART_RE = re.compile(r'(.*\.part)(\d+)(\.rar)$')
    _ALT_PART_RE = re.compile(r'(.*\.)(\d+)$')

    @classmethod
    def check(cls):
        return cls._path()

    @staticmethod
    @functools.cache
    def _path():
        for name in ('7zz', '7z'):
            if shutil.which(name):
                return name
        raise KeyError

    @classmethod
    async def extract(cls, path, dest, paths=None, password='',
                      overwrite=False):
        args = [
            cls._path(),
            '-bd',  # disable progress indicator
            '-bb0',  # quietest log level
        ]

        kwargs = {
            # prevent prompt when files already exist
            'stdin': asyncio.subprocess.DEVNULL,
        }

        if overwrite:
            args.append('-aoa')  # overwrite all without prompting

        if dest == sys.stdout.buffer:
            args.extend(['e', f'-p{password}', '-so', '--', str(path)])
        else:
            args.extend([
                'x', f'-p{password}', '-spe', f'-o{dest}', '--', str(path)
            ])
            # supress output that shows even at the quiest log level
            kwargs['stdout'] = asyncio.subprocess.DEVNULL

        if paths:
            args.extend(paths)

        proc = await asyncio.create_subprocess_exec(*args, **kwargs)
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @classmethod
    async def contents(cls, path):
        args = [cls._path(), '-ba', 'l', '--', str(path)]
        proc = await asyncio.create_subprocess_exec(
            *args, stdout=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)

        contents = []
        for line in stdout.splitlines():
            # - date+time may be blank
            # - size may be blank
            attrs = line[20:25]
            name = line[53:]
            if attrs == b'D....':
                name += b'/'
            contents.append(name)
        return contents

    @classmethod
    async def volumes(cls, path, password=''):
        args = [cls._path(), 'l', f'-p{password}', '--', str(path)]
        proc = await asyncio.create_subprocess_exec(
            *args, stdout=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)

        num_volumes = 1
        for line in reversed(stdout.splitlines()):
            if line.startswith(b'Volumes = '):
                num_volumes = int(line.split(b' = ')[1])
                break

        if num_volumes > 1:
            if found := cls._PART_RE.search(str(path)):
                prefix, vol_num, suffix = found.groups()
            elif found := cls._ALT_PART_RE.search(str(path)):
                prefix, vol_num = found.groups()
                suffix = ''
            else:
                raise NotImplementedError

            volumes = [
                pathlib.Path('{}{}{}'.format(
                    prefix, str(i).rjust(len(vol_num), '0'), suffix))
                for i in range(1, num_volumes + 1)
            ]
            for v in volumes:
                if not v.is_file():
                    raise RuntimeError(f'missing volume {v}')
        else:
            volumes = [path]
        return volumes


class dolphin_tool:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('dolphin-tool'):
            raise KeyError

    @classmethod
    async def contents(cls, path):
        cls._check_is_rvz(path)
        return [path.with_suffix('.iso').name.encode()]

    @classmethod
    async def extract(cls, path, dest, paths=None, password=None, overwrite=False):
        cls._check_is_rvz(path)
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        proc = await asyncio.create_subprocess_exec(
            'dolphin-tool', 'convert',
            '--format=iso',
            f'--input={path}',
            f'--output={target}',
            stdout=asyncio.subprocess.DEVNULL)
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @classmethod
    async def volumes(cls, path, password=''):
        cls._check_is_rvz(path)
        return [path]

    @staticmethod
    def _check_is_rvz(path):
        if path.suffix.lower() != '.rvz':
            raise ValueError('does not end with .rvz')


class udisksctl:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('udisksctl'):
            raise KeyError

    @classmethod
    async def contents(cls, path):
        with cls._loop_context(path) as device:
            with cls._udisksctl_mount_context(device) as mount_path:
                return sorted(
                    bytes(path.relative_to(mount_path))
                    for path in cls._child_paths(mount_path)
                )

    @classmethod
    async def extract(cls, path, dest, paths=None, password=None,
                      overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError

        with cls._loop_context(path) as device:
            with cls._udisksctl_mount_context(device) as mount_path:
                mount_path = pathlib.Path(mount_path)
                shutil.copytree(mount_path, dest, dirs_exist_ok=True)

        dest.chmod(0o755)
        for path in cls._child_paths(dest):
            if path.is_dir():
                path.chmod(0o755)
            else:
                path.chmod(0o644)

    @staticmethod
    async def volumes(path, password=''):
        return [path]

    @staticmethod
    def _loop_info(device):
        proc = subprocess.run(
            ['udisksctl', 'info', '--block-device', device],
            stdout=subprocess.PIPE,
            check=True)
        output = proc.stdout.decode().strip()

        backing_file = None
        mount_point = None
        for line in output.splitlines():
            if line.startswith('    MountPoints:'):
                mount_point = line.split(maxsplit=1)[1]
            elif line.startswith('    BackingFile:'):
                backing_file = line.split(maxsplit=1)[1]

        return {
            'backing_file': backing_file,
            'mount_point': mount_point,
        }

    @staticmethod
    @contextlib.contextmanager
    def _loop_context(path):
        proc = subprocess.run(
            ['udisksctl', 'loop-setup', '--no-user-interaction',
             '--read-only', '--file', path],
            stdout=subprocess.PIPE,
            check=True)
        # strip trailing period
        output = proc.stdout.decode().strip()
        start = f'Mapped file {path} as '
        if output.startswith(start) and output.endswith('.'):
            device = output.replace(start, '', 1)[:-1]
        else:
            raise RuntimeError(f'udisksctl error: {output}')

        try:
            yield device
        finally:
            subprocess.run(
                ['udisksctl', 'loop-delete', '--no-user-interaction',
                 '--block-device', device],
                stdout=subprocess.DEVNULL,
                check=True)

    @staticmethod
    @contextlib.contextmanager
    def _udisksctl_mount_context(device):
        proc = subprocess.run(
            ['udisksctl', 'mount', '--no-user-interaction',
             '--options', 'ro',
             '--block-device', device],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.PIPE)

        if proc.returncode:
            mount_info = udisksctl._loop_info(device)
            path = mount_info['mount_point']

            if path is None:
                # udisksctl doesn't recognize some floppy images as mountable
                # ex. goodolddays_000846_commander_keen_goodbye_galaxy
                with udisksctl._mount_context(device) as path:
                    yield path
                return
        else:
            output = proc.stdout.decode().strip()
            start = f'Mounted {device} at '
            if output.startswith(start):
                path = output.replace(start, '', 1)
            else:
                raise RuntimeError(f'udisksctl error: {output}')

        try:
            yield path
        finally:
            subprocess.run(
                ['udisksctl', 'unmount', '--no-user-interaction',
                 '--block-device', device],
                stdout=subprocess.DEVNULL,
                check=True)

    @staticmethod
    @contextlib.contextmanager
    def _mount_context(device):
        if os.getuid() != 0:
            raise RuntimeError('must extracted as root')
        with tempfile.TemporaryDirectory() as tmp:
            try:
                subprocess.run(
                    ['mount', '-o', 'loop,ro', device, tmp],
                    check=True)
                yield tmp
            finally:
                subprocess.run(
                    ['umount', tmp],
                    check=True)

    @staticmethod
    def _child_paths(root):
        stack = [pathlib.Path(root)]
        paths = []
        while stack:
            for path in stack.pop().iterdir():
                paths.append(path)
                if path.is_dir():
                    stack.append(path)
        return paths


class unzip:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('unzip'):
            raise KeyError

    @staticmethod
    async def contents(path):
        proc = await asyncio.create_subprocess_exec(
            'unzip',
            '-O', 'UTF-8',  # encoding for DOS, Windows, OS/2
            '-I', 'UTF-8',  # encoding for UNIX, other
            '-qq', '-l', path,
            stdout=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)
        return [
            line.split(maxsplit=3)[-1]
            for line in stdout.splitlines()
        ]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        args = [
            'unzip',
            '-O', 'UTF-8',  # encoding for DOS, Windows, OS/2
            '-I', 'UTF-8',  # encoding for UNIX, other
            '-qq',
            '-d', dest,
        ]
        if overwrite:
            args.append('-o')  # overwrite without prompting
        args.append(path)
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdin=asyncio.subprocess.DEVNULL,
            stdout=asyncio.subprocess.PIPE)
        await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class cabextract:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('cabextract'):
            raise KeyError

    @staticmethod
    async def contents(path):
        proc = subprocess.run(
            ['cabextract', '--list', '--quiet', '--', path],
            stdout=subprocess.PIPE,
            check=True)
        return [
            line.split(maxsplit=6)[-1]
            for line in proc.stdout.splitlines()[2:]
        ]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['cabextract', '--quiet', '--directory', dest, '--', path],
            check=True)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class unshield:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('unshield'):
            raise KeyError

    @staticmethod
    async def contents(path):
        proc = await asyncio.create_subprocess_exec(
            'unshield', 'l', '--', path,
            stdout=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)
        contents = []
        for line in stdout.splitlines()[1:-2]:
            # convert windows-separated (\) path to local
            p = pathlib.Path(
                pathlib.PureWindowsPath(
                    line.strip().split(maxsplit=1)[-1].decode()
                )
            )
            contents.append(bytes(p))
        return contents

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        proc = await asyncio.create_subprocess_exec(
            'unshield', 'x', '-d', dest, '--', path,
            stdout=asyncio.subprocess.DEVNULL)
        await proc.wait()
        if proc.returncode != 0:
            raise RuntimeError('exit code {proc.returncode}')

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class xorriso:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('xorriso'):
            raise KeyError

    @staticmethod
    async def contents(path):
        proc = subprocess.run(
            ['xorriso', '-osirrox', 'on', '-indev', path,
             '-find', '/', '-exec', 'lsdl'],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            check=True)

        parents = {}
        for line in proc.stdout.splitlines():
            name = line.split(b"'", maxsplit=1)[-1][:-1]\
                .decode()\
                .strip()\
                .lstrip('/')
            if not name:
                continue
            if line.startswith(b'd'):
                parents.setdefault(name, set())
            else:
                parent = pathlib.Path(name).parent.name
                parents.setdefault(parent, set())
                parents[parent].add(name)

        paths = set()
        for parent, children in parents.items():
            if children:
                paths.update(child.encode() for child in children)
            else:
                paths.add(parent.encode() + b'/')
        return paths

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['xorriso', '-osirrox', 'on', '-indev', path,
             '-chmod_r', 'u+rw', '/', '--', '-extract', '/', dest,
             '-rollback_end'],
            stderr=subprocess.DEVNULL,
            check=True)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class unrar:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('unrar'):
            raise KeyError

    @staticmethod
    async def contents(path):
        proc = await asyncio.create_subprocess_exec(
            'unrar', 'vb', '-v', '--', path,
            stdout=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)
        return set(stdout.splitlines())

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        args = []
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError

        if password is not None:
            args.append(f'-p{password}')

        proc = await asyncio.create_subprocess_exec(
            'unrar', 'x', '-idc', '-idd', '-idn', '-idp', '-idq', *args,
            '--', path, dest,
            stdin=asyncio.subprocess.DEVNULL)
        await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        proc = await asyncio.create_subprocess_exec(
            'unrar', 'vt', '-v', '--', path,
            stdout=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)
        return [
            path.parent / line.split(maxsplit=1)[-1]
            for line in stdout.decode().splitlines()
            if line.startswith('Archive: ')
        ]


class bchunk:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('bchunk'):
            raise KeyError

    @classmethod
    async def contents(cls, path):
        if path.suffix != '.cue':
            raise NotImplementedError('must end with .cue')
        volumes = await cls.volumes(path)
        if len(volumes) != 2:
            raise NotImplementedError('too many files')
        # 01 is the track number
        name = cls._content_name(path) + '01'
        return [f'{name}.iso'.encode()]

    @staticmethod
    def _content_name(cue_path):
        name = pathlib.Path(cue_path).name.removesuffix('.cue')
        if not name:
            raise RuntimeError
        return name

    @classmethod
    async def extract(cls, path, dest, paths=None, password=None,
                      overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        if password is not None:
            raise NotImplementedError

        if isinstance(path, bytes):
            path = path.decode()
        path = pathlib.Path(path)

        volumes = await cls.volumes(path)
        name = cls._content_name(path)
        proc = await asyncio.create_subprocess_exec(
            'bchunk', '-w', volumes[1], volumes[0], dest / name,
            stdout=asyncio.subprocess.DEVNULL)
        await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=None):
        if password is not None:
            raise NotImplementedError
        files = []
        for line in path.read_text().splitlines():
            line = line.strip()
            if line.startswith('FILE '):
                file_path = line\
                    .split(maxsplit=1)[1]\
                    .rsplit(maxsplit=1)[0]\
                    .removeprefix('"')\
                    .removesuffix('"')
                file_path = path.parent / pathlib.Path(file_path)
                if not file_path.is_file():
                    raise ValueError('file(s) specified in cue does not exist')
                files.append(file_path)
        if len(files) == 0:
            raise NotImplementedError
        return [path, *files]


class unace:
    # note: unace command seems to expect file to end with `.ace`

    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('unace'):
            raise KeyError

    @staticmethod
    async def contents(path):
        proc = subprocess.run(
            ['unace', 'l', path],
            stdout=subprocess.PIPE,
            check=True)

        magic_string = b'Date    Time     Packed      Size  Ratio  File'
        lines = None
        for line in proc.stdout.splitlines():
            line = line.strip()
            if lines is not None:
                lines.append(line)
            elif line.startswith(magic_string):
                lines = []

        if lines[-1].startswith(b'listed:'):
            lines = lines[:-1]
        else:
            raise RuntimeError('unable to parse unace output')

        return sorted(set(
            line.split(maxsplit=5)[-1]
            for line in lines
            if line
        ))

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        args = ['unace', 'e']
        if overwrite:
            args.append('-o')
        if password:
            raise NotImplementedError
        dest = str(dest)
        if not dest.endswith('/'):
            dest += '/'
        args.extend([path, dest])
        subprocess.run(args, check=True)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class innoextract:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('innoextract'):
            raise KeyError

        # needed for GOG only ? (*.bin files)
        if not shutil.which('unrar'):
            raise KeyError

    @staticmethod
    async def contents(path):
        # safe to pass --gog flag to non-gog installers
        proc = subprocess.run(
            ['innoextract', '--gog', '--exclude-temp', '--quiet', '--list',
             str(path)],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=True)

        contents = set()
        listing_files = False
        for line in proc.stdout.splitlines():
            if line == b'----------- ---------  ---------- -----  ----':
                listing_files = not listing_files
            elif listing_files:
                name = line.split(maxsplit=4)[-1]
                contents.add(name)
            elif line.startswith(b' - '):
                _, name, _ = line.split(b'"', 2)
                contents.add(name)

        return contents

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        # safe to pass --gog flag to non-gog installers
        subprocess.run(
            ['innoextract', '--gog', '--exclude-temp', '--extract',
             '--output-dir', dest, path],
            check=True)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class gog_linux:
    @staticmethod
    def check():
        pass

    @classmethod
    async def contents(cls, path):
        with cls._zipfile(path) as zf:
            contents = set()
            for zi in zf.infolist():
                if target := cls._local_target(zi):
                    contents.add(target)
            return sorted(c.encode() for c in contents)

    @classmethod
    async def extract(cls, path, dest, paths=None, password=None,
                      overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        with cls._zipfile(path) as zf:
            for zi in zf.infolist():
                if local_name := cls._local_target(zi):
                    zi.filename = local_name
                    target = dest.joinpath(local_name)
                    zf.extract(zi, dest)

                    # extract doesn't set attrs
                    if attr := zi.external_attr >> 16:
                        os.chmod(target, attr)

    @staticmethod
    def _local_target(zi):
        if zi.filename.startswith('data/noarch/'):
            if target := zi.filename[12:]:
                return target

    @staticmethod
    async def volumes(path, password=''):
        return [path]

    @staticmethod
    @contextlib.contextmanager
    def _zipfile(path):
        with open(path, 'rb') as f:
            FILESIZE_RE = re.compile(r'filesizes="(\d+?)"')
            OFFSET_RE = re.compile(r'offset=`head -n (\d+?) "\$0"')

            beginning = f.read(10240).decode(errors='ignore')
            offset_match = OFFSET_RE.search(beginning)
            script_lines = int(offset_match.group(1))

            # Read the number of lines to determine the script size
            f.seek(0, io.SEEK_SET)
            for line in range(0, script_lines):
                f.readline()
            script_size = f.tell()

            # Read the script
            f.seek(0, io.SEEK_SET)
            script_bin = f.read(script_size)
            script = script_bin.decode()

            # Filesize is for the MojoSetup archive, not the actual game data
            filesize_match = FILESIZE_RE.search(script)
            filesize = int(filesize_match.group(1))

            # Extract the game data archive
            dataoffset = script_size + filesize
            f.seek(dataoffset, io.SEEK_SET)
            with zipfile.ZipFile(f) as zf:
                yield zf


class gnu_tar:
    @staticmethod
    @functools.cache
    def check():
        try:
            proc = subprocess.run(
                ['tar', '--version'],
                stdout=subprocess.PIPE,
                check=True)
        except FileNotFoundError:
            raise KeyError

        if 'GNU tar' not in proc.stdout.decode().splitlines()[0]:
            raise KeyError

    @staticmethod
    async def contents(path):
        proc = await asyncio.create_subprocess_exec(
            'tar', 'tf', str(path), '--force-local',
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL)
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)
        return stdout.splitlines()

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        args = ['tar', 'xf', path, '--force-local']
        if dest == sys.stdout.buffer:
            args.append('--to-stdout')
        else:
            args.append(f'--one-top-level={dest}')

        if overwrite:
            args.append('--overwrite')
        else:
            args.append('--keep-old-files')

        if paths:
            args.extend(paths)

        proc = await asyncio.create_subprocess_exec(*args)
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class gzip:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('gzip'):
            raise KeyError

    @staticmethod
    async def contents(path):
        return [path.with_suffix('').name.encode()]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        with open(target, 'w') as handle:
            proc = await asyncio.create_subprocess_exec(
                'gzip', '-d', '-c', '--', path,
                stdout=handle)
            await proc.wait()
            if proc.returncode:
                raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class cpio:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('cpio'):
            raise KeyError

    @staticmethod
    async def contents(path):
        proc = await asyncio.create_subprocess_exec(
            'cpio',
            '--list',
            '--no-absolute-filenames',
            '--quiet',  # suppress last line containing block count
            '--file', path,
            stdout=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)
        return stdout.splitlines()

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        if path == dest:
            raise RuntimeError
        proc = await asyncio.create_subprocess_exec(
            'cpio',
            '--extract',
            '--directory', dest,
            '--make-directories',
            '--no-absolute-filenames',
            '--file', path)
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class pbzip2:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('pbzip2'):
            raise KeyError

    @staticmethod
    async def contents(path):
        return [path.with_suffix('').name.encode()]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        with open(target, 'w') as handle:
            proc = await asyncio.create_subprocess_exec(
                'pbzip2', '-d', '-c', '--', path,
                stdout=handle)
            await proc.wait()
            if proc.returncode:
                raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class pigz:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('pigz'):
            raise KeyError

    @staticmethod
    async def contents(path):
        return [path.with_suffix('').name.encode()]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        with open(target, 'w') as handle:
            proc = await asyncio.create_subprocess_exec(
                'pigz',
                '-d',  # decompress
                '-k',  # keep original file
                '-c',  # write to stdout
                '--', path,
                stdout=handle)
            await proc.wait()
            if proc.returncode:
                raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class pixz:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('pixz'):
            raise KeyError

    @staticmethod
    async def contents(path):
        return [path.with_suffix('').name.encode()]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        proc = await asyncio.create_subprocess_exec(
            'pixz',
            '-d',  # decompress
            '-k',  # keep original input
            '--', path,
            target)
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class bzip2:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('bzip2'):
            raise KeyError

    @staticmethod
    async def contents(path):
        return [path.with_suffix('').name.encode()]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        with open(target, 'w') as handle:
            proc = await asyncio.create_subprocess_exec(
                'bzip2', '-d', '-c', '--', path,
                stdout=handle)
            await proc.wait()
            if proc.returncode:
                raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class xz:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('xz'):
            raise KeyError

    @staticmethod
    async def contents(path):
        return [path.with_suffix('').name.encode()]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        with open(target, 'w') as handle:
            proc = await asyncio.create_subprocess_exec(
                'xz', '-d', '-c', '--', path,
                stdout=handle)
            await proc.wait()
            if proc.returncode:
                raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class lz4:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('lz4'):
            raise KeyError

    @staticmethod
    async def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        args = ['lz4', '-d']
        if overwrite:
            args.append('-f')
        target = dest / path.with_suffix('').name
        args.extend(['--', path, target])
        subprocess.run(args, stdin=subprocess.PIPE, check=True)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class zstd:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('zstd'):
            raise KeyError

    @staticmethod
    async def contents(path):
        return [path.with_suffix('').name.encode()]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        args = ['zstd', '-d', '--quiet', '--output-dir-flat', dest]
        if overwrite:
            args.append('-f')

        args.extend(['--', path])

        proc = await asyncio.create_subprocess_exec(*args)
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class brotli:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('brotli'):
            raise KeyError

    @staticmethod
    async def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths:
            raise NotImplementedError
        args = ['brotli', '--decompress', '--stdout']
        if overwrite:
            args.append('--force')
        args.extend(['--', path])

        proc = await asyncio.create_subprocess_exec(*args)
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


class unsquashfs:
    @staticmethod
    @functools.cache
    def check():
        if not shutil.which('unsquashfs'):
            raise KeyError

    @staticmethod
    async def contents(path):
        proc = await asyncio.create_subprocess_exec(
            'unsquashfs', '-lc', str(path),
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL)
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise ProcessError(proc.returncode)
        return stdout.splitlines()

    @staticmethod
    async def extract(path, dest, paths=None, password=None, overwrite=False):
        if paths or password:
            raise NotImplementedError

        args = [
            'unsquashfs',
            '-quiet',
            '-force',  # fails to extract even when extracting to empty dir
            '-dest', str(dest),
            str(path),
        ]

        proc = await asyncio.create_subprocess_exec(*args)
        await proc.wait()
        if proc.returncode:
            raise ProcessError(proc.returncode)

    @staticmethod
    async def volumes(path, password=''):
        return [path]


def _build_extract_dest(path, parent, child):
    if parent is None:
        parent = path.parent
    parent = parent.absolute()

    if child:
        if len(path.suffixes) > 1 and path.suffixes[-2].lower() == '.tar':
            dest = parent / pathlib.Path(path.stem).stem
        else:
            dest = parent / pathlib.Path(path.stem)

        while dest.exists():
            dest = dest.with_name(f'{dest.name}_')
    else:
        dest = parent
    dest.mkdir(parents=True, exist_ok=True)
    return dest


async def _get_class(path):
    suffixes = [suffix.lower() for suffix in path.suffixes]

    with open(path, 'rb') as f:
        start = f.read(10)

        # tar
        if start.startswith(b'ustar\x0000'):
            return gnu_tar
        # tar
        elif start.startswith(b'ustar  \x00'):
            return gnu_tar
        # rar < 5.0
        elif start.startswith(b'Rar!\x1a\x07\x00'):
            return unrar
        # rar >= 5.0
        elif start.startswith(b'Rar!\x1a\x07\x01\x00'):
            return unrar
        # 7-zip
        elif start.startswith(b"7z\xbc\xaf'\x1c"):
            return cli_7zip
        # zip
        # zip (empty)
        # zip (spanned)
        elif \
                start.startswith(b'PK\x03\x04') or \
                start.startswith(b'PK\x05\x06') or \
                start.startswith(b'PK\x07\x08'):
            try:
                # better handling of multipart
                cli_7zip.check()
                return cli_7zip
            except KeyError:
                return unzip
        # microsoft cabinet file
        elif start.startswith(b'MSCF'):
            return cabextract
        # unshield CAB
        elif start.startswith(b'ISc('):
            return unshield
        # lz4
        elif start.startswith(b'\x04"M\x18'):
            return lz4
        # gzip
        elif start.startswith(b'\x1f\x8b'):
            if len(suffixes) >= 1 and suffixes[-1] == '.tgz':
                return gnu_tar
            elif len(suffixes) >= 2 and suffixes[-2] == '.tar':
                return gnu_tar
            else:
                try:
                    pigz.check()
                    return pigz
                except KeyError:
                    return gzip
        # bzip2
        elif start.startswith(b'BZh'):
            if len(suffixes) >= 2 and suffixes[-2] == '.tar':
                return gnu_tar
            else:
                try:
                    pbzip2.check()
                    return pbzip2
                except KeyError:
                    return bzip2
        # xz
        elif start.startswith(b'\xfd7zXZ\x00'):
            if len(suffixes) >= 1 and suffixes[-1] == '.txz':
                return gnu_tar
            elif len(suffixes) >= 2 and suffixes[-2] == '.tar':
                return gnu_tar
            else:
                try:
                    pixz.check()
                    return pixz
                except KeyError:
                    return xz
        # zstandard
        elif start.startswith(b'(\xb5/\xfd'):
            if len(suffixes) >= 2 and suffixes[-2] == '.tar':
                return gnu_tar
            else:
                return zstd
        # cpio (new ASCII (SVR4))
        # cpio (CRC)
        # cpio (standard ASCII)
        elif \
                start.startswith(b'070701') or \
                start.startswith(b'070702') or \
                start.startswith(b'070707'):
            return cpio
        # exe
        elif start.startswith(b'MZ'):
            # TODO: add additional innoextract validation
            innoextract.check()
            try:
                await innoextract.contents(path)
                return innoextract
            except Exception:
                pass

            unzip.check()
            try:
                await unzip.contents(path)
                return unzip
            except Exception:
                pass

        # squashfs
        elif start.startswith(b'hsqs'):
            return unsquashfs

        elif start.startswith(b'#!/bin/sh\n'):
            f.seek(271)
            if f.read(58) == b'# with modifications for mojosetup and GOG.com installer.\n':  # noqa: E501
                return gog_linux

        # iso9660
        f.seek(32769)
        if f.read(5) == b'CD001':
            return xorriso

    if suffixes := [suffix.lower() for suffix in path.suffixes]:
        if suffixes[-1] == '.cue':
            await bchunk.contents(path)
            try:
                await bchunk.contents(path)
                return bchunk
            except Exception:
                pass
        if suffixes[-1] == '.rvz':
            return dolphin_tool
        if suffixes[-1] == '.nsz':
            return nsz
        # ffs - brotli doesn't have a file signature
        if suffixes[-1] == '.br':
            return brotli
        # unable to find magic number
        elif suffixes[-1] == '.ace':
            return unace
        elif suffixes[-1] == '.img':
            return udisksctl
        # non-iso9660 ex. bluray
        elif suffixes[-1] == '.iso':
            return udisksctl
        # some tars lack file signature
        elif suffixes[-1] == '.tar':
            return gnu_tar

    # 7zz supports a bunch of things
    try:
        cli_7zip.check()
        if await cli_7zip.contents(path):
            return cli_7zip
    except Exception:
        pass

    raise NotImplementedError(path)


class ProcessError(Exception):
    """Process exited non-zero"""


def format_contents(paths):
    file_parents = set()
    for path in paths:
        is_file = not path.endswith(b'/')
        if is_file:
            parent = []
            for part in tuple(path.strip(b'/').split(b'/')[:-1]):
                parent.append(part)
                file_parents.add(tuple(parent))

    contents = set()

    for path in paths:
        if path.endswith(b'/'):
            parts = tuple(path.strip(b'/').split(b'/'))
            if parts not in file_parents:
                contents.add(path)
        else:
            contents.add(path)

    return sorted(contents, key=lambda x: (x.lower(), x))


# from async-executor package.
# copied into this script to ensure this works purely with the stdlib.
# useful for sudo executions where the async-executor may not be present.
class AsyncExecutor:
    def __init__(self, max_concurrent=None):
        if max_concurrent and not isinstance(max_concurrent, int):
            raise ValueError('max_concurrent must type int')
        if max_concurrent and max_concurrent < 0:
            raise ValueError('max_concurrent must be greater than 0')
        self._max_concurrent = max_concurrent or os.cpu_count()
        self._queued = []
        self._pending = set()
        self._completed = set()

    def submit(self, func, *args, **kwargs):
        event = asyncio.Event()
        task = asyncio.create_task(self._wrap(event, func, args, kwargs))
        self._queued.append((event, task))
        return task

    @staticmethod
    async def _wrap(event, func, args, kwargs):
        await event.wait()
        return await func(*args, **kwargs)

    def _fill(self):
        for _ in range(self._max_concurrent - len(self._pending)):
            if not self._queued:
                return
            event, task = self._queued.pop(0)
            event.set()
            self._pending.add(task)

    def __len__(self):
        return len(self._queued) + len(self._pending) + len(self._completed)

    def __aiter__(self):
        return self

    async def __anext__(self):
        if not len(self):
            raise StopAsyncIteration

        if not self._completed:
            self._fill()
            self._completed, self._pending = await asyncio.wait(
                self._pending, return_when=asyncio.FIRST_COMPLETED)

        return self._completed.pop()


async def process_archive(cls, volumes, path, paths, password, args):
    if not args.quiet and not args.stdout:
        print('Extracting', path)
    if args.child:
        dest = _build_extract_dest(path, args.parent, args.child)
        with tempfile.TemporaryDirectory(
                dir=dest.parent, prefix='.extract_',
                suffix=dest.name + '.tmp') as tmp:
            tmp = pathlib.Path(tmp)

            await cls.extract(
                volumes[0],
                tmp,
                paths=paths,
                password=password,
                overwrite=args.force)

            tmp.rename(dest)
            if args.rm:
                for path in volumes:
                    path.unlink()
    else:
        dest = sys.stdout.buffer if args.stdout else _build_extract_dest(
            path, args.parent, args.child)

        await cls.extract(
            volumes[0],
            dest,
            paths=paths,
            password=password,
            overwrite=args.force)

        if args.rm:
            for path in volumes:
                path.unlink()


async def extract_main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-p', dest='parent', metavar='DIR', type=pathlib.Path,
        help='parent directory to extract to')
    parser.add_argument(
        '-c', dest='child', action='store_true',
        help='extract each archive to a unique child directory')
    parser.add_argument(
        '--stdout', action='store_true',
        help='extract a specifc file to stdout')
    parser.add_argument(
        '-l', '--list', action='store_true',
        help='list contents')
    parser.add_argument(
        '-f', '--force', action='store_true',
        help='overwrite existing files/directories')
    parser.add_argument(
        '--rm', action='store_true',
        help='remove archive after successful extraction')
    parser.add_argument(
        '--password', action='store_true',
        help='prompt for password')
    parser.add_argument(
        '-n', metavar='NUM', dest='num_procs', type=_num_procs, default=1,
        help='number of parallel jobs (default: %(default)s)')
    parser.add_argument(
        '-q', '--quiet', action='store_true',
        help='suppress non-error output')
    parser.add_argument('--verbose', action='store_true')
    parser.add_argument('archive', nargs='+', type=pathlib.Path)
    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)

    password = getpass.getpass('Password: ') if args.password else None

    executor = AsyncExecutor(args.num_procs)

    all_volumes = set()
    if args.stdout:
        archives = [args.archive[0]]
        if len(args.archive) == 2:
            paths = [str(args.archive[1])]
        else:
            paths = None
            assert len(args.archive) == 1
    else:
        archives = args.archive
        paths = None

    error_paths = []
    task_to_path = {}
    for path in archives:
        path = path.absolute()

        if path in all_volumes:
            continue

        cls = await _get_class(path)
        LOGGER.debug('Using %s for %s', cls, path)
        cls.check()
        if args.list:
            contents = format_contents(await cls.contents(path))

            # avoid errors with non-unicode file names
            sys.stdout.buffer.write(b'\n'.join(contents) + b'\n')
            sys.stdout.buffer.flush()
        else:
            try:
                volumes = await cls.volumes(path, password)
            except Exception as e:
                LOGGER.exception(e)
                error_paths.append(path)
                continue
            all_volumes.update(volumes)
            task = executor.submit(
                process_archive, cls, volumes, path, paths, password, args)
            task_to_path[task] = path

    async for task in executor:
        path = task_to_path.pop(task)
        try:
            task.result()
        except Exception as e:
            LOGGER.exception(e)
            error_paths.append(path)
    if error_paths:
        for path in sorted(error_paths):
            LOGGER.error('Error extracting "%s"', path)
        sys.exit(1)


if __name__ == '__main__':
    if sys.argv[0].endswith('archive'):
        archive_main()
    else:
        asyncio.run(extract_main())
