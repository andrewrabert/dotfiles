#!/usr/bin/env python3
import argparse
import asyncio
import contextlib
import os
import pathlib
import shutil
import sys
import tempfile


@contextlib.contextmanager
def TempPath(**kwargs):
    """Wrapper around tempfile.NamedTemporaryFile which returns a path object

    Unlike tempfile.NamedTemporaryFile, the FileNotFoundError exception is not
    raised if the file is deleted before the context closes.

    :rtype: pathlib.Path
    """
    with tempfile.NamedTemporaryFile(**kwargs, delete=False) as tmp:
        temp_path = pathlib.Path(tmp.name)
        try:
            yield temp_path
        finally:
            try:
                temp_path.unlink()
            except FileNotFoundError:
                pass


def _all_paths(root):
    stack = [root]
    paths = {root}
    while stack:
        for path in stack.pop().iterdir():
            paths.add(path)
            if path.is_dir() and not path.is_symlink():
                stack.append(path)
    return paths


async def create_zip(path, dest, fast=False):
    if path.is_dir():
        cwd = path
        paths = _all_paths(path)
    else:
        cwd = path.parent
        paths = (path,)

    paths = sorted(
        path.relative_to(cwd)
        for path in paths
        if str(path) != '.'
    )

    level = '-0' if fast else '-9'

    # zip cli thinks existing file means
    dest.unlink()

    proc = await asyncio.create_subprocess_exec(
        'zip',
        level,
        '-nw',  # treat wildcards as regular characters
        '-X',  # exclude extra file attributes, prevents EpubCheck error
        '-@',  # read paths from stdin
        dest,
        cwd=cwd,
        stdin=asyncio.subprocess.PIPE)
    proc.stdin.write(b'\n'.join(bytes(p) for p in paths))
    proc.stdin.close()
    await proc.wait()
    if proc.returncode != 0:
        raise RuntimeError('exit code {proc.returncode}')
    if not fast:
        await optimize_zip(dest)


async def create_7z(path, dest, fast=False):
    if path.is_dir():
        cwd = path
        paths = _all_paths(path)
    else:
        cwd = path.parent
        paths = (path,)

    paths = sorted(
        path.relative_to(cwd)
        for path in paths
        if str(path) != '.'
    )

    # 7z barfs on existing file
    dest.unlink()

    proc = await asyncio.create_subprocess_exec(
        '7z',
        'a',
        '--',
        dest,
        *paths,
        cwd=cwd)
    await proc.wait()
    if proc.returncode != 0:
        raise RuntimeError('exit code {proc.returncode}')


async def create_epub(path, dest, fast=False):
    if path.is_dir():
        cwd = path
        paths = _all_paths(path)
    else:
        cwd = path.parent
        paths = (path,)

    level = '-0' if fast else '-9'

    # zip cli thinks existing file means
    dest.unlink()

    def _path_rank(x):
        if x == 'mimetype':
            rank = 0
        elif x.startswith('META-INF/') or x == 'META-INF':
            rank = 1
        elif x.startswith('OEBPS/') or x == 'OEBPS':
            rank = 2
        else:
            rank = 3
        return rank, x

    paths = sorted(
        (str(path.relative_to(cwd)) for path in paths),
        key=_path_rank
    )

    proc = await asyncio.create_subprocess_exec(
        'zip',
        level,
        '-nw',  # treat wildcards as regular characters
        '-X',  # exclude extra file attributes, prevents EpubCheck error
        '-@',  # read paths from stdin
        dest,
        cwd=cwd,
        stdin=asyncio.subprocess.PIPE)
    proc.stdin.write(b'\n'.join(bytes(p) for p in paths))
    proc.stdin.close()
    await proc.wait()
    if proc.returncode != 0:
        raise RuntimeError('exit code {proc.returncode}')
    if not fast:
        await optimize_zip(dest)


async def create_zstd(path, dest, fast=False):
    if path.is_dir():
        raise RuntimeError
    else:
        paths = (path,)

    level = '-1' if fast else '-22'

    zstd_proc = await asyncio.create_subprocess_exec(
        'zstd', '--quiet', '-f', '-T0', '--ultra', level, '-o', dest,
        '--', paths[0])
    await zstd_proc.wait()
    assert zstd_proc.returncode == 0


async def create_tar_zstd(path, dest, fast=False):
    if path.is_dir():
        cwd = path
        paths = _all_paths(path)
    else:
        cwd = path.parent
        paths = (path,)

    level = '-1' if fast else '-22'

    read, write = os.pipe()

    tar_proc = await asyncio.create_subprocess_exec(
        'tar', 'cf', '-', '-C', cwd, '--no-recursion',
        '--verbatim-files-from', '--null', '-T', '-',
        stdin=asyncio.subprocess.PIPE,
        stdout=write)
    os.close(write)

    zstd_proc = await asyncio.create_subprocess_exec(
        'zstd', '--quiet', '-f', '-T0', '--ultra', level, '-o', dest,
        stdin=read)
    os.close(read)

    tar_proc.stdin.write(b'\0'.join(
        bytes(p.relative_to(cwd))
        for p in paths
        if p != cwd
    ))
    tar_proc.stdin.close()

    await asyncio.gather(tar_proc.wait(), zstd_proc.wait())
    assert tar_proc.returncode == zstd_proc.returncode == 0


async def optimize_zip(path):
    proc = await asyncio.create_subprocess_exec(
        'advzip', '--recompress', '--shrink-insane', path)
    await proc.wait()
    assert proc.returncode == 0


_formats = {
    '7z': {
        'func': create_7z,
        'suffix': '.7z',
    },
    'epub': {
        'func': create_epub,
        'suffix': '.epub',
    },
    'tar-zstd': {
        'func': create_tar_zstd,
        'suffix': '.tar.zst'
    },
    'zip': {
        'func': create_zip,
        'suffix': '.zip',
    },
    'zstd': {
        'func': create_zstd,
        'suffix': '.zst'
    },
}


async def process(source, archive_format, suffix, remove, fast=False):
    source = source.absolute()

    f = _formats[archive_format]
    suffix = suffix or f['suffix']

    dest = pathlib.Path(source.name + suffix).absolute()
    with TempPath(dir=dest.parent, suffix=suffix) as tmp:
        await f['func'](source, tmp, fast)
        print(dest)
        tmp.rename(dest)

    if remove:
        if source.is_dir():
            shutil.rmtree(source)
        else:
            source.unlink()


def _num_procs(value):
    value = int(value)
    if value == 0:
        return os.cpu_count()
    elif value > 0:
        return value
    else:
        raise argparse.ArgumentError('invalid num_procs')


class AsyncExecutor:
    def __init__(self, max_pending=None):
        self.max_pending = \
            os.cpu_count() if max_pending is None else max_pending
        self._queued = []
        self._pending = set()

    def submit(self, func, *args, **kwargs):
        self._queued.append((func, args, kwargs))
        try:
            asyncio.get_running_loop()
        except RuntimeError:
            pass
        else:
            self._fill()

    async def as_completed(self):
        while self._queued or self._pending:
            self._fill()

            done, self._pending = await asyncio.wait(
                self._pending, return_when=asyncio.FIRST_COMPLETED)

            for result in done:
                yield result

    def _fill(self):
        for _ in range(self.max_pending - len(self._pending)):
            if not self._queued:
                return
            func, args, kwargs = self._queued.pop()
            self._pending.add(asyncio.create_task(func(*args, **kwargs)))


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--rm', default=False, action='store_true')
    parser.add_argument('-f', '--format', choices=_formats, default='tar-zstd')
    parser.add_argument('--suffix')
    parser.add_argument('-n', '--num-procs', type=_num_procs, default=1)
    parser.add_argument('--fast', default=False, action='store_true')
    parser.add_argument('source', type=pathlib.Path, nargs='+')
    args = parser.parse_args()

    async def run(args):
        executor = AsyncExecutor(max_pending=args.num_procs)
        for source in args.source:
            executor.submit(
                process, source, args.format, args.suffix, args.rm, args.fast)

        async for future in executor.as_completed():
            try:
                future.result()
            except Exception as e:
                print(e, file=sys.stderr)

    asyncio.run(run(args))


if __name__ == '__main__':
    main()
