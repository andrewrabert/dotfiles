#!/usr/bin/env python3
import argparse
import datetime
import os
import pathlib
import re
import subprocess
import sys

NOTES_DIR = pathlib.Path(os.environ.get('NOTES_DIR', '~/Notes')).expanduser()
TODO_FILE = NOTES_DIR / 'todo.txt'


class Style:
    FG_BLACK = '\u001b[30m'
    FG_RED = '\u001b[31m'
    FG_GREEN = '\u001b[32m'
    FG_YELLOW = '\u001b[33m'
    FG_BLUE = '\u001b[34m'
    FG_MAGENTA = '\u001b[35m'
    FG_CYAN = '\u001b[36m'
    FG_WHITE = '\u001b[37m'

    BG_BLACK = '\u001b[40m'
    BG_RED = '\u001b[41m'
    BG_GREEN = '\u001b[42m'
    BG_YELLOW = '\u001b[43m'
    BG_BLUE = '\u001b[44m'
    BG_MAGENTA = '\u001b[45m'
    BG_CYAN = '\u001b[46m'
    BG_WHITE = '\u001b[47m'

    RESET = '\u001b[0m'
    BRIGHT = '\u001b[1m'
    DIM = '\u001b[2m'
    ITALIC = '\u001b[3m'
    REVERSE = '\u001b[7m'
    UNDERLINE = '\u001b[4m'

    @classmethod
    def strip(cls, text):
        for key, value in cls.__dict__.items():
            if isinstance(value, str):
                text = text.replace(value, '')
        return text


class TodoItem:

    _PRIORITY_REGEX = re.compile(r'^\(([A-Z])\)$')

    def __init__(self, line):
        self.priority = None
        self.completed = False
        self.completed_date = None
        self.created_date = None
        self.due_date = None
        self.contexts = set()
        self.projects = set()
        self.message = None

        parts = line.split()
        if not parts:
            return

        if result := self._PRIORITY_REGEX.match(parts[0]):
            self.priority = result.groups()[0]
            parts.pop(0)

        if not parts:
            return

        if parts[0] == 'x':
            parts.pop(0)
            self.completed = True

        if not parts:
            return

        first_date = self.parse_date(parts[0]) if parts else None
        second_date = self.parse_date(parts[1]) if len(parts) > 1 else None

        if first_date and second_date:
            parts.pop(0)
            parts.pop(1)
            self.completed_date = first_date
            self.created_date = second_date
        elif first_date:
            self.created_date = first_date
            parts.pop(0)

        message_parts = []
        for part in parts:
            if part.startswith('@'):
                self.contexts.add(part)
            elif part.startswith('+'):
                self.projects.add(part)
            elif part.startswith('due:'):
                self.due_date = self.parse_date(part.replace('due:', '', 1))
            elif part:
                message_parts.append(part)
        self.message = ' '.join(message_parts)

    @staticmethod
    def parse_date(value):
        try:
            return datetime.datetime.strptime(value, '%Y-%m-%d').date()
        except ValueError:
            pass

    def __str__(self):
        parts = [
            f'({self.priority})' if self.priority else None,
            'x' if self.completed else None,
            str(self.created_date) if self.created_date else None,
            f'due:{self.due_date}' if self.due_date else None,
            self.message,
            *sorted(self.contexts),
            *sorted(self.projects),
        ]
        return ' '.join(
            part
            for part in parts
            if part
        )

    def __lt__(self, other):
        return str(self) < str(other)


def _render_item(item, details=False):
    parts = []
    if item.priority:
        parts.append('{}({}){}'.format(
            Style.FG_RED,
            item.priority,
            Style.RESET
        ))

    if item.completed:
        message_color = Style.DIM + Style.FG_WHITE
        parts.append(message_color + 'x' + Style.RESET)
    else:
        message_color = Style.FG_WHITE

    if details and item.created_date:
        parts.append('{}{}{}'.format(
            Style.FG_YELLOW,
            item.created_date,
            Style.RESET,
        ))

    if item.due_date:
        if datetime.date.today() > item.due_date:
            parts.append('{}{}due:{}{}'.format(
                Style.FG_BLACK,
                Style.BG_RED,
                item.due_date,
                Style.RESET,
            ))
        else:
            parts.append('{}due:{}{}{}'.format(
                Style.FG_CYAN,
                Style.FG_YELLOW,
                item.due_date,
                Style.RESET,
            ))

    if item.message:
        message_parts = []
        for part in item.message.split():
            if part.startswith(('https://', 'http://')):
                part = '\u001b[4m' + Style.DIM + part
            part = '{}{}{}'.format(
                message_color,
                part,
                Style.RESET
            )
            message_parts.append(part)

        parts.append(' '.join(message_parts))

    if item.contexts:
        parts.append('{}{}{}'.format(
            Style.FG_GREEN,
            ' '.join(sorted(item.contexts)),
            Style.RESET,
        ))

    if item.projects:
        parts.append('{}{}{}'.format(
            Style.FG_BLUE,
            ' '.join(sorted(item.projects)),
            Style.RESET,
        ))

    return ' '.join(parts)


def _parse_due(value):
    if value == 'today':
        return datetime.date.today()
    else:
        return datetime.datetime.strptime(value, '%Y-%m-%d').date()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-f', dest='path', type=pathlib.Path, default=TODO_FILE)

    subparsers = parser.add_subparsers(
        dest='command', metavar='COMMAND', required=True)

    add_parser = subparsers.add_parser('add', help='add stuff')
    add_parser.set_defaults(cmd='add')
    add_parser.add_argument('-d', '--due', type=_parse_due)

    info_parser = subparsers.add_parser('due', help='add stuff')
    info_parser.set_defaults(cmd='due')

    list_parser = subparsers.add_parser('ls', help='add stuff')
    list_parser.set_defaults(cmd='list')
    list_parser.add_argument('-a', dest='all', action='store_true')
    list_parser.add_argument('-l', dest='details', action='store_true')
    list_parser.add_argument('query', nargs='*')

    info_parser = subparsers.add_parser('edit', help='add stuff')
    info_parser.set_defaults(cmd='edit')

    info_parser = subparsers.add_parser('contexts', help='add stuff')
    info_parser.set_defaults(cmd='contexts')

    info_parser = subparsers.add_parser('projects', help='add stuff')
    info_parser.set_defaults(cmd='projects')

    args = parser.parse_args()

    if not args.path.is_file():
        parser.error('path must be specified')
        parser.exit(1)

    items = []

    path = args.path
    for p in path.parent.iterdir():
        if not p.is_file():
            continue
        if p.suffix != path.suffix:
            continue
        if not p.stem.startswith(path.stem):
            continue
        if 'sync-conflict-' in path.name:
            parser.error('sync conflict detected')
            parser.exit(1)

    if args.cmd == 'edit':
        subprocess.run(['nvim', str(path)])

    for line in path.read_text().splitlines():
        items.append(TodoItem(line))

    if args.cmd == 'add':
        item = TodoItem(input('Task: '))
        if not item.created_date:
            item.created_date = datetime.date.today()
        item.due_date = args.due
        items.append(item)
        path.write_text('\n'.join(sorted(str(item) for item in items if str(item))))
    elif args.cmd == 'edit':
        path.write_text('\n'.join(sorted(str(item) for item in items if str(item))))
    elif args.cmd == 'list':
        lines = []
        for item in sorted(items):
            if item.completed and not args.all:
                continue
            show = False
            if args.query:
                for query in args.query:
                    if query in str(item).split():
                        show = True
                        break
            else:
                show = True
            if show:
                lines.append(_render_item(item, args.details))

        lines = sorted(
            lines,
            key=lambda x: Style.strip(x)
        )

        if not sys.stdout.isatty():
            lines = [
                Style.strip(line)
                for line in lines
            ]
        for line in lines:
            print(line)

    elif args.cmd == 'projects':
        projects = set()
        for item in items:
            projects.update(item.projects)
        projects = '\n'.join(sorted(projects))
        if sys.stdout.isatty():
            print(Style.FG_BLUE + projects + Style.RESET)
        else:
            print(projects)
    elif args.cmd == 'contexts':
        contexts = set()
        for item in items:
            contexts.update(item.contexts)
        contexts = '\n'.join(sorted(contexts))
        if sys.stdout.isatty():
            print(Style.FG_GREEN + contexts + Style.RESET)
        else:
            print(contexts)
    elif args.cmd == 'due':
        due_items = sorted(
            (item for item in items if item.due_date),
            key=lambda x: (x.due_date, str(x))
        )
        for item in due_items:
            print(item)


if __name__ == '__main__':
    main()
