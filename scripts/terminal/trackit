#!/usr/bin/env python3
import argparse
import collections
import csv
import datetime
import os
import pathlib
import re
import subprocess
import sys

NOTES_DIR = pathlib.Path(os.environ.get('NOTES_DIR', '~/Notes')).expanduser()
TRACKIT_DIR = NOTES_DIR / 'trackit'

_NUM_RE = re.compile(r'(\d+)')


def fzf(options, prompt=''):
    proc = subprocess.run(
        ['fzf', f'--prompt={prompt}', '--exact', '-i', '--print-query',
         '--layout=reverse'],
        input=b'\n'.join(str(o).encode() for o in options),
        stdout=subprocess.PIPE,
    )
    try:
        result = proc.stdout.decode().splitlines()[-1]
    except IndexError:
        result = None
    return result


def now():
    return datetime.datetime.now(datetime.timezone.utc)


def read_csv(path):
    headers = None
    rows = []
    with open(path) as f:
        reader = csv.reader(f)
        headers = next(reader)
        for row in reader:
            timestamp = datetime.datetime.fromisoformat(row.pop(0))
            rows.append([timestamp, *row])
    return headers, rows


def write_csv(path, headers, rows):
    with open(path, 'w') as f:
        writer = csv.writer(f)
        writer.writerow(headers)
        for row in rows:
            row[0] = row[0].isoformat()
            writer.writerow(row)


def print_table(headers, rows, date, summed=False):
    import tabulate

    new_rows = []
    for row in rows:
        timestamp = row.pop(0).astimezone()
        if timestamp.date() == date:
            new_rows.append([timestamp.strftime('%Y-%m-%d %H:%M'), *row])

    if summed:
        # TODO: allow specification of sum column
        groups = collections.defaultdict(int)
        for row in new_rows:
            matches = _NUM_RE.findall(row[2])
            if len(matches) == 1:
                groups[row[1]] += int(matches[0])
            else:
                raise RuntimeError('cannot sum')

        new_rows = [
            [date.strftime('%Y-%m-%d'), k, v]
            for k, v in groups.items()
        ]

    print(tabulate.tabulate(sorted(new_rows), headers=headers))


def _date_arg(value):
    return datetime.datetime.strptime(value, '%Y-%m-%d').date()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', '--show-path', action='store_true')
    parser.add_argument('-l', '--list', action='store_true')
    parser.add_argument('--date', type=_date_arg,
                        default=datetime.date.today())
    parser.add_argument('--sum', action='store_true')
    parser.add_argument('name', nargs='?')
    args = parser.parse_args()

    if args.name is None:
        name = fzf(
            (path.stem for path in TRACKIT_DIR.iterdir()),
            prompt='name: ')
        if not name:
            sys.exit(1)
    else:
        name = args.name

    path = TRACKIT_DIR.joinpath(name)
    if not name.endswith('.csv'):
        path = path.with_suffix('.csv')

    if path.exists():
        headers, rows = read_csv(path)
    else:
        headers = ['timestamp', 'item', 'value']
        rows = []

    if args.show_path:
        print(path)
        parser.exit()

    if args.list:
        print_table(headers, rows, date=args.date, summed=args.sum)
        parser.exit()

    previous = collections.defaultdict(set)
    for _, item, value in rows:
        previous[item].add(value)

    item = fzf(previous.keys(), prompt=f'{headers[1]}: ')
    if not item:
        sys.exit(1)
    value = fzf(previous[item], prompt=f'{headers[2]}: ')
    if not value:
        sys.exit(1)
    rows.append([now(), item, value])

    write_csv(path, headers, rows)
    print(f'Added "{item}" - "{value}"')


if __name__ == '__main__':
    main()
