#!/usr/bin/env python3
import argparse
import functools
import getpass
import pathlib
import re
import shutil
import subprocess


class p7zip:
    _PART_RE = re.compile(r'(.*\.part)(\d+)(\.rar)$')
    _ALT_PART_RE = re.compile(r'(.*\.)(\d+)$')

    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('7z'):
            raise KeyError

    @staticmethod
    def extract(path, dest, password='', overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['7z', 'x', f'-p{password}', '-ba', '-spe', f'-o{dest}', '--',
             str(path)],
            check=True
        )

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['7z', '-ba', 'l', '--', str(path)],
            stdout=subprocess.PIPE,
            check=True
        )
        return [
            line.split(maxsplit=5)[-1]
            for line in proc.stdout.decode().splitlines()
        ]

    @classmethod
    def volumes(cls, path, password=''):
        result = subprocess.run(
            ['7z', 'l', f'-p{password}', '--', str(path)],
            stdout=subprocess.PIPE,
            check=True)

        num_volumes = 1
        for line in reversed(result.stdout.decode().splitlines()):
            if line.startswith('Volumes = '):
                num_volumes = int(line.split(' = ')[1])
                break

        if num_volumes > 1:
            if found := cls._PART_RE.search(str(path)):
                prefix, vol_num, suffix = found.groups()
            elif found := cls._ALT_PART_RE.search(str(path)):
                prefix, vol_num = found.groups()
                suffix = ''
            else:
                raise NotImplementedError

            volumes = [
                pathlib.Path('{}{}{}'.format(
                    prefix, str(i).rjust(len(vol_num), '0'), suffix))
                for i in range(1, num_volumes + 1)
            ]
            for v in volumes:
                if not v.is_file():
                    raise RuntimeError(f'missing volume {v}')
        else:
            volumes = [path]
        return volumes


class unzip:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('unzip'):
            raise KeyError

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['unzip', '-qq', '-l', path],
            stdout=subprocess.PIPE,
            check=True)
        return [
            line.split(maxsplit=3)[-1]
            for line in proc.stdout.decode().splitlines()
        ]

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['unzip', '-d', dest, path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class unrar:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('unrar'):
            raise KeyError

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['unrar', 'vb', '-v', path],
            stdout=subprocess.PIPE,
            check=True)
        return list(set(
            line.split(maxsplit=3)[-1]
            for line in proc.stdout.decode().splitlines()
        ))

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['unrar', 'x', path, dest],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        proc = subprocess.run(
            ['unrar', 'vt', '-v', path],
            stdout=subprocess.PIPE,
            check=True)
        return [
            path.parent / line.split(maxsplit=1)[-1]
            for line in proc.stdout.decode().splitlines()
            if line.startswith('Archive: ')
        ]


class innoextract:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('innoextract'):
            raise KeyError

        # needed for GOG only ? (*.bin files)
        if not shutil.which('unrar'):
            raise KeyError

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['innoextract', '--gog', '--quiet', '--list', str(path)],
            stdout=subprocess.PIPE,
            check=True)

        contents = []
        for line in proc.stdout.decode().splitlines():
            _, name, _ = line.split('"', 2)
            contents.append(name)
        return contents

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['innoextract', '--gog', '--extract', '--output-dir', dest, path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class gnu_tar:
    @staticmethod
    @functools.lru_cache()
    def check():
        try:
            proc = subprocess.run(
                ['tar', '--version'],
                stdout=subprocess.PIPE,
                check=True)
        except FileNotFoundError:
            raise KeyError

        if 'GNU tar' not in proc.stdout.decode().splitlines()[0]:
            raise KeyError

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['tar', 'tf', str(path), '--force-local'],
            stdout=subprocess.PIPE,
            check=True)
        return proc.stdout.decode().splitlines()

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        args = [
            'tar', 'xf', path, '--force-local', f'--one-top-level={dest}',
        ]
        if overwrite:
            args.append('--overwrite')
        else:
            args.append('--keep-old-files')

        subprocess.run(args, check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class gzip:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('gzip'):
            raise KeyError

    @staticmethod
    def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        with open(target, 'w') as handle:
            subprocess.run(
                ['gzip', '-d', '-c', '--', path],
                stdout=handle,
                check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class xz:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('xz'):
            raise KeyError

    @staticmethod
    def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        with open(target, 'w') as handle:
            subprocess.run(
                ['xz', '-d', '-c', '--', path],
                stdout=handle,
                check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class zstd:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('zstd'):
            raise KeyError

    @staticmethod
    def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['zstd', '-d', '--output-dir-flat', dest, '--', path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class brotli:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('brotli'):
            raise KeyError

    @staticmethod
    def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['brotli', '-d', '--', path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


def _build_dest(path, parent, child):
    if parent is None:
        parent = path.parent
    parent = parent.absolute()

    if child:
        if len(path.suffixes) > 1 and path.suffixes[-2].lower() == '.tar':
            dest = parent / pathlib.Path(path.stem).stem
        else:
            dest = parent / pathlib.Path(path.stem)

        while dest.exists():
            dest = dest.with_name(f'{dest.name}_')
    else:
        dest = parent
    dest.mkdir(parents=True, exist_ok=True)
    return dest


def _get_class(path):
    suffixes = [suffix.lower() for suffix in path.suffixes]
    suffix = suffixes[-1]
    if len(suffixes) > 1 and suffixes[-2] == '.tar':
        cls = gnu_tar
    elif suffix in ('.tar', '.tgz'):
        cls = gnu_tar
    elif suffix == '.zst':
        cls = zstd
    elif suffix == '.br':
        cls = brotli
    elif suffix == '.gz':
        cls = gzip
    elif suffix == '.xz':
        cls = xz
    elif suffix in ('.zip', '.pk3'):
        cls = unzip
    elif suffix == '.rar':
        cls = unrar
    elif suffix == '.exe':
        cls = innoextract
    else:
        cls = p7zip

    cls.check()
    return cls


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-p', dest='parent', metavar='DIR', type=pathlib.Path,
        help='parent directory to extract to')
    parser.add_argument(
        '-c', dest='child', action='store_true',
        help='extract each archive to a unique child directory')
    parser.add_argument(
        '-l', dest='list', action='store_true',
        help='list contents')
    parser.add_argument(
        '-f', '--force', action='store_true',
        help='overwrite existing files/directories')
    parser.add_argument(
        '--rm', action='store_true',
        help='remove archive after successful extraction')
    parser.add_argument(
        '--password', action='store_true',
        help='prompt for password')
    parser.add_argument('archive', nargs='+', type=pathlib.Path)
    args = parser.parse_args()

    password = getpass.getpass('Password: ') if args.password else None

    extracted = set()
    for path in args.archive:
        cls = _get_class(path)
        if args.list:
            contents = sorted(
                cls.contents(path),
                key=lambda x: (x.lower(), x)
            )
            print('\n'.join(contents))
        else:
            if path in extracted:
                continue

            volumes = cls.volumes(path, password)

            cls.extract(
                volumes[0],
                _build_dest(path, args.parent, args.child),
                password=password,
                overwrite=args.force)

            if args.rm:
                for path in volumes:
                    path.unlink()
            extracted.update(volumes)


if __name__ == '__main__':
    main()
