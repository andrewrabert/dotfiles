#!/usr/bin/env python3
import argparse
import getpass
import pathlib
import re
import subprocess


class p7zip:

    _PART_RE = re.compile(r'(.*\.part)(\d+)(\.rar)$')
    _ALT_PART_RE = re.compile(r'(.*\.)(\d+)$')

    @staticmethod
    def extract(path, dest, password=''):
        subprocess.run(
            ['7z', 'x', f'-p{password}', '-ba', '-spe', f'-o{dest}', '--',
             str(path)],
            check=True
        )

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['7z', '-ba', 'l', '--', str(path)],
            stdout=subprocess.PIPE,
            check=True
        )
        return [
            line.split(maxsplit=5)[-1]
            for line in proc.stdout.decode().splitlines()
        ]

    @classmethod
    def volumes(cls, path, password=''):
        result = subprocess.run(
            ['7z', 'l', f'-p{password}', '--', str(path)],
            stdout=subprocess.PIPE,
            check=True)

        num_volumes = 1
        for line in reversed(result.stdout.decode().splitlines()):
            if line.startswith('Volumes = '):
                num_volumes = int(line.split(' = ')[1])
                break

        if num_volumes > 1:
            if found := cls._PART_RE.search(str(path)):
                prefix, vol_num, suffix = found.groups()
            elif found := cls._ALT_PART_RE.search(str(path)):
                prefix, vol_num = found.groups()
                suffix = ''
            else:
                raise NotImplementedError

            volumes = [
                pathlib.Path('{}{}{}'.format(
                    prefix, str(i).rjust(len(vol_num), '0'), suffix))
                for i in range(1, num_volumes + 1)
            ]
            for v in volumes:
                if not v.is_file():
                    raise RuntimeError(f'missing volume {v}')
        else:
            volumes = [path]
        return volumes


class unzip:
    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['unzip', '-qq', '-l', path],
            stdout=subprocess.PIPE,
            check=True)
        return [
            line.split(maxsplit=3)[-1]
            for line in proc.stdout.decode().splitlines()
        ]

    @staticmethod
    def extract(path, dest, password=None):
        subprocess.run(
            ['unzip', '-d', dest, path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class unrar:
    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['unrar', 'vb', '-v', path],
            stdout=subprocess.PIPE,
            check=True)
        return list(set(
            line.split(maxsplit=3)[-1]
            for line in proc.stdout.decode().splitlines()
        ))

    @staticmethod
    def extract(path, dest, password=None):
        subprocess.run(
            ['unrar', 'x', path, dest],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        proc = subprocess.run(
            ['unrar', 'vt', '-v', path],
            stdout=subprocess.PIPE,
            check=True)
        return [
            path.parent / line.split(maxsplit=1)[-1]
            for line in proc.stdout.decode().splitlines()
            if line.startswith('Archive: ')
        ]


class innoextract:

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['innoextract', '--quiet', '--list', str(path)],
            stdout=subprocess.PIPE,
            check=True)

        contents = []
        for line in proc.stdout.decode().splitlines():
            _, name, _ = line.split('"', 2)
            contents.append(name)
        return contents

    @staticmethod
    def extract(path, dest, password=None):
        subprocess.run(
            ['innoextract', '--extract', '--output-dir', dest, path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class tar:

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['tar', 'tf', str(path)],
            stdout=subprocess.PIPE,
            check=True)
        return proc.stdout.decode().splitlines()

    @staticmethod
    def extract(path, dest, password=None):
        subprocess.run(
            ['tar', 'xf', path, f'--one-top-level={dest}', '--keep-old-files'],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class zstd:

    @staticmethod
    def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    def extract(path, dest, password=None):
        subprocess.run(
            ['zstd', '-d', '--output-dir-flat', dest, '--', path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


def _build_dest(path, parent, child):
    if parent is None:
        parent = path.parent
    parent = parent.absolute()

    if child:
        if len(path.suffixes) > 1 and path.suffixes[-2].lower() == '.tar':
            dest = parent / pathlib.Path(path.stem).stem
        else:
            dest = parent / path.with_name(path.stem)

        while dest.exists():
            dest = dest.with_name(f'{dest.name}_')
    else:
        dest = parent
    dest.mkdir(parents=True, exist_ok=True)
    return dest


def _get_class(path):
    suffixes = [suffix.lower() for suffix in path.suffixes]
    suffix = suffixes[-1]
    if len(suffixes) > 1 and suffixes[-2] == '.tar':
        return tar
    elif suffix in ('.tar', '.tgz'):
        return tar
    elif suffix == '.zst':
        return zstd
    elif suffix in ('.zip', '.pk3'):
        return unzip
    elif suffix == '.rar':
        return unrar
    elif suffix == '.exe':
        return innoextract
    else:
        return p7zip


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-p', dest='parent', metavar='DIR', type=pathlib.Path,
        help='parent directory to extract to')
    parser.add_argument(
        '-c', dest='child', action='store_true',
        help='extract each archive to a unique child directory')
    parser.add_argument(
        '-l', dest='list', action='store_true',
        help='list contents')
    parser.add_argument(
        '--rm', action='store_true',
        help='remove archive after successful extraction')
    parser.add_argument(
        '--password', action='store_true',
        help='prompt for password')
    parser.add_argument('archive', nargs='+', type=pathlib.Path)
    args = parser.parse_args()

    password = getpass.getpass('Password: ') if args.password else None

    extracted = set()
    for path in args.archive:
        cls = _get_class(path)
        if args.list:
            print('\n'.join(sorted(cls.contents(path))))
        else:
            if path in extracted:
                continue

            volumes = cls.volumes(path, password)

            cls.extract(
                volumes[0],
                _build_dest(path, args.parent, args.child),
                password)

            if args.rm:
                for path in volumes:
                    path.unlink()
            extracted.update(volumes)


if __name__ == '__main__':
    main()
