#!/usr/bin/env python3
import argparse
import contextlib
import functools
import getpass
import io
import os
import pathlib
import re
import shutil
import subprocess
import zipfile


class p7zip:
    _PART_RE = re.compile(r'(.*\.part)(\d+)(\.rar)$')
    _ALT_PART_RE = re.compile(r'(.*\.)(\d+)$')

    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('7z'):
            raise KeyError

    @staticmethod
    def extract(path, dest, password='', overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['7z', 'x', f'-p{password}', '-ba', '-spe', f'-o{dest}', '--',
             str(path)],
            check=True
        )

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['7z', '-ba', 'l', '--', str(path)],
            stdout=subprocess.PIPE,
            check=True
        )
        return [
            line.split(maxsplit=5)[-1]
            for line in proc.stdout.decode().splitlines()
        ]

    @classmethod
    def volumes(cls, path, password=''):
        result = subprocess.run(
            ['7z', 'l', f'-p{password}', '--', str(path)],
            stdout=subprocess.PIPE,
            check=True)

        num_volumes = 1
        for line in reversed(result.stdout.decode().splitlines()):
            if line.startswith('Volumes = '):
                num_volumes = int(line.split(' = ')[1])
                break

        if num_volumes > 1:
            if found := cls._PART_RE.search(str(path)):
                prefix, vol_num, suffix = found.groups()
            elif found := cls._ALT_PART_RE.search(str(path)):
                prefix, vol_num = found.groups()
                suffix = ''
            else:
                raise NotImplementedError

            volumes = [
                pathlib.Path('{}{}{}'.format(
                    prefix, str(i).rjust(len(vol_num), '0'), suffix))
                for i in range(1, num_volumes + 1)
            ]
            for v in volumes:
                if not v.is_file():
                    raise RuntimeError(f'missing volume {v}')
        else:
            volumes = [path]
        return volumes


class udisksctl:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('udisksctl'):
            raise KeyError

    @classmethod
    def contents(cls, path):
        with cls._loop_context(path) as device:
            with cls._mount_context(device) as mount_path:
                return sorted(
                    str(path.relative_to(mount_path))
                    for path in cls._child_paths(mount_path)
                )

    @classmethod
    def extract(cls, path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError

        with cls._loop_context(path) as device:
            with cls._mount_context(device) as mount_path:
                for path in pathlib.Path(mount_path).iterdir():
                    newpath = dest.joinpath(
                        path.relative_to(mount_path))
                    shutil.copytree(path, newpath)

    @staticmethod
    def volumes(path, password=''):
        return [path]

    @staticmethod
    @contextlib.contextmanager
    def _loop_context(path):
        proc = subprocess.run(
            ['udisksctl', 'loop-setup', '--no-user-interaction',
             '--read-only', '--file', path],
            stdout=subprocess.PIPE,
            check=True)
        # strip trailing period
        output = proc.stdout.decode().strip()
        start = f'Mapped file {path} as '
        if output.startswith(start) and output.endswith('.'):
            device = output.replace(start, '', 1)[:-1]
        else:
            raise RuntimeError(f'udisksctl error: {output}')

        try:
            yield device
        finally:
            proc = subprocess.run(
                ['udisksctl', 'loop-delete', '--no-user-interaction',
                 '--block-device', device],
                stdout=subprocess.DEVNULL,
                check=True)

    @staticmethod
    @contextlib.contextmanager
    def _mount_context(device):
        proc = subprocess.run(
            ['udisksctl', 'mount', '--no-user-interaction',
             '--block-device', device],
            stdout=subprocess.PIPE,
            check=True)
        output = proc.stdout.decode().strip()
        start = f'Mounted {device} at '
        if output.startswith(start):
            path = output.replace(start, '', 1)
        else:
            raise RuntimeError(f'udisksctl error: {output}')

        try:
            yield path
        finally:
            subprocess.run(
                ['udisksctl', 'unmount', '--no-user-interaction',
                 '--block-device', device],
                stdout=subprocess.DEVNULL,
                check=True)

    @staticmethod
    def _child_paths(root):
        stack = [pathlib.Path(root)]
        paths = []
        while stack:
            for path in stack.pop().iterdir():
                paths.append(path)
                if path.is_dir():
                    stack.append(path)
        return paths


class unzip:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('unzip'):
            raise KeyError

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['unzip', '-qq', '-l', path],
            stdout=subprocess.PIPE,
            check=True)
        return [
            line.split(maxsplit=3)[-1]
            for line in proc.stdout.decode().splitlines()
        ]

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['unzip', '-d', dest, path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class unrar:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('unrar'):
            raise KeyError

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['unrar', 'vb', '-v', path],
            stdout=subprocess.PIPE,
            check=True)
        return list(set(
            line.split(maxsplit=3)[-1]
            for line in proc.stdout.decode().splitlines()
        ))

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['unrar', 'x', path, dest],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        proc = subprocess.run(
            ['unrar', 'vt', '-v', path],
            stdout=subprocess.PIPE,
            check=True)
        return [
            path.parent / line.split(maxsplit=1)[-1]
            for line in proc.stdout.decode().splitlines()
            if line.startswith('Archive: ')
        ]


class innoextract:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('innoextract'):
            raise KeyError

        # needed for GOG only ? (*.bin files)
        if not shutil.which('unrar'):
            raise KeyError

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['innoextract', '--gog', '--quiet', '--list', str(path)],
            stdout=subprocess.PIPE,
            check=True)

        contents = []
        for line in proc.stdout.decode().splitlines():
            _, name, _ = line.split('"', 2)
            contents.append(name)
        return contents

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['innoextract', '--gog', '--extract', '--output-dir', dest, path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class gog_linux:
    @staticmethod
    def check():
        pass

    @classmethod
    def contents(cls, path):
        with cls._zipfile(path) as zf:
            contents = set()
            for zi in zf.infolist():
                if target := cls._local_target(zi):
                    contents.add(target)
            return sorted(contents)

    @classmethod
    def extract(cls, path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        with cls._zipfile(path) as zf:
            for zi in zf.infolist():
                if target := cls._local_target(zi):
                    zi.filename = target
                    zf.extract(zi, dest)

    @staticmethod
    def _local_target(zi):
        if zi.filename.startswith('data/noarch/'):
            if target := zi.filename[12:]:
                return target

    @staticmethod
    def volumes(path, password=''):
        return [path]

    class _ZipFile(zipfile.ZipFile):
        def _extract_member(self, member, targetpath, pwd):
            # extract doesn't  set file metadta
            if not isinstance(member, zipfile.ZipInfo):
                member = self.getinfo(member)

            targetpath = super()._extract_member(member, targetpath, pwd)

            attr = member.external_attr >> 16
            if attr != 0:
                os.chmod(targetpath, attr)
            return targetpath

    @classmethod
    @contextlib.contextmanager
    def _zipfile(cls, path):
        with open(path, 'rb') as f:
            FILESIZE_RE = re.compile(r'filesizes="(\d+?)"')
            OFFSET_RE = re.compile(r'offset=`head -n (\d+?) "\$0"')

            beginning = f.read(10240).decode(errors="ignore")
            offset_match = OFFSET_RE.search(beginning)
            script_lines = int(offset_match.group(1))

            # Read the number of lines to determine the script size
            f.seek(0, io.SEEK_SET)
            for line in range(0, script_lines):
                f.readline()
            script_size = f.tell()

            # Read the script
            f.seek(0, io.SEEK_SET)
            script_bin = f.read(script_size)
            script = script_bin.decode()

            # Filesize is for the MojoSetup archive, not the actual game data
            filesize_match = FILESIZE_RE.search(script)
            filesize = int(filesize_match.group(1))

            # Extract the game data archive
            dataoffset = script_size + filesize
            f.seek(dataoffset, io.SEEK_SET)
            yield cls._ZipFile(f)


class gnu_tar:
    @staticmethod
    @functools.lru_cache()
    def check():
        try:
            proc = subprocess.run(
                ['tar', '--version'],
                stdout=subprocess.PIPE,
                check=True)
        except FileNotFoundError:
            raise KeyError

        if 'GNU tar' not in proc.stdout.decode().splitlines()[0]:
            raise KeyError

    @staticmethod
    def contents(path):
        proc = subprocess.run(
            ['tar', 'tf', str(path), '--force-local'],
            stdout=subprocess.PIPE,
            check=True)
        return proc.stdout.decode().splitlines()

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        args = [
            'tar', 'xf', path, '--force-local', f'--one-top-level={dest}',
        ]
        if overwrite:
            args.append('--overwrite')
        else:
            args.append('--keep-old-files')

        subprocess.run(args, check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class gzip:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('gzip'):
            raise KeyError

    @staticmethod
    def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        with open(target, 'w') as handle:
            subprocess.run(
                ['gzip', '-d', '-c', '--', path],
                stdout=handle,
                check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class xz:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('xz'):
            raise KeyError

    @staticmethod
    def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        target = dest / path.with_suffix('').name
        with open(target, 'w') as handle:
            subprocess.run(
                ['xz', '-d', '-c', '--', path],
                stdout=handle,
                check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class zstd:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('zstd'):
            raise KeyError

    @staticmethod
    def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['zstd', '-d', '--output-dir-flat', dest, '--', path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


class brotli:
    @staticmethod
    @functools.lru_cache()
    def check():
        if not shutil.which('brotli'):
            raise KeyError

    @staticmethod
    def contents(path):
        return [path.with_suffix('').name]

    @staticmethod
    def extract(path, dest, password=None, overwrite=False):
        if overwrite:
            raise NotImplementedError
        subprocess.run(
            ['brotli', '-d', '--', path],
            check=True)

    @staticmethod
    def volumes(path, password=''):
        return [path]


def _build_dest(path, parent, child):
    if parent is None:
        parent = path.parent
    parent = parent.absolute()

    if child:
        if len(path.suffixes) > 1 and path.suffixes[-2].lower() == '.tar':
            dest = parent / pathlib.Path(path.stem).stem
        else:
            dest = parent / pathlib.Path(path.stem)

        while dest.exists():
            dest = dest.with_name(f'{dest.name}_')
    else:
        dest = parent
    dest.mkdir(parents=True, exist_ok=True)
    return dest


def _get_class(path):
    with open(path, 'rb') as f:
        start = f.read(10)

        # rar < 5.0
        if start.startswith(b'Rar!\x1a\x07\x00'):
            return unrar
        # rar >= 5.0
        elif start.startswith(b'Rar!\x1a\x07\x01\x00'):
            return unrar
        # 7-zip
        elif start.startswith(b"7z\xbc\xaf'\x1c"):
            return p7zip
        # zip
        elif start.startswith(b'PK\x03\x04'):
            return unzip
        # zip (empty)
        elif start.startswith(b'PK\x05\x06'):
            return unzip
        # zip (spanned)
        elif start.startswith(b'PK\x07\x08'):
            return unzip
        # exe
        elif start.startswith(b'MZ'):
            # TODO: add additional innoextract validation
            return innoextract
        elif start.startswith(b'#!/bin/sh\n'):
            f.seek(271)
            if f.read(58) == b'# with modifications for mojosetup and GOG.com installer.\n':  # noqa: E501
                return gog_linux

    suffixes = [suffix.lower() for suffix in path.suffixes]
    suffix = suffixes[-1]
    if len(suffixes) > 1 and suffixes[-2] == '.tar':
        return gnu_tar
    elif suffix in ('.tar', '.tgz'):
        return gnu_tar
    elif suffix == '.zst':
        return zstd
    elif suffix == '.br':
        return brotli
    elif suffix == '.gz':
        return gzip
    elif suffix == '.xz':
        return xz
    elif suffix == '.iso':
        raise RuntimeError('iso support is fucked')
        return udisksctl

    raise NotImplementedError(path)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-p', dest='parent', metavar='DIR', type=pathlib.Path,
        help='parent directory to extract to')
    parser.add_argument(
        '-c', dest='child', action='store_true',
        help='extract each archive to a unique child directory')
    parser.add_argument(
        '-l', dest='list', action='store_true',
        help='list contents')
    parser.add_argument(
        '-f', '--force', action='store_true',
        help='overwrite existing files/directories')
    parser.add_argument(
        '--rm', action='store_true',
        help='remove archive after successful extraction')
    parser.add_argument(
        '--password', action='store_true',
        help='prompt for password')
    parser.add_argument('archive', nargs='+', type=pathlib.Path)
    args = parser.parse_args()

    password = getpass.getpass('Password: ') if args.password else None

    extracted = set()
    for path in args.archive:
        cls = _get_class(path)
        cls.check()
        if args.list:
            contents = sorted(
                cls.contents(path),
                key=lambda x: (x.lower(), x)
            )
            print('\n'.join(contents))
        else:
            if path in extracted:
                continue

            volumes = cls.volumes(path, password)

            cls.extract(
                volumes[0],
                _build_dest(path, args.parent, args.child),
                password=password,
                overwrite=args.force)

            if args.rm:
                for path in volumes:
                    path.unlink()
            extracted.update(volumes)


if __name__ == '__main__':
    main()
