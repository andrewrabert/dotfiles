#!/usr/bin/env python3
import argparse
import hashlib
import os
import pathlib
import subprocess
import sys
import tempfile


class FileCache:
    def __init__(self, name, cache_home=None):
        if cache_home := cache_home or os.environ.get("XDG_CACHE_HOME"):
            cache_home = pathlib.Path(cache_home)
        else:
            cache_home = pathlib.Path.home() / ".cache"
        self.cache_root = cache_home / name
        self.cache_root.mkdir(exist_ok=True)

    def get(self, key):
        cache_path = self.cache_root / key
        if cache_path.exists():
            return cache_path.read_bytes()

    def set(self, key, data):
        cache_path = self.cache_root / key
        safe_write_bytes(cache_path, data)


def safe_write_bytes(path, data):
    stat = None
    if path.exists():
        if not os.access(path, os.W_OK):
            raise PermissionError(f"No write permission: {path}")
        stat = path.stat()

    with tempfile.NamedTemporaryFile(delete=False, dir=path.parent) as handle:
        temp_path = pathlib.Path(handle.name)
        try:
            temp_path.write_bytes(data)
            if stat:
                for ids in ((stat.st_uid, -1), (-1, stat.st_gid)):
                    try:
                        os.chown(temp_path, *ids)
                    except PermissionError:
                        pass
                temp_path.chmod(stat.st_mode)
            temp_path.replace(path)
        finally:
            try:
                temp_path.unlink()
            except FileNotFoundError:
                pass


def cache_key(path, name):
    path = path.absolute()
    stat = path.stat()
    path_hash = hashlib.md5(str(path).encode()).hexdigest()
    return "_".join(
        [path_hash, str(stat.st_size), str(int(stat.st_mtime)), name]
    )


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--path", required=True, type=pathlib.Path)
    parser.add_argument("--name", required=True)
    parser.add_argument("command")
    parser.add_argument("args", nargs="*")
    args = parser.parse_args()

    cache = FileCache("pathcacher")
    key = cache_key(args.path, args.name)
    data = cache.get(key)
    if data is None:
        proc = subprocess.run(
            [args.command, *args.args], check=True, stdout=subprocess.PIPE
        )
        data = proc.stdout

        cache.set(key, data)
    sys.stdout.buffer.write(data)


if __name__ == "__main__":
    main()
