#!/usr/bin/env python3
import argparse
import pathlib
import string

VALID = [*" .,-_()[]'", *string.ascii_letters, *string.digits]


def all_files(root):
    files = []
    stack = [root]
    while stack:
        for path in stack.pop().iterdir():
            if path.is_file():
                files.append(path)
            elif path.is_dir():
                stack.append(path)
    return sorted(files)


def escape_path(path):
    new_parts = []
    for part in path.parts:
        new_part = ''.join([c for c in part if c in VALID])

        if not new_part:
            raise ValueError(f'Unable to escape {path}')
        new_parts.append(new_part)
    return pathlib.Path(*new_parts)


def rename_files(root, dry_run=True):
    renamed_paths = []

    paths = all_files(root) if root.is_dir() else [root]

    for f in paths:
        new_f = escape_path(f)
        if new_f != f:
            if new_f.exists() or new_f in renamed_paths:
                raise ValueError(f'"{new_f}" already exists')
            if not dry_run:
                new_f.parent.mkdir(parents=True, exist_ok=True)
                f.rename(new_f)
            renamed_paths.append(new_f)
            print(f)
            print(new_f)
            print()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('path', type=pathlib.Path, nargs='+')
    parser.add_argument('-c', '--commit',
                        action='store_true',
                        help='commit renames to disk. otherwise dry run')
    args = parser.parse_args()

    for path in args.path:
        # always perform a dry run to check for errors
        rename_files(path, dry_run=True)

        if args.commit:
            rename_files(path, dry_run=False)


if __name__ == '__main__':
    main()
