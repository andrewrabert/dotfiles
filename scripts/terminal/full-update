#!/usr/bin/env sh
set -eu

YELLOW='\033[1;33m'
RESET_COLOR='\033[0m'

run_script() {
    printf '%bRunning %s ...%b\n' "$YELLOW" "${1##*/}" "$RESET_COLOR"
    "$@"
}

show_help() {
    cat << EOF
usage: full-update [--skip NAME]... [script ...]

    --skip NAME skip script by name (can be repeated)
    --help      show help and exit
EOF
}

SKIP_SCRIPTS=""

should_skip() {
    case ",$SKIP_SCRIPTS," in
        *,"$1",*) return 0 ;;
        *) return 1 ;;
    esac
}

if command -v hostname > /dev/null; then 
    export HOST_DOTFILES="$(hostname)"
fi
export HOST_DOTFILES="$(zsh -lic 'if [ -f ~/.zshenv.local ]; then . ~/.zshenv.local; fi && echo "$HOST_DOTFILES"')"
if [ -z "$HOST_DOTFILES" ]; then
    echo 'error: cannot determine hostname' >&2
    exit 1
fi

BREW_GNUBIN='/opt/homebrew/opt/coreutils/libexec/gnubin'
if [ -d "$BREW_GNUBIN" ]; then
	export PATH="$BREW_GNUBIN:$PATH"
fi

# Setup ro/rw handling for pikvm
if [ "$HOST_DOTFILES" = "pikvm" ]; then
    was_readonly=0
    if grep -q ' / .*\bro\b' /proc/mounts; then
        was_readonly=1
        rw
    fi

    cleanup() {
        if [ $was_readonly -eq 1 ]; then
            ro
        fi
    }

    trap 'cleanup' EXIT
    trap 'cleanup; exit 1' INT TERM
fi

while [ $# -gt 0 ]; do
    case "$1" in
        --help)
            show_help
            exit
            ;;
        --skip)
            if [ -n "$SKIP_SCRIPTS" ]; then
                SKIP_SCRIPTS="$SKIP_SCRIPTS,$2"
            else
                SKIP_SCRIPTS="$2"
            fi
            shift 2
            ;;
        *)
            script_name="$1"
            shift
            for d in "$DOTFILES" $(env | grep ^DOTFILES_ | sed 's/.*=//g' | sort); do
                script="${d}/full-update/${script_name}"
                if [ -f "$script" ]; then
                    run_script "$script" "$@"
                fi
            done
            exit
            ;;
    esac
done

# Special case for pikvm: run specific scripts only
if [ "$HOST_DOTFILES" = "pikvm" ]; then
    "$0" 00-dotfiles
    "$0" 10-pikvm
    "$0" 60-tmux
    "$0" 60-zsh
    exit
fi

process() {
    if ! [ -d "$1"/full-update ]; then
        return
    fi
    printf '%bfull-update - %s - start %s%b\n' "$YELLOW" "$1" "$(date)" "$RESET_COLOR"

    # update dotfiles to ensure full-update/* is up-to-date
    cmd="$1"/full-update/00-dotfiles
    if [ -f "$cmd" ]; then
        if should_skip "00-dotfiles"; then
            printf '%bSkipping 00-dotfiles%b\n' "$YELLOW" "$RESET_COLOR"
        else
            run_script "$cmd" --system
        fi
    fi

    for cmd in "$1"/full-update/*; do
        script_basename="${cmd##*/}"
        if should_skip "$script_basename"; then
            printf '%bSkipping %s%b\n' "$YELLOW" "$script_basename" "$RESET_COLOR"
            continue
        fi
        case "$cmd" in
            */00-dotfiles)
                # already run
                ;;
            *)
                run_script "$cmd"
                ;;
        esac
    done
    printf '%bfull-update - %s - done %s%b\n' "$YELLOW" "$1" "$(date)" "$RESET_COLOR"
}

process "$DOTFILES"

for d in $(env | grep ^DOTFILES_ | sort); do
    process "$(echo "$d" | cut -d = -f 2)"
done
