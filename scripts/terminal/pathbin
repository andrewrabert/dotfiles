#!/usr/bin/env python
import argparse
import collections
import json
import os
import pathlib


def executables_in_path():
    executables = set()
    for directory in os.get_exec_path():
        root = pathlib.Path(directory)
        if root.is_dir():
            for path in root.iterdir():
                try:
                    if path.is_file() and os.access(path, os.X_OK):
                        executables.add(path.name)
                except PermissionError:
                    pass
    return executables


def main():
    parser = argparse.ArgumentParser(description='list executables in path')
    mutex_group = parser.add_mutually_exclusive_group()
    mutex_group.add_argument(
        '-c', dest='group_command', action='store_true',
        help=('group by command. directories are ordered as '
              'they appear in the path list'))
    mutex_group.add_argument(
        '-d', dest='group_directory', action='store_true',
        help='group by directory')
    parser.add_argument(
        'path', nargs='*', default=os.get_exec_path(),
        help='paths to search (default: $PATH)')
    args = parser.parse_args()

    executables = []
    for path in (pathlib.Path(p) for p in args.path):
        executables.extend(list_executables(path))

    if args.group_command:
        result = collections.defaultdict(list)
        for path in executables:
            result[path.name].append(str(path.parent))
        print(json.dumps(result, indent=2, sort_keys=True))
    elif args.group_directory:
        result = collections.defaultdict(list)
        for path in executables:
            result[str(path.parent)].append(str(path.name))
        for contents in result.values():
            contents.sort()
        print(json.dumps(result, indent=2, sort_keys=True))
    else:
        print('\n'.join(sorted(set(str(path.name) for path in executables))))


if __name__ == '__main__':
    main()
