#!/usr/bin/env -S uv run --script
"""
Music library organization tool with metadata support.

# /// script
# dependencies = [
#     "charset_normalizer",
#     "python-magic",
#     "pytaglib",
# ]
# ///
"""

import argparse
import collections
import logging
import os
import pathlib
import stat
import string
import subprocess
import tempfile
import unicodedata

import charset_normalizer
import magic  # package: python-magic
import taglib

LIBRARY = pathlib.Path("/storage/Audio/Library")

FLAC_EXT = ".flac"
MP3_EXT = ".mp3"
OPUS_EXT = ".opus"

AUDIO_EXT = (FLAC_EXT, MP3_EXT, OPUS_EXT)

IMAGE_EXT = (".jpg", ".png")
IMAGE_PREFIX = "cover"

CUE_EXT = ".cue"

IGNORED_PATH_CHARS = {"&", "/", "\\", ".", ":", "*", "?", '"', "<", ">", "|"}

# preferred suffix is first in list
MIME_SUFFIXES = {
    "application/pdf": [
        ".pdf",
    ],
    "audio/flac": [
        ".flac",
    ],
    "audio/mpeg": [
        ".mp3",
    ],
    "audio/ogg": [
        ".ogg",
        ".opus",
    ],
    "image/gif": [
        ".gif",
    ],
    "image/jpeg": [
        ".jpg",
    ],
    "image/png": [
        ".png",
    ],
    "text/plain": [
        ".txt",
        ".accurip",
        ".cue",
        ".log",
        ".nfo",
    ],
}


EXPECTED_TAGS = (
    "albumartist",
    "album",
    "artist",
    "date",
    "genre",
    "title",
    "tracknumber",
)


LOGGER = logging.getLogger("music-organizer")


def folder_name(tag_value):
    chars = []
    for c in tag_value:
        if not chars and c == ".":
            continue
        if c in IGNORED_PATH_CHARS:
            continue
        if not c.isprintable():
            raise ValueError("unprintable character")
        chars.append(c)
    name = "".join(chars)
    return " ".join(part for part in name.split())


def cue_track_count(path, dry_run=False):
    """Return the number of tracks in a .cue file

    Also converts the file to UTF-8 if it's not
    """
    data = path.read_bytes()
    text = data.decode(charset_normalizer.detect(data)["encoding"])
    if data != text:
        if not dry_run:
            path.write_text(text)
        else:
            LOGGER.info(f"Would convert encoding for: {path}")

    return sum(
        1 for line in text.split("\n") if line.strip().startswith("TRACK ")
    )


def split_flac(flac_path, cue_path, dry_run=False):
    parent = cue_path.absolute().parent
    if dry_run:
        LOGGER.info(f"Would split {flac_path}")
        return
    LOGGER.info(f"Splitting {flac_path}")
    with tempfile.TemporaryDirectory(
        dir=parent, prefix=".shntool_split"
    ) as tmpdir:
        subprocess.run(
            [
                "shntool",
                "split",
                "-q",
                "-d",
                tmpdir,
                "-f",
                cue_path.name,
                "-o",
                "flac flac --best --verify --output-name split%f -",
                "-t",
                "%n",
                flac_path.name,
            ],
            cwd=parent,
            check=True,
        )
        for path in pathlib.Path(tmpdir).iterdir():
            path.replace(parent / path.name)
    flac_path.unlink()


def check_cue_files(root_path, dry_run=False):
    paths = [p for p in root_path.iterdir() if p.is_file()]
    flac_files = [p for p in paths if p.suffix == FLAC_EXT]
    if not flac_files:
        return

    cue_files = [p for p in paths if p.suffix in CUE_EXT]

    if len(cue_files) > 1:
        LOGGER.error(f"Multiple .cue files: {root_path}")
    elif len(cue_files) == len(flac_files) == 1:
        cue_file = cue_files[0]
        num_tracks = cue_track_count(cue_file, dry_run)
        if num_tracks == 0:
            LOGGER.error(f"Bad cue file: {cue_file}")
        elif num_tracks != 1:
            split_flac(flac_files[0], cue_file, dry_run)


def organize_images(root_path, dry_run=False):
    paths = [p for p in root_path.iterdir() if p.is_file()]
    audio_files = [p for p in paths if p.suffix in AUDIO_EXT]
    if not audio_files:
        return

    images = [p for p in paths if p.suffix in IMAGE_EXT]
    if len(images) == 1:
        image = images[0]
        target = image.parent / (IMAGE_PREFIX + image.suffix)
        if image != target:
            if not dry_run:
                image.replace(pathlib.Path(image.parent, target))
            else:
                LOGGER.info(f"Would rename image: {image} -> {target}")
    elif len(images) > 1:
        LOGGER.error(f"Multiple images: {root_path}")
    else:
        LOGGER.error(f"No images: {root_path}")


def check_metadata(path, metadata):
    for tag in EXPECTED_TAGS:
        try:
            metadata[tag]
        except KeyError:
            LOGGER.error(f'File {path} missing "{tag}"')


def fix_metadata(path, metadata, dry_run=False):
    changed = False
    for tag, values in metadata.items():
        new_values = sorted(
            {
                unicodedata.normalize(
                    "NFC", " ".join(v for v in value.split() if v)
                )
                for value in values
            }
        )
        if new_values != sorted(values):
            metadata[tag] = new_values
            LOGGER.info(
                f'Fixing whitespace/unicode normalization in "{tag}": "{path}"'
            )
            changed = True

        for v in (tag, *values):
            for c in v:
                if not c.isprintable():
                    LOGGER.error(
                        f'Non-printable character detected in "{tag}": "{path}"'
                    )

    if changed and not dry_run:
        with taglib.File(str(path), save_on_exit=True) as song:
            song.tags = {k.upper(): v for k, v in metadata.items()}


def fix_tracknumber(path, metadata, dry_run=False):
    try:
        tracknumber = metadata["tracknumber"][0]
    except KeyError:
        return

    if "/" in tracknumber:
        tracknumber, all_tracks = tracknumber.split("/")

        try:
            int(tracknumber)
        except ValueError:
            LOGGER.error(f'Unhandled tracknumber: "{tracknumber}"')

        metadata["tracknumber"] = [tracknumber]
        LOGGER.info(f'Fixing track number: "{path}"')
        if not dry_run:
            with taglib.File(str(path), save_on_exit=True) as song:
                song.tags = {k.upper(): v for k, v in metadata.items()}


def rename_extensions(path, dry_run=False):
    for f in {p for p in path.iterdir() if p.is_file()}:
        mime = magic.from_file(str(f), mime=True)
        if mime in MIME_SUFFIXES:
            if expected := MIME_SUFFIXES[mime]:
                if f.suffix not in expected:
                    if f.suffix.lower() in expected:
                        safe_rename(f, f.stem + f.suffix.lower(), dry_run)
                    elif mime == "text/plain":
                        LOGGER.error('Unhandled text/plain suffix: "%s"', f)
                    else:
                        safe_rename(f, f.stem + expected[0], dry_run)
        else:
            LOGGER.error('Unhandled MIME: "%s" for "%s"', mime, f)


def rename_from_tags(path, metadata, dry_run=False):
    try:
        title = metadata["title"][0]
    except KeyError:
        return

    try:
        tracknumber = int(metadata["tracknumber"][0])
    except ValueError:
        LOGGER.error(f'Cannot rename "{path}"')
        return
    # Only modify when under 10 to retain tracks >= 100
    if tracknumber < 10:
        tracknumber = f"{tracknumber:02d}"

    for char in IGNORED_PATH_CHARS:
        title = title.replace(char, " ")
    title = " ".join(title.split())
    safe_rename(path, f"{tracknumber} {title}{path.suffix}", dry_run)


def safe_rename(source, name, dry_run=False):
    target = source.with_name(name)
    if source != target:
        if target.exists():
            LOGGER.error(
                f'Error renaming "{source}" to "{target}": already exists'
            )
        else:
            LOGGER.info(f'Renaming "{source}" to "{target}"')
            if not dry_run:
                source.replace(target)


def all_dirs(root):
    directories = [root]
    stack = [root]
    while stack:
        for path in stack.pop().iterdir():
            if path.is_dir():
                directories.append(path)
                stack.append(path)
    return sorted(directories)


def set_permissions(path):
    os.chown(path, os.getuid(), os.getgid())
    if path.is_dir():
        os.chmod(
            path,
            stat.S_IRUSR
            + stat.S_IRGRP
            + stat.S_IROTH
            + stat.S_IXUSR
            + stat.S_IXGRP
            + stat.S_IXOTH
            + stat.S_IWUSR,
        )
    else:
        os.chmod(
            path, stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH + stat.S_IWUSR
        )


def setup_logging(name, level=logging.INFO):
    logger = logging.getLogger()
    logger.setLevel(level)

    fmt = logging.Formatter("%(levelname)s %(message)s")

    sh = logging.StreamHandler()
    sh.setLevel(level)
    sh.setFormatter(fmt)
    logger.addHandler(sh)

    fh = logging.FileHandler(
        filename=pathlib.Path(tempfile.gettempdir()) / f"{name}.log", mode="w"
    )
    fh.setLevel(level)
    fh.setFormatter(fmt)
    logger.addHandler(fh)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("directory", type=pathlib.Path)
    parser.add_argument("--library", action="store_true")
    parser.add_argument("-t", "--check-tags", action="store_true")
    parser.add_argument(
        "--organize-dirs",
        type=pathlib.Path,
        help="Enable directory organization; parent directory where artist folders are located",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without making changes",
    )
    args = parser.parse_args()

    # Convert organize_dirs to absolute path if specified
    if args.organize_dirs:
        args.organize_dirs = args.organize_dirs.absolute()

    setup_logging("music-organizer")

    artists = set()

    for root_path in all_dirs(args.directory.absolute()):
        set_permissions(root_path)
        rename_extensions(root_path, args.dry_run)
        organize_images(root_path, args.dry_run)
        check_cue_files(root_path, args.dry_run)

        if args.check_tags or args.organize_dirs:
            artists = set()
            albumartists = set()
            albums = set()

            missing_album = False
            missing_artist = False

            tracks = []
            has_symlinks = False
            has_subdirs = False
            for path in sorted(root_path.iterdir()):
                if path.is_symlink():
                    has_symlinks = True
                    LOGGER.error('Symlink detected "%s"', path)
                    continue
                elif path.is_dir():
                    has_subdirs = True
                    continue
                set_permissions(path)
                if path.suffix in AUDIO_EXT:
                    with taglib.File(str(path)) as song:
                        metadata = {k.lower(): v for k, v in song.tags.items()}
                    check_metadata(path, metadata)
                    fix_metadata(path, metadata, args.dry_run)
                    fix_tracknumber(path, metadata, args.dry_run)
                    rename_from_tags(path, metadata, args.dry_run)
                    try:
                        albums.add(metadata["album"][0])
                    except KeyError:
                        missing_album = True
                    try:
                        artists.update(metadata["artist"])
                    except KeyError:
                        missing_artist = True
                    try:
                        artists.update(metadata["albumartist"])
                        albumartists.update(metadata["albumartist"])
                    except KeyError:
                        pass
                    tracks.append(path)

            if len(albums) > 1:
                LOGGER.error(f'Multiple album tags in "{root_path}"')
            elif albums:
                album = list(albums)[0]
                expected_album = folder_name(album)
                if not expected_album:
                    LOGGER.error('invalid album name "%s"', root_path)
                    raise RuntimeError("figure out what to do")

                # Check if album is in correct artist folder (only if --organize-dirs was specified)
                if args.organize_dirs:
                    if len(albumartists) == 1:
                        albumartist = list(albumartists)[0]
                        expected_artist = folder_name(albumartist)
                        if (
                            expected_artist
                            and root_path.parent.name != expected_artist
                        ):
                            # Album is in wrong artist folder, need to move it
                            correct_artist_dir = (
                                args.organize_dirs / expected_artist
                            )
                            correct_album_path = (
                                correct_artist_dir / expected_album
                            )

                            if correct_album_path.exists():
                                LOGGER.error(
                                    'cannot move album "%s" to "%s": target already exists',
                                    root_path,
                                    correct_album_path,
                                )
                            else:
                                # Special case: if root_path is the directory being scanned,
                                # move just the files instead of the directory
                                if root_path == args.directory.absolute():
                                    LOGGER.info(
                                        'moving files from "%s" to "%s"',
                                        root_path,
                                        correct_album_path,
                                    )
                                    if not args.dry_run:
                                        correct_artist_dir.mkdir(exist_ok=True)
                                        correct_album_path.mkdir(exist_ok=True)
                                        for path in root_path.iterdir():
                                            if path.is_file():
                                                path.replace(
                                                    correct_album_path
                                                    / path.name
                                                )
                                        root_path = correct_album_path
                                else:
                                    LOGGER.info(
                                        'moving album from "%s" to "%s"',
                                        root_path,
                                        correct_album_path,
                                    )
                                    if not args.dry_run:
                                        correct_artist_dir.mkdir(exist_ok=True)
                                        root_path.replace(correct_album_path)
                                        root_path = correct_album_path
                        elif root_path.name != expected_album:
                            # Album is in correct artist folder but has wrong name
                            LOGGER.info(
                                'renaming album folder from "%s" to "%s"',
                                root_path,
                                expected_album,
                            )
                            new_root = root_path.with_name(expected_album)
                            if new_root.exists():
                                LOGGER.error(
                                    'new root already exists "%s"', new_root
                                )
                                continue
                            else:
                                if not args.dry_run:
                                    root_path.replace(new_root)
                                    root_path = new_root
                    else:
                        # No albumartist or multiple albumartists, just rename if needed
                        if root_path.name != expected_album:
                            LOGGER.info(
                                'renaming album folder from "%s" to "%s"',
                                root_path,
                                expected_album,
                            )
                            new_root = root_path.with_name(expected_album)
                            if new_root.exists():
                                LOGGER.error(
                                    'new root already exists "%s"', new_root
                                )
                                continue
                            else:
                                if not args.dry_run:
                                    root_path.replace(new_root)
                                    root_path = new_root

            if len(albumartists) > 1:
                LOGGER.error(f'Multiple albumartists in "{root_path}"')
            elif (
                not missing_artist
                and not missing_album
                and not albumartists
                and len(artists) == len(albums) == 1
            ):
                artist = list(artists)[0]
                for path in tracks:
                    LOGGER.info(
                        'Setting albumartist to "%s" (%s)', artist, path
                    )
                    if not args.dry_run:
                        with taglib.File(str(path), save_on_exit=True) as song:
                            song.tags["ALBUMARTIST"] = [artist]

            if len(albumartists) == 1 and args.library:
                relative_root = root_path.relative_to(LIBRARY)
                expected_root = LIBRARY.joinpath(
                    folder_name(list(albumartists)[0]),
                    *relative_root.parts[1:],
                )
                if expected_root != root_path:
                    LOGGER.error(
                        'top-level should be "%s" for "%s"',
                        expected_root.relative_to(LIBRARY),
                        relative_root,
                    )

    # audit artist title variations
    artist_variants = collections.defaultdict(set)

    valid_chars = string.ascii_lowercase + string.digits

    for artist in artists:
        normalized = "".join([c for c in artist.lower() if c in valid_chars])
        if normalized:
            artist_variants[normalized].add(artist)

    for normalized, variants in artist_variants.items():
        if len(variants) > 1:
            LOGGER.error("artist variants: %s - %s", normalized, variants)


if __name__ == "__main__":
    main()
