#!/usr/bin/env python3
import argparse
import os
import pathlib
import subprocess

import chardet
import mutagen.flac
import mutagen.mp3

AUDIO_EXT = ('.flac', '.mp3')
FLAC_EXT = '.flac'

IMAGE_EXT = ('.jpg', '.png')
IMAGE_PREFIX = 'cover'

CUE_EXT = ('.cue')

RENAME_MAP = {'.jpeg': '.jpg'}

EXPECTED_TAGS = (
    'albumartist',
    'album',
    'artist',
    'date',
    'genre',
    'tracknumber'
)


MUTAGEN_CLASS = {
    '.flac': mutagen.flac.FLAC,
    '.mp3': mutagen.mp3.EasyMP3
}


def cue_track_count(path):
    try:
        with open(path) as f:
            lines = f.readlines()
    except UnicodeDecodeError:
        detector = chardet.UniversalDetector()
        with open(path, 'rb') as f:
            data = f.read()
            detector.feed(data)
        detector.close()
        lines = data.decode(detector.result['encoding']).split('\n')
        with open(path, 'w') as f:
            f.write('\n'.join(lines))
    return len([l for l in lines if l.strip().startswith('TRACK ')])


def split_flac(flac_path, cue_path):
    print(f'Splitting {flac_path}')
    subprocess.run(
        ['shntool', 'split', '-f', cue_path.name, '-o',
         'flac flac --output-name=split%f -', '-t', '%n', flac_path.name],
        cwd=cue_path.parent,
        stderr=subprocess.DEVNULL,
        check=True
    )
    flac_path.unlink()


def check_cue_files(root_path):
    paths = [p for p in root_path.iterdir() if p.is_file()]
    flac_files = [p for p in paths if p.suffix == FLAC_EXT]
    if not flac_files:
        return

    cue_files = [p for p in paths if p.suffix in CUE_EXT]

    if len(cue_files) > 1:
        print(f'Multiple .cue files: {root_path}')
    elif len(cue_files) == len(flac_files) == 1:
        cue_file = cue_files[0]
        num_tracks = cue_track_count(cue_file)
        if num_tracks == 0:
            print(f'Bad cue file: {cue_file}')
        elif num_tracks != 1:
            split_flac(flac_files[0], cue_file)


def organize_images(root_path):
    paths = [p for p in root_path.iterdir() if p.is_file()]
    audio_files = [p for p in paths if p.suffix in AUDIO_EXT]
    if not audio_files:
        return

    images = [p for p in paths if p.suffix in IMAGE_EXT]
    if len(images) == 1:
        image = images[0]
        image.rename(
            pathlib.Path(image.parent, IMAGE_PREFIX + image.suffix)
        )
    elif len(images) > 1:
        print(f'Multiple images: {root_path}')
    else:
        print(f'No images: {root_path}')


def check_metadata(path, metadata):
    for tag in EXPECTED_TAGS:
        try:
            metadata[tag]
        except KeyError:
            print(f'File {path} missing "{tag}"')


def fix_tracknumber(path, metadata):
    tracknumber = metadata['tracknumber'][0]

    if '/' in tracknumber:
        tracknumber, all_tracks = tracknumber.split('/')

        try:
            int(tracknumber)
        except ValueError:
            print(f'Unhandled tracknumber: "{tracknumber}"')

        metadata['tracknumber'] = tracknumber
        print(f'Fixing track number: "{path}"')
        metadata.save()


def rename_extensions(path):
    for f in {p for p in path.iterdir() if p.is_file()}:
        suffix = f.suffix.lower()
        suffix = RENAME_MAP.get(suffix, suffix)
        safe_rename(f, f.stem + suffix)


def rename_from_tags(path, metadata):
    title = metadata['title'][0]
    try:
        tracknumber = int(metadata['tracknumber'][0])
    except ValueError:
        print(f'Cannot rename "{path}"')
        return
    # Only modify when under 10 to retain tracks >= 100
    if tracknumber < 10:
        tracknumber = f'{tracknumber:02d}'

    for char in ('/', '.'):
        title = title.replace(char, ' ')
    title = ' '.join(title.split())
    safe_rename(path, f'{tracknumber} - {title}{path.suffix}')


def safe_rename(source, name):
    target = source.with_name(name)
    if source != target:
        if target.exists():
            print(f'Error renaming "{source}" to "{target}": already exists')
        else:
            print(f'Renaming "{source}" to "{target}"')
            source.rename(target)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('directory')
    parser.add_argument('-t', '--check-tags', action='store_const', const=True)
    args = parser.parse_args()

    music_dir = pathlib.Path(args.directory)

    for root, dirs, files in os.walk(music_dir):
        root_path = pathlib.Path(root)

        rename_extensions(root_path)
        organize_images(root_path)
        check_cue_files(root_path)

        if args.check_tags:
            albums = set()

            for path in {p for p in root_path.iterdir() if p.is_file()}:
                mutagen_class = MUTAGEN_CLASS.get(path.suffix)
                if mutagen_class:
                    metadata = mutagen_class(path)
                    check_metadata(path, metadata)
                    fix_tracknumber(path, metadata)
                    rename_from_tags(path, metadata)
                    albums.add(metadata['album'][0])

            if len(albums) > 1:
                print(f'Multiple album tags in "{root_path}"')


if __name__ == '__main__':
    main()
