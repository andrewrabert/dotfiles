#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "pytaglib",
# ]
# ///
"""Dump and restore music tags to/from JSON file."""

import argparse
import importlib.metadata
import json
import pathlib
import sys

import taglib

AUDIO_EXT = {
    ".aac",
    ".ape",
    ".flac",
    ".m4a",
    ".mp3",
    ".ogg",
    ".opus",
    ".wav",
    ".wma",
}

TAG_PRIORITY = [
    "title",
    "tracknumber",
    "artist",
    "album",
    "genre",
    "albumartist",
]


def sort_tags(tags):
    """Sort tags: priority tags first in order, then remaining alphabetically."""
    priority_set = set(TAG_PRIORITY)
    priority_items = []
    other_items = []
    for key, value in tags.items():
        if key in priority_set:
            priority_items.append((key, value))
        else:
            other_items.append((key, value))
    priority_items.sort(key=lambda x: TAG_PRIORITY.index(x[0]))
    other_items.sort(key=lambda x: x[0])
    return dict(priority_items + other_items)


def get_all_tags(file_path):
    with taglib.File(str(file_path)) as song:
        return {
            k.lower(): v[0] if len(v) == 1 else v for k, v in song.tags.items()
        }


def set_all_tags(file_path, tags):
    normalized_tags = {
        k: [v] if isinstance(v, str) else v for k, v in tags.items()
    }
    with taglib.File(str(file_path), save_on_exit=True) as song:
        song.tags = normalized_tags


def all_files(*roots):
    files = set()
    stack = []
    for path in roots:
        if path.is_file():
            files.add(path)
        else:
            stack.append(path)
    while stack:
        for path in stack.pop().iterdir():
            if path.is_file():
                files.add(path)
            else:
                stack.append(path)
    return files


def is_audio_file(path):
    return path.is_file() and path.suffix.lower() in AUDIO_EXT


def dump_structured_tags(directory, output_file):
    directory_path = pathlib.Path(directory).absolute()

    if not directory_path.exists():
        print(f"Directory does not exist: {directory}", file=sys.stderr)
        sys.exit(1)

    # Group files by parent directory
    dirs = {}
    for path in all_files(directory_path):
        if not is_audio_file(path):
            continue
        parent = str(path.parent.absolute())
        if parent not in dirs:
            dirs[parent] = []
        dirs[parent].append((path, get_all_tags(path)))

    result = {}
    for dir_path, files in sorted(dirs.items()):
        albums = set()
        albumartists = set()
        dates = set()
        genres = set()
        tracknumbers = {}
        tracks = {}

        for path, tags in files:
            if "album" in tags:
                albums.add(tags["album"])
            if "albumartist" in tags:
                albumartists.add(tags["albumartist"])
            if "date" in tags:
                dates.add(tags["date"])
            if "genre" in tags:
                genres.add(tags["genre"])
            if "tracknumber" in tags:
                tracknum = tags["tracknumber"]
                if tracknum in tracknumbers:
                    print(
                        f"Duplicate tracknumber '{tracknum}' in {dir_path}: "
                        f"{tracknumbers[tracknum]} and {path.name}",
                        file=sys.stderr,
                    )
                    sys.exit(1)
                tracknumbers[tracknum] = path.name

            filename = path.name
            if filename in tracks:
                print(
                    f"Duplicate filename '{filename}' in {dir_path}",
                    file=sys.stderr,
                )
                sys.exit(1)
            tracks[filename] = tags

        if len(albums) > 1:
            print(f"Differing albums in {dir_path}: {albums}", file=sys.stderr)
            sys.exit(1)
        if len(albumartists) > 1:
            print(
                f"Differing albumartists in {dir_path}: {albumartists}",
                file=sys.stderr,
            )
            sys.exit(1)
        if len(dates) > 1:
            print(f"Differing dates in {dir_path}: {dates}", file=sys.stderr)
            sys.exit(1)

        album = albums.pop() if albums else None
        albumartist = albumartists.pop() if albumartists else None
        date = dates.pop() if dates else None
        genre = genres.pop() if len(genres) == 1 else None

        dir_entry = {}
        if album:
            dir_entry["album"] = album
        if albumartist:
            dir_entry["albumartist"] = albumartist
        if date:
            dir_entry["date"] = date
        if genre:
            dir_entry["genre"] = genre

        sorted_tracks = {}
        for filename in sorted(
            tracks.keys(),
            key=lambda f: (
                int(tracks[f].get("tracknumber", "0"))
                if tracks[f].get("tracknumber", "").isdigit()
                else float("inf"),
                f,
            ),
        ):
            tags = tracks[filename]
            track_tags = dict(tags)
            # Remove album-level tags from track
            track_tags.pop("album", None)
            track_tags.pop("albumartist", None)
            track_tags.pop("date", None)
            if genre:
                track_tags.pop("genre", None)
            # Remove artist if same as albumartist
            if track_tags.get("artist") == albumartist:
                track_tags.pop("artist", None)
            sorted_tracks[filename] = sort_tags(track_tags)

        dir_entry["tracks"] = sorted_tracks
        result[dir_path + "/"] = dir_entry

    result = dict(sorted(result.items()))

    if output_file:
        with open(output_file, "w", encoding="utf-8") as f:
            json.dump(result, f, indent=2, ensure_ascii=False)
        print(f"\nDumped {len(result)} directories to {output_file}", file=sys.stderr)
    else:
        json.dump(result, sys.stdout, indent=2, ensure_ascii=False)
        print(file=sys.stdout)


def dump_directory_tags(directory, output_file):
    directory_path = pathlib.Path(directory).absolute()

    if not directory_path.exists():
        print(f"Directory does not exist: {directory}", file=sys.stderr)
        sys.exit(1)

    all_tags = {}

    for path in all_files(directory_path):
        if not is_audio_file(path):
            continue
        all_tags[str(path.absolute())] = sort_tags(get_all_tags(path))

    all_tags = dict(sorted(all_tags.items()))

    if output_file:
        with open(output_file, "w", encoding="utf-8") as f:
            json.dump(all_tags, f, indent=2, ensure_ascii=False)
        print(
            f"\nDumped {len(all_tags)} files to {output_file}", file=sys.stderr
        )
    else:
        json.dump(all_tags, sys.stdout, indent=2, ensure_ascii=False)
        print(file=sys.stdout)


def dump_single_file_tags(file_path, output_file):
    file_path = pathlib.Path(file_path).absolute()
    tags = sort_tags(get_all_tags(file_path))

    if output_file:
        with open(output_file, "w", encoding="utf-8") as f:
            json.dump({str(file_path): tags}, f, indent=2, ensure_ascii=False)
        print(
            f"Dumped tags from {file_path} to {output_file}", file=sys.stderr
        )
    else:
        json.dump(
            {str(file_path): tags}, sys.stdout, indent=2, ensure_ascii=False
        )
        print(file=sys.stdout)


def cmd_dump(args):
    path_obj = pathlib.Path(args.path)

    if path_obj.is_dir():
        if args.structured:
            dump_structured_tags(args.path, args.output)
        else:
            dump_directory_tags(args.path, args.output)
    elif path_obj.is_file():
        if args.structured:
            print("Structured mode requires a directory", file=sys.stderr)
            sys.exit(1)
        dump_single_file_tags(args.path, args.output)
    else:
        print(f"Invalid path: {args.path}", file=sys.stderr)
        sys.exit(1)


def normalize_tags(tags):
    return {
        k.upper(): [v] if isinstance(v, str) else v for k, v in tags.items()
    }


def expand_structured_tags(structured):
    """Convert structured format back to flat {filepath: tags} format."""
    flat = {}
    for dir_path, dir_data in structured.items():
        album = dir_data.get("album")
        albumartist = dir_data.get("albumartist")
        date = dir_data.get("date")
        genre = dir_data.get("genre")

        for filename, track_tags in dir_data.get("tracks", {}).items():
            file_path = str(pathlib.Path(dir_path) / filename)
            tags = dict(track_tags)
            if album:
                tags["album"] = album
            if albumartist:
                tags["albumartist"] = albumartist
                # Restore artist if not present (was same as albumartist)
                if "artist" not in tags:
                    tags["artist"] = albumartist
            if date:
                tags["date"] = date
            if genre and "genre" not in tags:
                tags["genre"] = genre
            flat[file_path] = tags
    return flat


def load_input_tags(args):
    if hasattr(args, "all_tags"):
        return args.all_tags
    if args.input:
        with open(args.input, "r", encoding="utf-8") as f:
            return json.load(f)
    return json.load(sys.stdin)


def cmd_restore(args):
    all_tags = load_input_tags(args)

    success_count = 0
    skipped_count = 0

    for file_path, new_tags in all_tags.items():
        if not pathlib.Path(file_path).exists():
            print(f"File not found: {file_path}", file=sys.stderr)
            continue

        current_tags = get_all_tags(file_path)
        new_tags_norm = normalize_tags(new_tags)
        current_tags_norm = normalize_tags(current_tags)

        if new_tags_norm == current_tags_norm:
            skipped_count += 1
            continue

        print(f"Replacing: {file_path}", file=sys.stderr)

        for key in sorted(
            set(new_tags_norm.keys()) | set(current_tags_norm.keys())
        ):
            new_val = new_tags_norm.get(key)
            cur_val = current_tags_norm.get(key)
            if new_val != cur_val:
                print(f"  {key}: {cur_val} -> {new_val}", file=sys.stderr)

        set_all_tags(file_path, new_tags_norm)
        success_count += 1

    print(
        f"\nReplaced {success_count} files, {skipped_count} unchanged",
        file=sys.stderr,
    )


def cmd_merge(args):
    all_tags = load_input_tags(args)

    success_count = 0
    skipped_count = 0

    for file_path, new_tags in all_tags.items():
        if not pathlib.Path(file_path).exists():
            print(f"File not found: {file_path}", file=sys.stderr)
            continue

        current_tags = get_all_tags(file_path)
        current_tags_norm = normalize_tags(current_tags)

        merged_tags = dict(current_tags_norm)
        changes = []

        for key, value in new_tags.items():
            key_upper = key.upper()

            if value is None:
                if key_upper in merged_tags:
                    changes.append(
                        f"  {key_upper}: {merged_tags[key_upper]} -> [deleted]"
                    )
                    del merged_tags[key_upper]
            else:
                new_val = [value] if isinstance(value, str) else value
                cur_val = merged_tags.get(key_upper)

                if new_val != cur_val:
                    changes.append(f"  {key_upper}: {cur_val} -> {new_val}")
                    merged_tags[key_upper] = new_val

        if not changes:
            skipped_count += 1
            continue

        print(f"Merging: {file_path}", file=sys.stderr)
        for change in changes:
            print(change, file=sys.stderr)

        set_all_tags(file_path, merged_tags)
        success_count += 1

    print(
        f"\nMerged {success_count} files, {skipped_count} unchanged",
        file=sys.stderr,
    )


def cmd_set(args):
    success_count = 0
    skipped_count = 0

    tag_updates = {}

    if args.set:
        for tag, value in args.set:
            tag_updates[tag.upper()] = [value]

    if args.delete:
        for tag in args.delete:
            tag_updates[tag.upper()] = None

    if not tag_updates:
        print("No tag changes specified", file=sys.stderr)
        return

    for file_path in args.files:
        if not file_path.exists():
            print(f"File not found: {file_path}", file=sys.stderr)
            continue

        current_tags = get_all_tags(file_path)
        current_tags_norm = normalize_tags(current_tags)

        merged_tags = dict(current_tags_norm)
        changes = []

        for tag, value in tag_updates.items():
            if value is None:
                if tag in merged_tags:
                    changes.append(f"  {tag}: {merged_tags[tag]} -> [deleted]")
                    del merged_tags[tag]
            else:
                cur_val = merged_tags.get(tag)
                if value != cur_val:
                    changes.append(f"  {tag}: {cur_val} -> {value}")
                    merged_tags[tag] = value

        if not changes:
            skipped_count += 1
            continue

        print(f"Setting: {file_path}", file=sys.stderr)
        for change in changes:
            print(change, file=sys.stderr)

        set_all_tags(file_path, merged_tags)
        success_count += 1

    print(
        f"\nSet {success_count} files, {skipped_count} unchanged",
        file=sys.stderr,
    )


def main():
    parser = argparse.ArgumentParser(
        description="Dump and restore music tags to/from JSON"
    )

    parser.add_argument(
        "--version",
        action="version",
        version=f"pytaglib {importlib.metadata.version('pytaglib')}",
    )
    parser.add_argument(
        "-i",
        "--input",
        metavar="FILE",
        help='Input JSON file for replace/merge (use "-" for stdin)',
    )
    parser.add_argument(
        "-o",
        "--output",
        metavar="FILE",
        help="Output JSON file for dump (default: stdout)",
    )
    parser.add_argument(
        "--merge",
        action="store_true",
        help="Merge mode: only update/delete specified tags (requires -i)",
    )
    parser.add_argument(
        "-S",
        "--structured",
        action="store_true",
        help="Structured output: group by directory with album/albumartist at top level",
    )
    parser.add_argument(
        "-s",
        "--set",
        action="append",
        nargs=2,
        metavar=("TAG", "VALUE"),
        help="Set tag to value (can be specified multiple times)",
    )
    parser.add_argument(
        "-d",
        "--delete",
        action="append",
        metavar="TAG",
        help="Delete tag (can be specified multiple times)",
    )
    parser.add_argument(
        "path", nargs="*", help="Music file(s) or directory for dump/set mode"
    )

    args = parser.parse_args()

    if args.set or args.delete:
        if not args.path:
            parser.error("Set mode requires file paths")
        args.files = [pathlib.Path(p) for p in args.path]
        cmd_set(args)
    elif args.input:
        if args.input == "-":
            args.input = None
        if args.structured:
            # Load and expand structured format to flat format
            if args.input:
                with open(args.input, "r", encoding="utf-8") as f:
                    structured = json.load(f)
            else:
                structured = json.load(sys.stdin)
            args.all_tags = expand_structured_tags(structured)
        if args.merge:
            cmd_merge(args)
        else:
            cmd_restore(args)
    else:
        if not args.path:
            parser.error("Dump mode requires a path")
        if len(args.path) > 1:
            parser.error("Dump mode accepts only one path")
        args.path = args.path[0]
        cmd_dump(args)


if __name__ == "__main__":
    main()
