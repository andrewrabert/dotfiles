#!/usr/bin/env python3
import argparse
import os
import pathlib
import re
import sys

TITLES_FILE = 'source'
DEFAULT_PATTERN = r'.*S\d*E(\d*).*.mkv'


def get_titles(path):
    with open(path) as f:
        return {
            number: line.strip().replace('/', '-')
            for number, line in enumerate(f, 1)
        }


def get_new_path(path, pattern, titles):
    if path.name.endswith('.mkv'):
        matches = pattern.match(path.name)
        try:
            number = int(matches.group(1))
        except AttributeError:
            print('Unable to match in file', path)
            sys.exit(1)
        return pathlib.Path(
            path.parent, f'{number:02d} - {titles[number]}.mkv'
        )


def process(path, regex):
    pattern = re.compile(regex)
    for root, dirs, files in os.walk(path):
        try:
            titles_path = pathlib.Path(root, TITLES_FILE)
            titles = get_titles(pathlib.Path(root, TITLES_FILE))
        except FileNotFoundError:
            continue

        paths = {}
        for path in (pathlib.Path(root, f) for f in sorted(files)):
            new_path = get_new_path(path, pattern, titles)
            if new_path:
                if new_path.exists():
                    print('File already exists', new_path)
                    sys.exit(1)
                print(path.name, '\n', new_path.name, '\n', sep='')
                paths[path] = new_path

        should_rename = input('Should rename? (y/N)  ')
        if should_rename.lower() == 'y':
            for old_path, new_path in paths.items():
                old_path.rename(new_path)

            titles_path.unlink()


def main():
    parser = argparse.ArgumentParser()
    parser.description = f"{parser.prog} directory {DEFAULT_PATTERN}"
    parser.add_argument('directory')
    parser.add_argument('-r', '--regex', default=DEFAULT_PATTERN)
    args = parser.parse_args()

    pattern = f'^{args.regex}$'
    process(args.directory, pattern)


if __name__ == '__main__':
    main()
