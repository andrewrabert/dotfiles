#!/usr/bin/env python3
import argparse
import concurrent.futures
import contextlib
import logging
import pathlib
import subprocess
import tempfile

import mutagen

LOGGER = logging.getLogger('reencode-lossless')


def copy_tags(source, target):
    metadata_source = mutagen.File(source)
    metadata_target = mutagen.File(target)
    for key, value in metadata_source.items():
        if isinstance(value, mutagen.apev2.APETextValue):
            value = str(value)
        metadata_target[key] = value
    metadata_target.save()


@contextlib.contextmanager
def decode_ape_to_stdout(path):
    """Decode a FLAC file to stdout

    Decodes through any errors.

    :param pathlib.Path path: The FLAC file path
    """
    process = subprocess.Popen(
        ['mac', path, '-', '-d'],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    yield process.stdout
    process.wait()
    # Decode errors may are non-fatal, but may indicate a problem
    stderr = process.stderr.read()
    if process.returncode:
        raise subprocess.CalledProcessError(
            process.returncode,
            process.args,
            stderr=stderr
        )


@contextlib.contextmanager
def pipe_wave_to_stdout(path):
    process = subprocess.Popen(
        ['cat', path],
        stdout=subprocess.PIPE
    )
    yield process.stdout


@contextlib.contextmanager
def decode_flac(path):
    """Decode a FLAC file

    Decodes through any errors.

    :param pathlib.Path path: The FLAC file path
    """
    process = subprocess.Popen(
        ['flac', '-csd', path],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    yield process.stdout
    process.wait()
    # Decode errors may are non-fatal, but may indicate a problem
    stderr = process.stderr.read()
    if process.returncode:
        raise subprocess.CalledProcessError(
            process.returncode,
            process.args,
            stderr=stderr
        )
    if stderr:
        LOGGER.warning('Decode "%s" "%s"', path, stderr)


@contextlib.contextmanager
def TempPath(**kwargs):
    """Wrapper around tempfile.NamedTemporaryFile which returns a path object

    Unlike tempfile.NamedTemporaryFile, the FileNotFoundError exception is not
    raised if the file is deleted before the context closes.

    :rtype: pathlib.Path
    """
    with tempfile.NamedTemporaryFile(**kwargs, delete=False) as tmp:
        temp_path = pathlib.Path(tmp.name)
        try:
            yield temp_path
        finally:
            try:
                temp_path.unlink()
            except FileNotFoundError:
                pass


def reencode(source):
    LOGGER.info('Processing %s', source)

    suffix = source.suffix.lower()

    decode_contexts = {
        '.flac': decode_flac,
        '.ape': decode_ape_to_stdout,
        '.wav': pipe_wave_to_stdout
    }

    with decode_contexts[suffix](source) as decode:
        with TempPath(dir=source.parent, suffix='.flac') as tmp:
            encode = subprocess.Popen(
                ['flac', '-s', '--best', '-V', '-f', '-o', tmp, '-'],
                stdin=decode,
                stdout=subprocess.DEVNULL
            )
            encode.wait()
            if encode.returncode:
                raise subprocess.CalledProcessError(
                    encode.returncode, encode.args)
            copy_tags(source, tmp)
            source.unlink()
            tmp.rename(source.with_suffix('.flac'))


def all_files(root):
    files = []
    stack = [root]
    while stack:
        for path in stack.pop().iterdir():
            if path.is_file():
                files.append(path)
            elif path.is_dir():
                stack.append(path)
    return files


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('path', type=pathlib.Path, nargs='+')
    args = parser.parse_args()

    logging.basicConfig(
        format='%(levelname)s %(message)s',
        level=logging.INFO)

    paths = set()
    for path in args.path:
        if path.is_dir():
            paths.update(all_files(path))
        else:
            paths.add(path)

    with concurrent.futures.ProcessPoolExecutor() as pool:
        future_to_path = {
            pool.submit(reencode, path): path
            for path in sorted(paths)
            if path.suffix.lower() in ('.flac', '.ape', '.wav')
        }
        errors = []
        for future in concurrent.futures.as_completed(future_to_path):
            try:
                future.result()
            except Exception as e:
                LOGGER.exception(e)
                errors.append(future_to_path[future])

    for path in sorted(errors):
        LOGGER.error('Error %s', path)


if __name__ == '__main__':
    main()
