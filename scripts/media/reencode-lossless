#!/usr/bin/env python3
import argparse
import asyncio
import contextlib
import logging
import os
import pathlib
import tempfile

import mutagen

LOGGER = logging.getLogger('reencode-lossless')


def copy_tags(source, target):
    metadata_source = mutagen.File(source)
    metadata_target = mutagen.File(target)
    for key, value in metadata_source.items():
        if isinstance(value, mutagen.apev2.APETextValue):
            value = str(value)
        metadata_target[key] = value
    metadata_target.save()


async def decode_ape(source, fd):
    proc = await asyncio.create_subprocess_exec(
        'mac', source, '-', '-d',
        stdout=fd)
    return proc.wait()


async def decode_wv(source, fd):
    proc = await asyncio.create_subprocess_exec(
        'wvunpack', '-d', source, '-', '-d',
        stdout=fd)
    return proc.wait()


async def decode_flac(source, fd):
    proc = await asyncio.create_subprocess_exec(
        'flac', '-csd', source,
        stdout=fd)
    return proc.wait()


async def decode_wav(source, fd):
    proc = await asyncio.create_subprocess_exec(
        'cat', source,
        stdout=fd)
    return proc.wait()


@contextlib.contextmanager
def TempPath(**kwargs):
    """Wrapper around tempfile.NamedTemporaryFile which returns a path object

    Unlike tempfile.NamedTemporaryFile, the FileNotFoundError exception is not
    raised if the file is deleted before the context closes.

    :rtype: pathlib.Path
    """
    with tempfile.NamedTemporaryFile(**kwargs, delete=False) as tmp:
        temp_path = pathlib.Path(tmp.name)
        try:
            yield temp_path
        finally:
            try:
                temp_path.unlink()
            except FileNotFoundError:
                pass


async def encode_flac(fd, dest):
    proc = await asyncio.create_subprocess_exec(
        'flac', '-s', '--best', '-V', '-f', '-o', dest, '-',
        stdin=fd)
    return proc.wait()


async def reencode(source):
    LOGGER.info('Processing %s', source)

    suffix = source.suffix.lower()

    decode_contexts = {
        '.flac': decode_flac,
        '.ape': decode_ape,
        '.wv': decode_wv,
        '.wav': decode_wav
    }

    read, write = os.pipe()
    decode = await decode_contexts[suffix](source, write)
    os.close(write)
    with TempPath(dir=source.parent, suffix='.flac') as tmp:
        encode = await encode_flac(read, tmp)
        os.close(read)
        try:
            copy_tags(source, tmp)
        except Exception:
            pass
        source.unlink()
        tmp.rename(source.with_suffix('.flac'))
        await encode
        await decode


def all_files(root):
    files = []
    stack = [root]
    while stack:
        for path in stack.pop().iterdir():
            if path.is_file():
                files.append(path)
            elif path.is_dir():
                stack.append(path)
    return files


async def run(paths, max_procs=None):
    if max_procs is None:
        max_procs = os.cpu_count()

    paths = [
        path
        for path in paths
        if path.suffix.lower() in ('.flac', '.ape', '.wav', '.wv')
    ]

    pending = set()
    while paths or pending:
        for i in range(max_procs):
            if not paths:
                break
            pending.add(asyncio.create_task(reencode(paths.pop())))

        _, pending = await asyncio.wait(
            pending, return_when=asyncio.FIRST_COMPLETED)

    errors = []

    for path in sorted(errors):
        LOGGER.error('Error %s', path)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('path', type=pathlib.Path, nargs='+')
    args = parser.parse_args()

    logging.basicConfig(
        format='%(levelname)s %(message)s',
        level=logging.INFO)

    paths = set()
    for path in args.path:
        if path.is_dir():
            paths.update(all_files(path))
        else:
            paths.add(path)

    asyncio.run(run(paths))


if __name__ == '__main__':
    main()
