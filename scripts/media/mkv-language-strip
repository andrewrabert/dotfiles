#!/usr/bin/env python3
import argparse
import contextlib
import pathlib
import shlex
import shutil
import subprocess
import sys
import tempfile

import enzyme


DEFAULT_LANGUAGES = {'eng', 'und'}


class MKVFile:
    def __init__(self, path):
        self.path = path
        with self.path.open('rb') as handle:
            self.metadata = enzyme.MKV(handle)

    @property
    def languages(self):
        languages = set()

        for track in self.metadata.audio_tracks:
            languages.add(track.language)

        for track in self.metadata.subtitle_tracks:
            languages.add(track.language)

        return languages

    def matching_audio_tracks(self, languages):
        return self._matching_tracks(self.metadata.audio_tracks, languages)

    def matching_subtitle_tracks(self, languages):
        return self._matching_tracks(self.metadata.subtitle_tracks, languages)

    def _matching_tracks(self, metadata_tracks, languages):
        tracks = []
        for track in metadata_tracks:
            if track.language in languages:
                tracks.append(track.number - 1)
        return tracks

    @staticmethod
    def track_string(track_type, track_list):
        track_command = []
        if track_list:
            track_command += ['--' + track_type + '-tracks']
            invalid_tracks = "!"

            first_track = True
            for track in track_list:
                if first_track:
                    first_track = False
                else:
                    invalid_tracks += ','

                invalid_tracks += str(track)
            track_command += [invalid_tracks]

        return track_command

    def build_mkvmerge_command(self, target, audio=[], subtitle=[]):
        return [
            'mkvmerge', '-o', target,
            *self.track_string('audio', audio),
            *self.track_string('subtitle', subtitle),
            self.path
        ]

    def remove_tracks(self, target, audio=[], subtitle=[]):
        target.parent.mkdir(parents=True, exist_ok=True)
        if target.exists():
            print(f'error: already exists "{target}"', file=sys.stderr)
            sys.exit(1)

        with TempPath(dir=target.parent) as temp:
            subprocess.run(
                self.build_mkvmerge_command(temp, audio, subtitle),
                stdout=subprocess.DEVNULL,
                check=True
            )
            temp.rename(target)


def delete_if_exists(path):
    """Delete a file or directory if it exists
    :param pathlib.Path path:
    """
    try:
        if path.is_file():
            path.unlink()
        else:
            shutil.rmtree(path)
    except FileNotFoundError:
        pass


@contextlib.contextmanager
def TempPath(**kwargs):
    """Wrapper around tempfile.NamedTemporaryFile which returns a path object
    Unlike tempfile.NamedTemporaryFile, the FileNotFoundError exception is not
    raised if the file is deleted before the context closes.
    :rtype: pathlib.Path
    """
    with tempfile.NamedTemporaryFile(**kwargs, delete=False) as tmp:
        temp_path = pathlib.Path(tmp.name)
        try:
            yield temp_path
        except Exception:
            delete_if_exists(temp_path)
            raise
    delete_if_exists(temp_path)


def mkv_files(root):
    files = []
    stack = [root]
    while stack:
        for path in stack.pop().iterdir():
            if path.is_file() and path.suffix.lower() == '.mkv':
                files.append(path)
            elif path.is_dir():
                stack.append(path)
    return sorted(files)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('input_directory', type=pathlib.Path, nargs='?')
    parser.add_argument('output_directory', type=pathlib.Path, nargs='?')
    parser.add_argument(
        '-k',
        '--keep',
        action='append',
        help='Language to keep',
    )
    parser.add_argument(
        '-i',
        '--info',
        action='store_const',
        const=True,
        help='Show track language information'
    )
    parser.add_argument(
        '-d',
        '--dryrun',
        action='store_const',
        const=True
    )
    args = parser.parse_args()
    input_directory = args.input_directory.absolute()

    if args.info:
        for path in mkv_files(input_directory):
            mkv = MKVFile(path)
            print(path.relative_to(input_directory), mkv.languages)
    else:
        output_directory = args.output_directory.absolute()

        valid_languages = set(args.keep) if args.keep else DEFAULT_LANGUAGES
        if 'und' in valid_languages:
            valid_languages.add(None)

        for path in mkv_files(input_directory):
            print(path)
            mkv = MKVFile(path)
            invalid_languages = mkv.languages - valid_languages
            target = output_directory / path.relative_to(input_directory)
            audio = mkv.matching_audio_tracks(invalid_languages)
            subtitle = mkv.matching_subtitle_tracks(invalid_languages)

            if args.dryrun:
                parts = mkv.build_mkvmerge_command(
                    target, audio=audio, subtitle=subtitle
                )
                print(' '.join(shlex.quote(str(part)) for part in parts))
            else:
                mkv.remove_tracks(target, audio=audio, subtitle=subtitle)


if __name__ == '__main__':
    main()
