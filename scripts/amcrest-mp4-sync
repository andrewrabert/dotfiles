#!/usr/bin/env python3
import argparse
import asyncio
import datetime
import io
import pathlib
import tempfile

import httpx
import yarl


class Amcrest:
    PAGE_SIZE = 100

    def __init__(self, host, port, username, password, /, scheme='http'):
        self._http = httpx.AsyncClient(
            auth=httpx.DigestAuth(username, password))
        self._url = yarl.URL(f'{scheme}://{host}:{port}')

    async def all_files(self):
        factory_id = await self._factory_create()

        # start the search
        start_time = datetime.datetime(year=2000, month=1, day=1)
        end_time = datetime.datetime.now()
        url = (self._url / 'cgi-bin/mediaFileFind.cgi').with_query({
            'action': 'findFile',
            'object': factory_id,
            'condition.Channel': '1',
        })
        # yarl breaks on the space in strftime
        url = '{}&condition.StartTime={}&condition.EndTime={}'.format(
            str(url),
            start_time.strftime('%Y-%m-%d %H:%M:%S'),
            end_time.strftime('%Y-%m-%d %H:%M:%S'),
        )
        response = await self._http.get(url)
        # HTTP 400 seems to happen when no finds are found
        if response.status_code != 400:
            response.raise_for_status()

        # iterate over files
        url = (self._url / 'cgi-bin/mediaFileFind.cgi').with_query({
            'action': 'findNextFile',
            'object': factory_id,
            'count': str(self.PAGE_SIZE),
        })
        file_names = []
        while True:
            response = await self._http.get(str(url))
            response.raise_for_status()

            page_file_names = []
            for line in response.text.splitlines():
                if not line.startswith('items['):
                    continue
                _, line = line.split('.', maxsplit=1)
                if not line.startswith('FilePath='):
                    continue
                file_name = line.removeprefix('FilePath=')
                page_file_names.append(file_name)
            file_names.extend(page_file_names)
            if len(page_file_names) != self.PAGE_SIZE:
                break

        await self._factory_close(factory_id)
        await self._factory_destory(factory_id)
        return sorted(set(file_names))

    async def _factory_create(self):
        url = (self._url / 'cgi-bin/mediaFileFind.cgi').with_query({
            'action': 'factory.create',
        })
        response = await self._http.get(str(url))
        response.raise_for_status()
        name, factory_id = response.text.strip().split('=', maxsplit=1)
        if name != 'result':
            raise RuntimeError
        return factory_id

    async def _factory_close(self, factory_id):
        url = (self._url / 'cgi-bin/mediaFileFind.cgi').with_query({
            'action': 'close',
            'object': factory_id,
        })
        response = await self._http.get(str(url))
        response.raise_for_status()

    async def _factory_destory(self, factory_id):
        url = (self._url / 'cgi-bin/mediaFileFind.cgi').with_query({
            'action': 'destroy',
            'object': factory_id,
        })
        response = await self._http.get(str(url))
        response.raise_for_status()

    async def download_file(self, path):
        url = str(self._url / 'cgi-bin/RPC_Loadfile') + path
        response = await self._http.get(url)
        response.raise_for_status()
        return response.content

    async def get_storage_devices(self):
        url = (self._url / 'cgi-bin/storageDevice.cgi').with_query({
            'action': 'getDeviceAllInfo',
        })
        response = await self._http.get(str(url))
        response.raise_for_status()
        devices = {}
        for line in response.text.splitlines():
            if not line.startswith('list.info['):
                raise RuntimeError
            line = line.removeprefix('list.info[')
            index, parts = line.split('].', maxsplit=1)
            devices.setdefault(index, {})
            key, value = parts.split('=', maxsplit=1)
            devices[index][key] = value
        return devices

    async def format_storage_device(self, pointer):
        url = (self._url / 'cgi-bin/storageDevice.cgi').with_query({
            'action': 'setDevice',
            'pointer': str(pointer),
            'type': 'FormatPatition',
        })
        response = await self._http.get(str(url), timeout=120)
        response.raise_for_status()


def all_files(root):
    paths = []
    stack = [root]
    while stack:
        for path in stack.pop().iterdir():
            if path.is_dir():
                stack.append(path)
            else:
                paths.append(path)
    return set(paths)


def safe_write(path, data):
    path = pathlib.Path(path)
    if isinstance(data, str):
        data = data.encode()
    with tempfile.NamedTemporaryFile(delete=False, dir=path.parent) as handle:
        temp_path = pathlib.Path(handle.name)
        try:
            temp_path.write_bytes(data)
            temp_path.rename(path)
        finally:
            try:
                temp_path.unlink()
            except FileNotFoundError:
                pass


async def _download_new(camera, dest):
    existing_files = all_files(dest)
    existing_names = {p.name for p in existing_files}

    downloaded_new_file = False
    for remote_path in await camera.all_files():
        if not remote_path.endswith('.mp4'):
            continue
        local_name = remote_path.removeprefix('/mnt/sd/').replace('/', '_')
        if local_name in existing_names:
            continue
        print(f'Downloading {remote_path}...')
        handle = io.BytesIO()
        handle.write(await camera.download_file(remote_path))
        handle.seek(0)
        safe_write(dest / local_name, handle.read())
        downloaded_new_file = True
    return downloaded_new_file


async def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--username', required=True)
    parser.add_argument('--password', required=True)
    parser.add_argument('--port', type=int, default=80)
    parser.add_argument('--host', required=True)
    parser.add_argument('--dest', type=pathlib.Path, required=True)
    args = parser.parse_args()

    dest = args.dest
    dest.mkdir(exist_ok=True, parents=True)

    camera = Amcrest(args.host, args.port, args.username, args.password)

    devices = await camera.get_storage_devices()
    if len(devices) != 1:
        raise RuntimeError
    storage_id = list(devices.keys())[0]
    storage_pointer = devices[storage_id]['Pointer']

    downloaded_new_file = await _download_new(camera, dest)

    if downloaded_new_file:
        while downloaded_new_file:
            downloaded_new_file = await _download_new(camera, dest)

        print('Formatting storage')
        await camera.format_storage_device(storage_pointer)


if __name__ == '__main__':
    asyncio.run(main())
