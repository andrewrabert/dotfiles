#!/usr/bin/env python3
import argparse
import collections
import itertools
import logging
import os
import pathlib
import subprocess
import urllib3

import consumers
import requests
import requests.auth
import requests.utils


GITHUB_USERNAME = os.environ.get('GITHUB_USERNAME')
GITHUB_TOKEN = os.environ.get('GITHUB_TOKEN')
GITHUB_URL = os.environ.get(
    'GITHUB_URL', 'https://api.github.com/users/{}/repos')

GITLAB_TOKEN = os.environ.get('GITLAB_TOKEN')
GITLAB_URL = os.environ.get(
    'GITLAB_URL', 'https://gitlab.com/api/v4/users/{}/projects')

SSL_VERIFY = False if os.environ.get('SSL_VERIFY') == 'N' else True
if not SSL_VERIFY:
    urllib3.disable_warnings()


class RepoError(Exception):
    pass


class GitHub:

    def __init__(self, username, token, url, ssl_verify=True):
        self.username = username
        self.token = token
        self.url = url
        self.ssl_verify = ssl_verify

    def get_repo_names(self, user):
        url = self.url.format(user)
        while url:
            response = requests.get(
                url,
                auth=requests.auth.HTTPBasicAuth(self.username, self.token),
                verify=self.ssl_verify)

            response.raise_for_status()
            for item in response.json():
                yield Repo(
                    item['owner']['login'],
                    item['name'],
                    item['clone_url']
                )

            url = None
            link = response.headers.get('Link')
            if link is not None:
                for v in requests.utils.parse_header_links(link):
                    if v['rel'] == 'next':
                        url = v['url']


class GitLab:

    def __init__(self, token, url, ssl_verify=True):
        self.token = token
        self.url = url
        self.ssl_verify = ssl_verify

    def get_repo_names(self, user):
        url = self.url.format(user)
        headers = {'Private-Token': self.token}
        params = {'page': 1,
                  'per_page': 100}

        first_time = True
        repos = []
        while url:
            if first_time:
                response = requests.get(
                    url,
                    headers=headers,
                    params=params,
                    verify=self.ssl_verify)
            else:
                response = requests.get(
                    url,
                    headers=headers,
                    verify=self.ssl_verify)
            repos.extend(response.json())
            url = None
            links = requests.utils.parse_header_links(response.headers['Link'])
            for link in links:
                if link['rel'] == 'next':
                    url = link['url']
            first_time = False

        for repo in repos:
            yield Repo(
                repo['namespace']['full_path'],
                repo['path'],
                repo['ssh_url_to_repo']
            )


class Repo:
    def __init__(self, owner, name, url):
        self.username = owner
        self.reponame = name
        self.url = url

        self.name = f'{self.username}/{self.reponame}'

    def __str__(self):
        return self.name


class LocalRepo:
    def __init__(self, path, url):
        self.path = path
        self.url = url
        self.logger = logging.getLogger()

    def backup_from_origin(self):
        if self.path.exists():
            self.pull()
            self.prune()
        else:
            self.clone()

    def pull(self):
        self.git_command(self.path, 'fetch', '--all')
        result = self.git_command(self.path, 'branch', '--all')
        if result.stdout:
            self.git_command(self.path, 'pull')

    def prune(self):
        self.git_command(self.path, 'remote', 'prune', 'origin')

    def clone(self):
        parent_path = self.path.parent
        parent_path.mkdir(parents=True, exist_ok=True)

        self.git_command(parent_path, 'clone', self.url)

    def git_command(self, path, *args):
        try:
            result = subprocess.run(
                ['git', '-C', path, *args],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True)
        except subprocess.CalledProcessError as e:
            self.logger.exception(e)
            raise RepoError
        return result


def download_repos(repos):
    errors = []
    logger = logging.getLogger()

    for local_path, url in repos:
        repo = LocalRepo(local_path, url)
        repo.logger = logger
        logger.info('Backing up %s', repo.path)
        try:
            repo.backup_from_origin()
        except RepoError as e:
            logger.exception(e)
            errors.append(repo.path)

    return errors


def main():
    logging.basicConfig(
        level=logging.INFO,
        format='%(levelname)s %(processName)s %(message)s')

    logging.info('Begin')

    parser = argparse.ArgumentParser(
            description='Clone all the repos belonging to a user.')
    parser.add_argument('-d', '--directory')
    parser.add_argument('users', nargs='+')
    args = parser.parse_args()

    apis = []
    if GITLAB_TOKEN:
        apis.append(GitLab(
            GITLAB_TOKEN, GITLAB_URL, SSL_VERIFY))

    if GITHUB_TOKEN:
        apis.append(GitHub(
            GITHUB_USERNAME, GITHUB_TOKEN, GITHUB_URL, SSL_VERIFY))

    repos = collections.defaultdict(set)
    with consumers.Pool(download_repos) as pool:
        for api in apis:
            for user in args.users:
                for api_repo in api.get_repo_names(user):
                    user_path = pathlib.Path(args.directory, api_repo.username)
                    repos[user_path].add(api_repo.reponame)
                    local_path = pathlib.Path(user_path, api_repo.reponame)
                    pool.put(local_path, api_repo.url)

    for user_path, repos in repos.items():
        for orphan_repo in set(os.listdir(user_path)).difference(repos):
            logging.warning('Orphan found %s', pathlib.Path(user_path,
                                                            orphan_repo))

    for error in itertools.chain(*pool.results):
        logging.error(error)

    logging.info('Done')


if __name__ == '__main__':
    main()
