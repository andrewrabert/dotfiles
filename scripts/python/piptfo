#!/usr/bin/env python3
# Wise man once said "Coding with sickness result in many WTFs when better"

import configparser
import io
import json
import os
import pathlib
import subprocess
import sys
import sysconfig

import pkg_resources

# fix a deficiency in pipenv
# https://github.com/pypa/pipenv/issues/1798
os.environ['PIP_USER'] = '0'

os.environ['PIPENV_IGNORE_VIRTUALENVS'] = '1'

os.environ.setdefault('PIPTFO_LOCAL', '~/.local/share/piptfo')
os.environ.setdefault('PIPTFO_BIN', '~/.local/bin')

PIPTFO_LOCAL = pathlib.Path(os.environ['PIPTFO_LOCAL']).expanduser().resolve()
PIPTFO_BIN = pathlib.Path(os.environ['PIPTFO_BIN']).expanduser().resolve()


def package_files(package):
    virtualenv = pathlib.Path(os.environ['VIRTUAL_ENV'])

    dist = pkg_resources.get_distribution(package)
    files = set()

    site_packages = pathlib.Path(sysconfig.get_path('purelib'))

    egg_link = site_packages.joinpath(f'{dist.project_name}.egg-link')
    if egg_link.exists():
        files.add(egg_link)

    for name in ('RECORD', 'installed-files.txt'):
        if dist.has_metadata(name):
            files.update(
                pathlib.Path(dist.location, line.split(',')[0]).resolve()
                for line in dist.get_metadata_lines(name)
            )

    if dist.has_metadata('entry_points.txt'):
        parser = configparser.ConfigParser()
        parser.read_file(
            io.StringIO(
                '\n'.join(dist.get_metadata_lines('entry_points.txt'))
            )
        )
        if parser.has_section('console_scripts'):
            for name, _ in parser.items('console_scripts'):
                files.add(virtualenv.joinpath('bin', name))



    return files


def _force_link(target, source):
    try:
        target.unlink()
    except FileNotFoundError:
        pass
    target.parent.mkdir(parents=True, exist_ok=True)
    target.symlink_to(source)


def link_package_files():
    piptfo_root = pathlib.Path(os.environ['PIPENV_PIPFILE']).parent

    for path in piptfo_files():
        relative_path = path.relative_to(piptfo_root.joinpath('.venv'))

        target = piptfo_root.joinpath(relative_path)
        _force_link(target, path)

        if pathlib.Path('bin') in relative_path.parents:
            _force_link(PIPTFO_BIN.joinpath(relative_path.relative_to(pathlib.Path('bin'))), path)


def piptfo_files():
    result = subprocess.run(
        ['pipenv', 'run', 'piptfo', 'files'],
        check=True,
        stdout=subprocess.PIPE
    )
    return [
        pathlib.Path(line.strip())
        for line in result.stdout.decode().split('\n')
        if line
    ]


def pipenv_explicitly_installed():
    result = subprocess.run(
        ['piptfo', 'graph', '--json-tree'],
        stdout=subprocess.PIPE
    )
    return [package['package_name'] for package in json.loads(result.stdout)]


def piptfo_list():
    paths = []
    if PIPTFO_LOCAL.exists():
        paths.extend([
            env_path
            for env_path in PIPTFO_LOCAL.iterdir()
        ])
    return sorted(paths)


def piptfo_all(args):
    for path in piptfo_list():
        print(f'Executing piptfo for {path}')
        subprocess.run(
            ['piptfo', '-n', path.name, *args],
            check=True
        )


def main():
    if len(sys.argv) == 1 or sys.argv[1] == '--list':
        for path in piptfo_list():
            print(path.name)
        sys.exit()
    elif sys.argv[1] == '--all':
        piptfo_all(sys.argv[2:])
        sys.exit()

    if 'PIPENV_PIPFILE' in os.environ:
        namespace_pipfile = pathlib.Path(os.environ['PIPENV_PIPFILE']).expanduser().resolve()
    elif sys.argv[1] == '-n':
        sys.argv.pop(1)
        namespace = sys.argv[1]
        sys.argv.pop(1)
        namespace_dir = PIPTFO_LOCAL.joinpath(namespace)
        if not namespace_dir.exists():
            namespace_dir.mkdir(parents=True, exist_ok=True)
        namespace_pipfile = pathlib.Path(namespace_dir, 'Pipfile')
        os.environ['PIPENV_PIPFILE'] = str(namespace_pipfile)

    namespace_pipfile.parent.mkdir(parents=True, exist_ok=True)
    # The file could alternatively be touched, but then pipenv would
    # set the python_version to active version. That's not appropriate
    # for piptfo so let's be generic unless specified otherwise.
    if not namespace_pipfile.is_file():
        with open(namespace_pipfile, 'w') as handle:
            handle.write('[requires]\npython_version = "*"')

    namespace_pipfile.touch()

    namespace = pathlib.Path(namespace_pipfile).parent.name

    os.environ['PIPENV_VENV_IN_PROJECT'] = '1'

    args = sys.argv[1:]

    if args[0] == 'files':
        for package in pipenv_explicitly_installed():
            for script in package_files(package):
                print(script)
    else:
        subprocess.run(['pipenv', *args], check=True)
        if args[0] in ('install', 'update'):
            link_package_files()


if __name__ == '__main__':
    main()
