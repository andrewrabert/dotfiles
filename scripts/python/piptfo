#!/usr/bin/env python3
# Wise man once said "Coding with sickness result in many WTFs when better"

import json
import os
import pathlib
import subprocess
import sys

import pkg_resources

# fix a deficiency in pipenv
# https://github.com/pypa/pipenv/issues/1798
os.environ['PIP_USER'] = '0'

os.environ['PIPENV_IGNORE_VIRTUALENVS'] = '1'

os.environ.setdefault('PIPTFO_LOCAL', '~/.local/share/piptfo')
os.environ.setdefault('PIPTFO_BIN', '~/.local/bin')

PIPTFO_LOCAL = pathlib.Path(os.environ['PIPTFO_LOCAL']).expanduser().resolve()
PIPTFO_BIN = pathlib.Path(os.environ['PIPTFO_BIN']).expanduser().resolve()


def package_files(package):
    dist = pkg_resources.get_distribution(package)
    return [
        pathlib.Path(dist.location, line.split(',')[0]).resolve()
        for line in dist.get_metadata_lines('RECORD')
    ]


def link_package_files():
    root = pathlib.Path(os.environ['PIPENV_PIPFILE']).parent
    venv_root = root.joinpath('.venv')
    for path in piptfo_files():
        target = root.joinpath(path.relative_to(venv_root))
        try:
            target.unlink()
        except FileNotFoundError:
            pass
        target.parent.mkdir(parents=True, exist_ok=True)
        target.symlink_to(path)


def piptfo_files():
    result = subprocess.run(
        ['pipenv', 'run', 'piptfo', 'files'],
        check=True,
        stdout=subprocess.PIPE
    )
    return [
        pathlib.Path(line.strip())
        for line in result.stdout.decode().split('\n')
        if line
    ]


def pipenv_explicitly_installed():
    result = subprocess.run(
        ['piptfo', 'graph', '--json-tree'],
        stdout=subprocess.PIPE
    )
    return [package['package_name'] for package in json.loads(result.stdout)]


def piptfo_list():
    paths = []
    if PIPTFO_LOCAL.exists():
        paths.extend([
            env_path
            for env_path in PIPTFO_LOCAL.iterdir()
        ])
    return sorted(paths)


def piptfo_all(args):
    for path in piptfo_list():
        print(f'Executing piptfo for {path}')
        subprocess.run(
            ['piptfo', '-n', path.name, *args],
            check=True
        )


def main():
    if len(sys.argv) == 1 or sys.argv[1] == '--list':
        for path in piptfo_list():
            print(path.name)
        sys.exit()
    elif sys.argv[1] == '--all':
        piptfo_all(sys.argv[2:])
        sys.exit()

    if 'PIPENV_PIPFILE' in os.environ:
        namespace_pipfile = pathlib.Path(os.environ['PIPENV_PIPFILE']).expanduser().resolve()
    elif sys.argv[1] == '-n':
        sys.argv.pop(1)
        namespace = sys.argv[1]
        sys.argv.pop(1)
        namespace_dir = PIPTFO_LOCAL.joinpath(namespace)
        if not namespace_dir.exists():
            namespace_dir.mkdir(parents=True, exist_ok=True)
        namespace_pipfile = pathlib.Path(namespace_dir, 'Pipfile')
        os.environ['PIPENV_PIPFILE'] = str(namespace_pipfile)

    namespace_pipfile.parent.mkdir(parents=True, exist_ok=True)
    namespace_pipfile.touch()

    namespace = pathlib.Path(namespace_pipfile).parent.name

    os.environ['PIPENV_VENV_IN_PROJECT'] = '1'

    args = sys.argv[1:]

    if args[0] == 'files':
        for package in pipenv_explicitly_installed():
            for script in package_files(package):
                print(script)
    else:
        subprocess.run(['pipenv', *args], check=True)
        if args[0] in ('install', 'update'):
            link_package_files()


if __name__ == '__main__':
    main()
