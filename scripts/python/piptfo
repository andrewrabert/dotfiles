#!/usr/bin/env python3
# Wise man once said "Coding with sickness result in many WTFs when better"

import json
import os
import pathlib
import subprocess
import sys

import pkg_resources

# fix a deficiency in pipenv
# https://github.com/pypa/pipenv/issues/1798
os.environ['PIP_USER'] = '0'

os.environ['PIPENV_IGNORE_VIRTUALENVS'] = '1'

os.environ.setdefault('PIPTFO_LOCAL', '~/.local/share/piptfo')
os.environ.setdefault('PIPTFO_BIN', '~/.local/bin')

PIPTFO_LOCAL = pathlib.Path(os.environ['PIPTFO_LOCAL']).expanduser().resolve()
PIPTFO_BIN = pathlib.Path(os.environ['PIPTFO_BIN']).expanduser().resolve()


def package_scripts(package):
    bin_root = pathlib.Path(os.environ['VIRTUAL_ENV'], 'bin').resolve()

    dist = pkg_resources.get_distribution(package)

    scripts = []
    for line in dist.get_metadata_lines('RECORD'):
        path = pathlib.Path(dist.location, line.split(',')[0]).resolve()
        if path.parent == bin_root:
            scripts.append(path)
    return scripts


def piptfo_scripts(namespace):
    result = subprocess.run(
        ['pipenv', 'run', 'piptfo', 'scripts'],
        check=True,
        stdout=subprocess.PIPE
    )
    return [
        pathlib.Path(line.strip())
        for line in result.stdout.decode().split('\n')
        if line
    ]


def pipenv_explicitly_installed():
    result = subprocess.run(
        ['piptfo', 'graph', '--json-tree'],
        stdout=subprocess.PIPE
    )
    return [package['package_name'] for package in json.loads(result.stdout)]


def piptfo_list():
    paths = []
    if PIPTFO_LOCAL.exists():
        paths.extend([
            pipfile_path(env_path)
            for env_path in PIPTFO_LOCAL.iterdir()
        ])
    return paths


def piptfo_all(args):
    for path in piptfo_list():
        print(f'Executing piptfo for {path}')
        subprocess.run(
            ['piptfo', path.name, *args],
            check=True
        )


def pipfile_path(env_path):
    with open(env_path.joinpath('.project')) as handle:
        return pathlib.Path(handle.read(), 'Pipfile').expanduser().resolve()


def main():
    if sys.argv[1] == '--all':
        piptfo_all(sys.argv[2:])
        sys.exit()
    elif sys.argv[1] == '--list':
        for path in piptfo_list():
            print(path)
        sys.exit()

    if 'PIPENV_PIPFILE' in os.environ:
        namespace_pipfile = pathlib.Path(os.environ['PIPENV_PIPFILE']).expanduser().resolve()
    elif sys.argv[1] == '-f':
        sys.argv.pop(1)
        namespace_pipfile = pathlib.Path(sys.argv[1]).expanduser().resolve()
        sys.argv.pop(1)
        os.environ['PIPENV_PIPFILE'] = str(namespace_pipfile)
    elif sys.argv[1] == '-n':
        sys.argv.pop(1)
        namespace = sys.argv[1]
        sys.argv.pop(1)
        namespace_dir = PIPTFO_LOCAL.joinpath(namespace)
        for d in namespace_dir.iterdir():
            if d.is_dir():
                namespace_pipfile = pipfile_path(d)
                os.environ['PIPENV_PIPFILE'] = str(namespace_pipfile)
                break

    namespace = pathlib.Path(namespace_pipfile).parent.name

    os.environ['WORKON_HOME'] = str(PIPTFO_LOCAL.joinpath(namespace))

    args = sys.argv[1:]

    if args[0] == 'scripts':
        for package in pipenv_explicitly_installed():
            for script in package_scripts(package):
                print(script)
    else:
        subprocess.run(['pipenv', *args], check=True)
        if args[0] == 'install':
            for script in piptfo_scripts(namespace):
                target = PIPTFO_BIN.joinpath(script.name)
                print(f'Linking {target} -> {script}')
                try:
                    target.unlink()
                except FileNotFoundError:
                    pass
                target.symlink_to(script)


if __name__ == '__main__':
    main()
