#!/usr/bin/env python3
import json
import os
import pathlib
import subprocess
import sys

import pkg_resources

CONFIG_ROOT = pathlib.Path('~/.config/piptfo').expanduser().resolve()
LOCAL_ROOT = pathlib.Path('~/.local/share/piptfo').expanduser().resolve()
LOCAL_BIN_ROOT = pathlib.Path('~/.local/bin').expanduser().resolve()


def package_scripts(package):
    bin_root = pathlib.Path(os.environ['VIRTUAL_ENV'], 'bin').resolve()

    dist = pkg_resources.get_distribution(package)

    scripts = []
    for line in dist.get_metadata_lines('RECORD'):
        path = pathlib.Path(dist.location, line.split(',')[0]).resolve()
        if path.parent == bin_root:
            scripts.append(path)
    return scripts


def pipenv(args, **kwargs):
    os.environ['WORKON_HOME'] = str(LOCAL_ROOT)

    # fix a deficiency in pipenv
    # https://github.com/pypa/pipenv/issues/1798
    os.environ['PIP_USER'] = '0'

    return subprocess.run(
        ['pipenv', *args],
        check=True,
        **kwargs
    )


def piptfo_scripts(namespace):
    result = pipenv(
        ['run', 'piptfo', namespace, 'scripts'],
        stdout=subprocess.PIPE
    )
    return [
        pathlib.Path(line.strip())
        for line in result.stdout.decode().split('\n')
        if line
    ]


def pipenv_explicitly_installed():
    result = pipenv(['graph', '--json-tree'], stdout=subprocess.PIPE)
    return [package['package_name'] for package in json.loads(result.stdout)]


def main():
    namespace = sys.argv[1]

    namespace_root = CONFIG_ROOT.joinpath(namespace)
    namespace_root.mkdir(parents=True, exist_ok=True)

    namespace_pipfile = namespace_root.joinpath('Pipfile')
    namespace_pipfile.touch()

    os.environ['PIPENV_PIPFILE'] = str(namespace_pipfile)

    if sys.argv[2] == 'scripts':
        for package in pipenv_explicitly_installed():
            for script in package_scripts(package):
                print(script)
    else:
        pipenv(sys.argv[2:])
        if sys.argv[2] == 'install':
            for script in piptfo_scripts(namespace):
                target = LOCAL_BIN_ROOT.joinpath(script.name)
                print(f'Linking {target} -> {script}')
                try:
                    target.unlink()
                except FileNotFoundError:
                    pass
                target.symlink_to(script)


if __name__ == '__main__':
    main()
