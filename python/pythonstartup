#!/usr/bin/env python3
import collections
import concurrent.futures
import contextlib
import glob
import io
import itertools
import json
import os
import pathlib
import pickle
import pprint
import re
import shutil
import subprocess
import sys

import arrow
import jinja2
import psutil
import requests
import tabulate
import yaml
import yarl


def pp(*args, **kwargs):
    if sys.version_info.major >= 3 and sys.version_info.minor >= 8:
        kwargs.setdefault('sort_dicts', True)
        return pprint.pp(*args, **kwargs)
    else:
        return pprint.pprint(*args, **kwargs)


def ppdir(*args, **kwargs):
    return pp(dir(*args, **kwargs))


def walk(root):
    stack = [pathlib.Path(root)]
    paths = []
    while stack:
        for path in stack.pop().iterdir():
            if path.is_dir():
                stack.append(path)
            paths.add(path)
    return sorted(paths)


def paths(pattern=None):
    if pattern is None:
        return sorted(pathlib.Path().iterdir())
    else:
        return sorted(
            pathlib.Path(p)
            for p in glob.glob(str(pathlib.Path(pattern).expanduser()))
        )


def ls(all=False):
    if all:
        pp(paths())
    else:
        pp(paths('*'))


def files(*args, **kwargs):
    return sorted(p for p in paths(*args, **kwargs)
                  if p.is_file())


def dirs(*args, **kwargs):
    return sorted(p for p in paths(*args, **kwargs)
                  if p.is_dir())


def path(pattern):
    matches = list(paths(pattern))
    if len(matches) == 0:
        raise FileNotFoundError
    elif len(matches) != 1:
        raise ValueError
    return matches[0]


def load_json(data):
    if isinstance(data, pathlib.Path):
        data = data.read_text()
    return json.loads(data)


def dump_json(data, path=None):
    def _default_json(obj):
        if isinstance(obj, set):
            return sorted(obj)
        elif hasattr(obj, 'isoformat'):
            return obj.isoformat()
    dumped = json.dumps(
        data,
        indent=2,
        sort_keys=True,
        default=_default_json,
        ensure_ascii=False
    )
    if path is not None:
        path.write_text(dumped)
    else:
        return dumped


def cat(pattern):
    return b''.join(p.read_bytes() for p in paths(pattern))


def cd(pattern='~'):
    os.chdir(path(pattern))
    return pathlib.Path.cwd()


def pwd():
    return pathlib.Path.cwd()


def chunked(iterable, n):
    i = iter(iterable)
    while result := list(itertools.islice(i, n)):
        yield result
