#!/usr/bin/env python3
from concurrent.futures import ProcessPoolExecutor as Pool 
import code
import collections
import contextlib
import datetime
import glob
import io
import json
import os
import pickle
import pprint
import shutil
import subprocess
import sys

try:
    import arrow
except ImportError:
    pass

try:
    import requests
except ImportError:
    pass

try:
    import tabulate
except ImportError:
    pass

try:
    import yaml
except ImportError:
    pass

try:
    import pathlib
except ImportError:
    import pathlib2 as pathlib
    class FileNotFoundError(Exception):
        pass


def pp(*args, **kwargs):
    if sys.version_info.major >= 3 and sys.version_info.minor >= 8:
        kwargs.setdefault('sort_dicts', True)
        return pprint.pp(*args, **kwargs)
    else:
        return pprint.pprint(*args, **kwargs)


def ppdir(*args, **kwargs):
    return pp(dir(*args, **kwargs))


def walk(root):
    stack = [pathlib.Path(root)]
    paths = []
    while stack:
        for path in stack.pop().iterdir():
            if path.is_dir():
                stack.append(path)
            paths.add(path)
    return sorted(paths)


def paths(pattern=None):
    if pattern is None:
        return sorted(pathlib.Path().iterdir())
    else:
        return sorted(
            pathlib.Path(p)
            for p in glob.glob(str(pathlib.Path(pattern).expanduser()))
        )


def ls(all=False):
    if all:
        pp(paths())
    else:
        pp(paths('*'))


def files(*args, **kwargs):
    return sorted(p for p in paths(*args, **kwargs)
                  if p.is_file())


def dirs(*args, **kwargs):
    return sorted(p for p in paths(*args, **kwargs)
                  if p.is_dir())


def path(pattern):
    matches = list(paths(pattern))
    if len(matches) == 0:
        raise FileNotFoundError
    elif len(matches) != 1:
        raise ValueError
    return matches[0]


def load_json(data):
    if isinstance(data, pathlib.Path):
        data = data.read_text()
    return json.loads(data)


def dump_json(data, path=None):
    def _default_json(obj):
        if isinstance(obj, set):
            return sorted(obj)
        elif hasattr(obj, 'isoformat'):
            return obj.isoformat()
    dumped = json.dumps(
        data,
        indent=2,
        sort_keys=True,
        default=_default_json,
        ensure_ascii=False
    )
    if path is not None:
        path.write_text(dumped)
    else:
        return dumped


def cat(pattern):
    return b''.join(p.read_bytes() for p in paths(pattern))


def cd(pattern='~'):
    os.chdir(path(pattern))
    return pathlib.Path.cwd()


def pwd():
    return pathlib.Path.cwd()


def now():
    return datetime.datetime.now().astimezone()


def utcnow():
    return datetime.datetime.utcnow().astimezone(datetime.timezone.utc)
