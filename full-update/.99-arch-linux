#!/usr/bin/python3
# use /usr/bin/python3    intstead of /usr/bin/env python3
# allows using the native pyalpm package
import argparse
import asyncio
import grp
import hashlib
import os
import pathlib
import shutil
import subprocess
import sys

if not pathlib.Path("/etc/arch-release").is_file():
    exit()

import pyalpm


class UV:
    @staticmethod
    async def find_python(version):
        """Find python executable path, returns None if not found (retcode 2)."""
        args = ["uv", "python", "find", version]
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.DEVNULL,
        )
        stdout, _ = await proc.communicate()
        match proc.returncode:
            case 0:
                return pathlib.Path(stdout.decode().strip())
            case 2:
                return None
            case _:
                raise subprocess.CalledProcessError(proc.returncode, args)

    @staticmethod
    async def install_python(version):
        """Install python version."""
        args = ["uv", "python", "install", version]
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)


class Systemctl:
    @staticmethod
    async def is_enabled(name, user=False):
        """Check if systemd unit is enabled."""
        args = [
            "systemctl",
            "--user" if user else "--system",
            "show",
            "--property=UnitFileState",
            "--",
            name,
        ]
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.PIPE,
        )
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)
        match stdout.decode().strip():
            case "UnitFileState=enabled":
                return True
            case "UnitFileState=disabled":
                return False
            case _:
                raise RuntimeError(
                    f"Unexpected UnitFileState: {stdout.decode().strip()}"
                )

    @staticmethod
    async def enable(name, now=False, user=False):
        """Enable systemd unit."""
        if await Systemctl.is_enabled(name, user=user):
            return
        print(f"Enabling unit {name} (user={user}) (now={now})")
        args = []
        if not user:
            args.append("sudo")
        args.extend(
            [
                "systemctl",
                "--user" if user else "--system",
                "enable",
            ]
        )
        if now:
            args.append("--now")
        args.extend(["--", name])
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)


class Pacman:
    @staticmethod
    async def install(packages, asdeps=False):
        """Install packages via pacman."""
        args = [
            "sudo",
            "pacman",
            "-S",
            "--noconfirm",
            "--needed",
            "--overwrite",
            "*",
        ]
        if asdeps:
            args.append("--asdeps")
        args.extend(["--", *packages])
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)

    @staticmethod
    async def set_reason(packages, explicit=False, asdeps=False):
        """Change install reason for packages."""
        if explicit and asdeps:
            raise ValueError("Cannot set both explicit and asdeps")
        if not explicit and not asdeps:
            raise ValueError("Must set either explicit or asdeps")
        args = ["sudo", "pacman", "-D"]
        if explicit:
            args.append("--asexplicit")
        if asdeps:
            args.append("--asdeps")
        args.extend(["--", *packages])
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)


class Flatpak:
    @staticmethod
    async def list_installed():
        """Get set of installed flatpak app IDs."""
        args = [
            "flatpak",
            "list",
            "--app",
            "--columns=application",
        ]
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.DEVNULL,
        )
        stdout, _ = await proc.communicate()
        if proc.returncode:
            return set()
        return {
            line.strip()
            for line in stdout.decode().splitlines()
            if line.strip()
        }

    @staticmethod
    async def get_permissions(app):
        """Get filesystem permissions for a flatpak app."""
        args = [
            "flatpak",
            "info",
            "--show-permissions",
            "--user",
            app,
        ]
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.DEVNULL,
        )
        stdout, _ = await proc.communicate()
        if proc.returncode:
            return set()

        filesystems = set()
        for line in stdout.decode().splitlines():
            line = line.strip()
            if line.startswith("filesystems="):
                perms = line.split("=", 1)[1]
                filesystems.update(
                    p.strip() for p in perms.split(";") if p.strip()
                )
        return filesystems

    @staticmethod
    async def install(remote, app):
        """Install flatpak app from remote."""
        args = [
            "flatpak",
            "install",
            "-y",
            "--user",
            remote,
            app,
        ]
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)

    @staticmethod
    async def override_filesystem(app, path):
        """Grant flatpak app filesystem access."""
        args = [
            "flatpak",
            "override",
            "--user",
            app,
            f"--filesystem={path}",
        ]
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)


class UserGroup:
    @staticmethod
    async def add_to_group(user, group):
        """Add user to group."""
        print(f"Adding user {user} to group {group}")
        args = [
            "sudo",
            "gpasswd",
            "-a",
            user,
            group,
        ]
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.DEVNULL,
        )
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)


HOSTNAME = os.environ["HOST_DOTFILES"]

EXPECTED_PACKAGES = {
    "logrotate",
}

if HOSTNAME in ("sol", "mars", "phobos"):
    EXPECTED_PACKAGES.update(
        {
            "7zip",
            "advancecomp",
            "aria2",
            "base",
            "base-devel",
            "bat",
            "bchunk",
            "bind",  # dig
            "binmerge",
            "busybox",
            "cabextract",
            "cdemu-client",
            "crun",
            "cuetools",
            "curlie",
            "dash",
            "devtools",
            "dolphin-emu-tool",
            "dosfstools",
            "e2fsprogs",
            "efibootmgr",
            "efivar",
            "epub-tools-bin",
            "exfatprogs",
            "fd",
            "ffmpeg",
            "fzf",
            "gifsicle",
            "git",
            "git-lfs",
            "github-cli",
            "guestfs-tools",
            "hdparm",
            "htop",
            "hugo",
            "hyperfine",
            "iftop",
            "imagemagick",
            "inetutils",  # hostname command
            "innoextract",
            "iperf3",
            "iw",
            "jpegoptim",
            "jq",
            "less",
            "libvips",
            "mac",
            "man-db",
            "mediainfo",
            "moreutils",
            "mp3val",
            "mprime-bin",
            "mpv",
            "ms-sys",
            "neovim",
            "nfs-utils",
            "nmap",
            "nsz",
            "ntfs-3g",
            "ntfysh",
            "openbsd-netcat",
            "openssh",
            "opus-tools",
            "oxipng",
            "pacman-contrib",
            "pandoc-cli",
            "pbzip2",
            "perl-image-exiftool",
            "pigz",
            "pixz",
            "pkgfile",
            "prettier",
            "pwgen",
            "pyalpm",
            "pyright",
            "python",
            "reflector",
            "ripgrep",
            "rsync",
            "ruff",
            "rust-analyzer",
            "shellcheck",
            "shntool",
            "speedtest-go",
            "sshfs",
            "sshuttle",
            "stylua",
            "svgo",
            "syncthing",
            "tcpdump",
            "time",
            "tmux",
            "traceroute",
            "transmission-cli",
            "typescript-language-server",
            "unace",
            "unrar",
            "unshield",
            "unzip",
            "usbutils",
            "uv",
            "vi",
            "vim",
            "vorbis-tools",
            "which",
            "wl-clipboard",
            "xsel",
            "yazi",
            "yt-dlp",
            "zip",
            "zsh",
        }
    )

if HOSTNAME == "sol":
    EXPECTED_PACKAGES.add("iptables-nft")
else:
    EXPECTED_PACKAGES.add("iptables")

if HOSTNAME in ("mars", "phobos", "lounge-htpc"):
    EXPECTED_PACKAGES.update(
        {
            "firefox",
            "gamescope",
            "gwenview",
            "haruna",
            "jellyfin-desktop-git",
            "kwalletmanager",
            "noto-fonts",
            "proton-ge-custom-bin",
            "steam",
            "ttf-hack",
        }
    )

if HOSTNAME in ("mars", "phobos"):
    EXPECTED_PACKAGES.update(
        {
            "86box",
            "android-tools",
            "ark",
            "audacity",
            "base16-shell-preview",
            "chromium",
            "discover",
            "docker",
            "docker-compose",
            "dolphin",
            "dvd+rw-tools",
            "element-desktop",
            "extra-cmake-modules",
            "flatpak-builder",
            "flatpak-kcm",
            "foot",
            "ghostty",
            "gifski",
            "gimp",
            "google-chrome",
            "gparted",
            "inkscape",
            "k9s",
            "kcolorchooser",
            "kdeconnect",
            "kid3",
            "krdc",
            "krfb",
            "krita",
            "kubectl",
            "lsdvd",
            "makemkv",
            "meson",
            "mkvalidator",
            "mkvtoolnix-gui",
            "mpv-mpris",
            "ntfydesktop",
            "nvme-cli",
            "obs-studio",
            "okular",
            "opentoonz",
            "plasma6-runners-emojirunner",
            "podman",
            "print-manager",
            "qt6-doc",
            "rawtherapee",
            "sddm",
            "signal-desktop",
            "spectacle",
            "stern",
            "talosctl",
            "typst",
            "udiskie",
            "virt-manager",
            "vlc",
            "vulkan-radeon",  # amdgpu
            "waydroid",
            "wine",
            "xboxdrv",
            "yay",
        }
    )

EXPECTED_FLATPAKS = {
    "flathub": set(),
}

if HOSTNAME in ("mars", "phobos"):
    EXPECTED_FLATPAKS["flathub"].update(
        {
            "com.bitwarden.desktop",
            "com.bitwig.BitwigStudio",
            "md.obsidian.Obsidian",
            "org.equeim.Tremotesf",
            "org.fooyin.fooyin",
            "org.prismlauncher.PrismLauncher",
        }
    )

VHBA_MODULE_PACKAGE = "vhba-module"
if HOSTNAME in ("phobos", "sol"):
    VHBA_MODULE_PACKAGE = "vhba-module-dkms"

EXPECTED_PACKAGE_DEPENDENCIES = {
    "86box": {
        "86box-roms",
    },
    "android-tools": {
        "android-udev",
    },
    "ark": {
        "7zip",
        "arj",
        "lrzip",
        "lzop",
        "unarchiver",
        "unrar",
    },
    "asusctl": {
        "supergfxctl",
    },
    "breeze": {
        "breeze-gtk",
    },
    "cdemu-daemon": {
        "pulse-native-provider",
        VHBA_MODULE_PACKAGE,
    },
    "cmake": {
        "ninja",
    },
    "devtools": {
        "bat",
        "btrfs-progs",
        "nvchecker",
    },
    "digikam": {
        "hugin",
        "qt6-imageformats",
    },
    "dolphin": {
        "ffmpegthumbs",
        "kde-cli-tools",
        "kdegraphics-thumbnailers",
        "kio-admin",
        "konsole",
        "purpose",
    },
    "foot": {
        "foot-terminfo",
    },
    "gimp": {
        "alsa-lib",
        "cfitsio",
        "ghostscript",
        "gjs",
        "gutenprint",
        "gvfs",
    },
    "gwenview": {
        "kimageformats",
        "qt6-imageformats",
    },
    "gparted": {
        "btrfs-progs",
        "dosfstools",
        "exfatprogs",
        "f2fs-tools",
        "gpart",
        "mtools",
        "ntfs-3g",
        "polkit",
        "udftools",
        "xfsprogs",
        "xorg-xhost",
    },
    "libvips": {
        "imagemagick",
        "libheif",
        "libjxl",
        "openslide",
        "poppler-glib",
        "python",
    },
    "neovim": {
        "wl-clipboard",
    },
    "networkmanager": {
        "bluez",
        "dhcpcd",
        "dnsmasq",
        "iptables",
        "iwd",
        "nftables",
        "systemd-resolvconf",
    },
    "libvirt": {
        "dmidecode",
        "dnsmasq",
        "gettext",
        "iptables",
        "lvm2",
        "qemu-desktop",
        "swtpm",
    },
    "kcrash": {
        "drkonqi",
    },
    "krita": {
        "kimageformats5",
        "krita-plugin-gmic",
        "kseexpr",
        "libheif",
        "libjxl",
        "libmypaint",
        "poppler-qt5",
        "python-pyqt5",
    },
    "lutris": {
        "fluidsynth",
        "gamemode",
        "gvfs",
        "innoextract",
        "lib32-gamemode",
        "lib32-vkd3d",
        "lib32-vulkan-icd-loader",
        "python-protobuf",
        "vkd3d",
        "vulkan-icd-loader",
        "vulkan-tools",
        "wine",
        "xorg-xgamma",
    },
    "noto-fonts": {
        "noto-fonts-cjk",
        "noto-fonts-emoji",
        "noto-fonts-extra",
    },
    "okular": {
        "ebook-tools",
        "kdegraphics-mobipocket",
        "unrar",
    },
    "perl-image-exiftool": {
        "perl-archive-zip",
        "perl-io-compress-brotli",
    },
    "pipewire": {
        "pipewire-alsa",
        "pipewire-jack",
        "pipewire-pulse",
    },
    "plasma-desktop": {
        "bluedevil",
        "kscreen",
        "packagekit-qt6",
        "plasma-nm",
        "plasma-pa",
    },
    "plasma-workspace": {
        "xdg-desktop-portal-gtk",
    },
    "print-manager": {
        "system-config-printer",
    },
    "proton-ge-custom-bin": {
        "kdialog",
        "lib32-vulkan-icd-loader",
        "python-kivy",
        "steam",
        "vulkan-driver",
        "wine",
        "winetricks",
        "xboxdrv",
        "zenity",
    },
    "python": {
        "python-setuptools",
        "python-pip",
        "sqlite",
        "xz",
        "tk",
    },
    "python-aiohttp": {
        "python-aiodns",
    },
    "udiskie": {
        "libappindicator",
    },
    "vulkan-radeon": {
        "lib32-vulkan-radeon",
    },
    "wine": {
        "alsa-plugins",
        "cups",
        "dosbox",
        "gnutls",
        "gst-plugins-bad",
        "gst-plugins-base",
        "gst-plugins-base-libs",
        "gst-plugins-good",
        "gst-plugins-ugly",
        "libgphoto2",
        "libpulse",
        "libxcomposite",
        "libxinerama",
        "opencl-icd-loader",
        "pcsclite",
        "samba",
        "sane",
        "sdl2-compat",
        "unixodbc",
        "v4l-utils",
        "wine-gecko",
        "wine-mono",
    },
    "xdg-utils": {
        # needed to correctly identify .cbz as application/vnd.comicbook+zip
        "perl-file-mimeinfo",
    },
    "yazi": {
        "7zip",
        "chafa",
        "fd",
        "ffmpeg",
        "fzf",
        "imagemagick",
        "jq",
        "poppler",
        "ripgrep",
        "wl-clipboard",
        "zoxide",
    },
    "yt-dlp": {
        "aria2",
        "atomicparsley",
        "ffmpeg",
        "python-brotli",
        "python-brotlicffi",
        "python-pycryptodome",
        "python-pycryptodomex",
        "python-pyxattr",
        "python-secretstorage",
        "python-websockets",
        "python-xattr",
        "rtmpdump",
        "yt-dlp-ejs",
    },
}

EXPECTED_GROUPS = {}

EXPECTED_SERVICES = {
    "fstrim.timer",
    "logrotate.timer",
    "systemd-timesyncd.service",
}

EFI_SHELL_HOSTS = ("mars", "phobos", "lounge-htpc", "sol")
if HOSTNAME in EFI_SHELL_HOSTS:
    EXPECTED_PACKAGES.add("edk2-shell")
    EXPECTED_SERVICES.add("systemd-boot-update.service")

if HOSTNAME in ("lounge-htpc"):
    EXPECTED_GROUPS.setdefault("lounge-htpc", set())
    EXPECTED_GROUPS["lounge-htpc"].update(
        {
            "audio",
            "games",
            "nopasswdlogin",
            "realtime",
            "video",
            "wheel",
        }
    )

if HOSTNAME in ("mars", "phobos"):
    EXPECTED_PACKAGE_DEPENDENCIES.setdefault("podman", set())
    EXPECTED_PACKAGE_DEPENDENCIES["podman"].update(
        {
            "apparmor",
            "btrfs-progs",
            "fuse-overlayfs",
            "podman-compose",
            "slirp4netns",
        }
    )

    EXPECTED_PACKAGE_DEPENDENCIES.setdefault("docker", set())
    EXPECTED_PACKAGE_DEPENDENCIES["docker"].update(
        {
            "btrfs-progs",
            "docker-buildx",
            "pigz",
        }
    )

    EXPECTED_GROUPS.setdefault("ar", set())
    EXPECTED_GROUPS["ar"].update(
        {
            "games",  # for proton to automatically set niceness
            "realtime",
            "libvirt",
            "libvirt-qemu",
            "storage",
            "video",
            "wheel",
        }
    )
    EXPECTED_PACKAGES.update(
        {
            "python-pytorch-opt-rocm",
        }
    )

if HOSTNAME in ("lounge-htpc", "mars"):
    EXPECTED_PACKAGES.update(
        {
            "linux",
            "linux-headers",
        }
    )

if HOSTNAME in ("lounge-htpc", "mars", "phobos"):
    EXPECTED_PACKAGES.update(
        {
            "plymouth",
            "plymouth-kcm",
        }
    )

if HOSTNAME == "mars":
    EXPECTED_PACKAGES.update(
        {
            "digikam",
        }
    )

if HOSTNAME == "phobos":
    EXPECTED_PACKAGES.update(
        {
            "linux-flowx13",
            "linux-flowx13-headers",
            "plasma-keyboard",
            "rog-control-center",
        }
    )

if HOSTNAME in ("lounge-htpc", "phobos", "sol"):
    EXPECTED_PACKAGES.update(
        {
            "linux-lts",
            "linux-lts-headers",
        }
    )
    EXPECTED_SERVICES.update(
        {
            "smb.service",
        }
    )


def sha256sum(path):
    hasher = hashlib.sha256()
    try:
        with open(path, "rb") as handle:
            while data := handle.read(65536):
                hasher.update(data)
    except OSError:
        print(f'error reading "{path}"', file=sys.stderr)
        raise
    return hasher.hexdigest()


async def install_efi_shell():
    source = pathlib.Path("/usr/share/edk2-shell/x64/Shell_Full.efi")
    target = pathlib.Path("/boot/shellx64.efi")

    if not target.exists() or sha256sum(source) != sha256sum(target):
        print("Installing", target)
        shutil.copyfile(source, target)


async def ensure_python_freethreaded():
    """Install Python 3.14+ freethreaded via uv if not already installed."""
    python_path = await UV.find_python("3.14t")

    if python_path is None:
        print("Installing Python 3.14 freethreaded via uv")
        await UV.install_python("3.14t")
        python_path = await UV.find_python("3.14t")

    local_bin = pathlib.Path.home() / ".local" / "bin"
    local_bin.mkdir(parents=True, exist_ok=True)

    for name in ("python3", "python"):
        link_path = local_bin / name
        if link_path.is_symlink() or link_path.exists():
            if link_path.resolve() == python_path:
                continue
            link_path.unlink()

        print(f"Linking {link_path} to {python_path}")
        link_path.symlink_to(python_path)


async def ensure_using_systemd_resolved():
    unit = "systemd-resolved"
    if await Systemctl.is_enabled(unit):
        await Systemctl.enable(unit)

    source = pathlib.Path("/run/systemd/resolve/stub-resolv.conf")
    target = pathlib.Path("/etc/resolv.conf")
    if target.resolve() != source:
        print(f"Linking {target} to {source}")
        try:
            target.unlink()
        except FileNotFoundError:
            pass
        target.symlink_to(source)


async def ensure_users_in_expected_groups():
    for user, expected_groups in EXPECTED_GROUPS.items():
        current_groups = {
            g.gr_name for g in grp.getgrall() if user in g.gr_mem
        }
        for group in expected_groups - current_groups:
            await UserGroup.add_to_group(user, group)


def all_packages():
    handle = pyalpm.Handle(".", "/var/lib/pacman")
    localdb = handle.get_localdb()
    return localdb.pkgcache


async def ensure_flatpak_permissions():
    """Configure persistent filesystem access for flatpaks."""
    # Note: using :ro will always result in a portal path like /run/user/1000/doc/74ae3507/Library
    flatpak_permissions = {}

    match HOSTNAME:
        case "mars":
            # portal paths are not consistent,
            # likely due to /storage being an NFS mount.
            # eg. it could initially be /run/user/1000/doc/74ae3507/Library, but change to /run/user/1000/doc/efd6054f after a reboot
            flatpak_permissions["org.fooyin.fooyin"] = [
                "/storage/Audio/Library",
            ]
        case "phobos":
            flatpak_permissions["org.fooyin.fooyin"] = [
                "/home/ar/Audio/Lossy_opus_128/:ro",
            ]

    installed_flatpaks = await Flatpak.list_installed()

    for app, paths in flatpak_permissions.items():
        if app not in installed_flatpaks:
            continue

        current_perms = await Flatpak.get_permissions(app)

        for path in paths:
            # Normalize path for comparison - remove slash before :ro/:rw suffix
            normalized_path = path.replace("/:", ":")
            if not any(p == normalized_path for p in current_perms):
                print(f"Granting {app} access to {path}")
                await Flatpak.override_filesystem(app, path)


async def dump_installed_packages():
    """Dump installed packages list to DOTFILES_PRIVATE if configured."""
    dotfiles_private = os.environ.get("DOTFILES_PRIVATE")
    if not dotfiles_private:
        return

    output_file = (
        pathlib.Path(dotfiles_private)
        / "arch-linux"
        / f"packages_{HOSTNAME}.txt"
    )
    packages = sorted(all_packages(), key=lambda p: p.name)

    lines = []
    for pkg in packages:
        reason = (
            "explicit"
            if pkg.reason == pyalpm.PKG_REASON_EXPLICIT
            else "dependency"
        )
        lines.append(f"{pkg.name} {reason}")

    output_file.write_text("\n".join(lines) + "\n")


async def ensure_flatpaks():
    if not shutil.which("flatpak"):
        return
    installed_flatpaks = await Flatpak.list_installed()

    for remote, expected_apps in EXPECTED_FLATPAKS.items():
        missing = expected_apps - installed_flatpaks

        if missing:
            print(f"Installing missing flatpaks from {remote} ...")
            for app in missing:
                print(f"  Installing {app}")
                await Flatpak.install(remote, app)

    await ensure_flatpak_permissions()


async def ensure_packages():
    expected_packages = set(EXPECTED_PACKAGES)
    installed_packages = {package.name: package for package in all_packages()}

    missing = set()
    wrong_reason = set()
    for name in expected_packages:
        if name not in installed_packages:
            missing.add(name)
        elif installed_packages[name].reason != pyalpm.PKG_REASON_EXPLICIT:
            wrong_reason.add(name)

    if missing:
        print("Installing missing packages ...")
        await Pacman.install(missing)

    if wrong_reason:
        print("Marking packages as explicitly installed ...")
        await Pacman.set_reason(wrong_reason, explicit=True)


async def ensure_package_dependencies():
    provided_packages = set()
    installed_packages = set()
    for package in all_packages():
        installed_packages.add(package.name)
        provided_packages.add(package.name)
        provided_packages.update(package.provides)

    missing = set()
    for package, expected_deps in EXPECTED_PACKAGE_DEPENDENCIES.items():
        if package not in installed_packages:
            continue
        for dep in expected_deps:
            if dep not in provided_packages:
                missing.add(dep)

    if missing:
        print("Installing missing dependencies ...")
        await Pacman.install(missing, asdeps=True)


async def run_mode(mode):
    args = []
    if mode == "root":
        args.extend(["sudo", "--preserve-env=HOST_DOTFILES"])
    args.extend([__file__, mode])
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode:
        raise ProcessError(proc)


class ProcessError(Exception):
    def __init__(self, process, message=None):
        self.process = process
        self.message = message

    def __str__(self):
        proc = self.process

        text = f"exit {proc.returncode}"
        if self.message is not None:
            text = f"{text} - {self.message}"

        try:
            args = proc._transport._extra["subprocess"].args
        except (AttributeError, KeyError):
            pass
        else:
            text = f"{text}: {args}"
        return text


async def main():
    if not pathlib.Path("/etc/arch-release").exists():
        return

    modes = ["user", "root"]
    parser = argparse.ArgumentParser()
    parser.add_argument("mode", choices=modes, nargs="?")
    args = parser.parse_args()

    # TODO: always run as root
    match args.mode:
        case "user":
            await ensure_users_in_expected_groups()

            await ensure_packages()
            await ensure_package_dependencies()
            await ensure_flatpaks()
            await dump_installed_packages()

            # if HOSTNAME in ("mars", "phobos", "sol"):
            if HOSTNAME in ():
                await ensure_python_freethreaded()

            for service in EXPECTED_SERVICES:
                await Systemctl.enable(service, now=True)
        case "root":
            if HOSTNAME in ("mars", "phobos"):
                await ensure_using_systemd_resolved()
            if HOSTNAME in EFI_SHELL_HOSTS:
                await install_efi_shell()
        case _:
            for mode in modes:
                await run_mode(mode)


if __name__ == "__main__":
    asyncio.run(main())
