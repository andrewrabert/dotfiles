#!/usr/bin/env python3
import asyncio
import dataclasses
import pathlib
import sys


EXPECTED_PACKAGES = {
    '7-zip',
    'advancecomp',
    'aria2',
    'dash',
    'foot-terminfo',
    'fzf',
    'lf',
    'neovim',
    'rsync',
    'tmux',
    'wl-clipboard',
    'xsel',
    'yt-dlp',
    'zsh',
}


# bool True == package is installed
EXPECTED_OPT_DEPENDS = {
    'dolphin': {
        'ffmpegthumbs': True,
        'kde-cli-tools': True,
        'kdegraphics-thumbnailers': True,
        'kio-admin': True,
        'konsole': False,
        'purpose': True,
    },
    'neovim': {
        'python-pynvim': False,
        'xclip': False,
        'xsel': False,
        'wl-clipboard': False,
    },
    'yt-dlp': {
        'aria2': True,
        'atomicparsley': True,
        'ffmpeg': True,
        'phantomjs': False,
        'python-brotli': True,
        'python-brotlicffi': True,
        'python-mutagen': True,
        'python-pycryptodome': True,
        'python-pycryptodomex': True,
        'python-pyxattr': True,
        'python-secretstorage': True,
        'python-websockets': True,
        'python-xattr': True,
        'rtmpdump': True,
    },
}


@dataclasses.dataclass
class Package:
    name: str
    explicitly_installed: bool


@dataclasses.dataclass
class OptionalDependency:
    parent_name: str
    name: str
    description: str
    installed: bool


async def pacman_query_installed(packages):
    proc = await asyncio.create_subprocess_exec(
            'pacman', '-Qi', '--', *set(packages),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await proc.communicate()
    for line in stderr.decode().splitlines():
        if line.startswith("error: package '") and line.endswith("' was not found"):
            continue
        print(line, file=sys.stderr)

    found_packages = {}

    name = None
    explicitly_installed = False
    for line in stdout.decode().splitlines():
        if line.startswith('Install Reason  :'):
            _, part = line.split(':', maxsplit=1)
            match part.strip():
                case 'Explicitly installed':
                    explicitly_installed = True
                case 'Installed as a dependency for another package':
                    explicitly_installed = False
                case _:
                    raise RuntimeError()
        if line.startswith('Name            : '):
            if name is not None:
                found_packages[name] = Package(
                    name=name,
                    explicitly_installed=explicitly_installed,
                )
            name = line.split(':', maxsplit=1)[1].strip()

    if name is not None:
        found_packages[name] = Package(
            name=name,
            explicitly_installed=explicitly_installed,
        )
    return found_packages


async def pacman_query_opt_depends(packages):
    proc = await asyncio.create_subprocess_exec(
            'pacman', '-Qi', '--', *set(packages),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await proc.communicate()
    for line in stderr.decode().splitlines():
        if line.startswith("error: package '") and line.endswith("' was not found"):
            continue
        print(line, file=sys.stderr)

    opt_depends = {}

    inside_optdepends = False
    parent_package = None
    for line in stdout.decode().splitlines():
        if line.startswith('Name            : '):
            parent_package = line.split(':', maxsplit=1)[1].strip()

        if line.startswith('Optional Deps   : '):
            inside_optdepends = True
            parts = line.split(':', maxsplit=2)
            match len(parts):
                case 2:
                    if parts[1].strip() == 'None':
                        # no opt depends
                        continue
                case 3:
                    package_name = parts[1]
                    description = parts[2]
        elif inside_optdepends and line.startswith('                  '):
            package_name, description = line.split(':', maxsplit=1)
        else:
            inside_optdepends = False
            package_name = None

        if package_name is not None:
            package_name = package_name.strip()
            installed = False
            if description.strip().endswith(' [installed]'):
                description = description.removesuffix(' [installed]')
                installed = True
            optdep = OptionalDependency(
                parent_name=parent_package.strip(),
                name=package_name.strip(),
                description=description.strip(),
                installed=installed,
            )
            opt_depends.setdefault(parent_package, [])
            opt_depends[parent_package].append(optdep)
    return opt_depends


async def is_unit_enabled(name, user=False):
    proc = await asyncio.create_subprocess_exec(
        'systemctl',
        '--user' if user else '--system',
        'show',
        '--property=UnitFileState',
        '--',
        name,
        stdout=asyncio.subprocess.PIPE,
    )
    if proc.returncode:
        raise RuntimeError(f'exit {proc.returncode}')
    stdout, _ = await proc.communicate()
    match stdout.decode().strip():
        case 'UnitFileState=enabled':
            return True
        case 'UnitFileState=disabled':
            return False
        case _:
            raise RuntimeError


async def enable_unit(name, now=False, user=False):
    if await is_unit_enabled(name, user=user):
        return
    print(f'Enabling unit {name} (user={user}) (now={now})')
    args = []
    if not user:
        args.append('sudo')

    args.extend([
        'systemctl',
        '--user' if user else '--system',
        'enable',
    ])
    if now:
        args.append('--now')
    args.extend(['--', name])
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.communicate()
    if proc.returncode:
        raise RuntimeError(f'exit {proc.returncode}')


async def install_packages(packages, asdeps=False, asexplicit=False):
    args = [
        'sudo',
        'pacman',
        '-S',
        '--noconfirm',
    ]
    if asdeps:
        args.append('--asdeps')
    if asexplicit:
        args.append('--asexplicit')
    args.extend(['--', *packages])
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.communicate()


async def ensure_packages():
    packages = await pacman_query_installed(EXPECTED_PACKAGES)
    missing = set()
    for name in EXPECTED_PACKAGES:
        if name not in packages:
            missing.add(name)
        elif not packages[name].explicitly_installed:
            print('here', name)
            missing.add(name)

    if missing:
        await install_packages(missing, asexplicit=True)


async def ensure_opt_depends():
    opt_deps_by_parent = await pacman_query_opt_depends(
            EXPECTED_OPT_DEPENDS.keys())
    missing = set()
    for parent, opt_deps in opt_deps_by_parent.items():
        for opt_dep in opt_deps:
            try:
                expected_installed = EXPECTED_OPT_DEPENDS[parent][opt_dep.name]
            except KeyError:
                print(f'warning: undefined opt dep for {parent} - {opt_dep.name}',
                      file=sys.stderr)
                continue
            if opt_dep.installed != expected_installed:
                if opt_dep.installed:
                    if opt_dep.name not in EXPECTED_PACKAGES:
                        print(f'warning: unexpected optdep installed for {parent} - {opt_dep.name}: {opt_dep.description}', file=sys.stderr)
                else:
                    missing.add(opt_dep.name)
    if missing:
        await install_packages(missing, asdeps=True)


async def main():
    if not pathlib.Path('/etc/arch-release').exists():
        return

    await enable_unit('fstrim.timer', now=True)
    await enable_unit('systemd-timesyncd.service', now=True)
    await enable_unit('logrotate.timer', now=True)

    await ensure_packages()
    await ensure_opt_depends()



if __name__ == '__main__':
    asyncio.run(main())
