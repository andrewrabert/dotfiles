#!/usr/bin/python3
# use /usr/bin/python3 intstead of /usr/bin/env python3
# allows using the native pyalpm package
import argparse
import asyncio
import grp
import hashlib
import os
import pathlib
import shutil
import subprocess
import sys

if not pathlib.Path("/etc/arch-release").is_file():
    exit()

try:
    import pyalpm
except ImportError:
    subprocess.run(["yay", "-S", "--noconfirm", "pyalpm"], check=True)
    import pyalpm


class UV:
    @staticmethod
    async def find_python(version):
        """Find python executable path, returns None if not found (retcode 2)."""
        args = ["uv", "python", "find", version]
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.DEVNULL,
        )
        stdout, _ = await proc.communicate()
        match proc.returncode:
            case 0:
                return pathlib.Path(stdout.decode().strip())
            case 2:
                return None
            case _:
                raise subprocess.CalledProcessError(proc.returncode, args)

    @staticmethod
    async def install_python(version):
        """Install python version."""
        args = ["uv", "python", "install", version]
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)


class Systemctl:
    @staticmethod
    async def is_enabled(name, user=False):
        """Check if systemd unit is enabled."""
        args = [
            "systemctl",
            "--user" if user else "--system",
            "show",
            "--property=UnitFileState",
            "--",
            name,
        ]
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.PIPE,
        )
        stdout, _ = await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)
        match stdout.decode().strip():
            case "UnitFileState=enabled":
                return True
            case "UnitFileState=disabled":
                return False
            case _:
                raise RuntimeError(
                    f"Unexpected UnitFileState: {stdout.decode().strip()}"
                )

    @staticmethod
    async def enable(name, now=False, user=False):
        """Enable systemd unit."""
        if await Systemctl.is_enabled(name, user=user):
            return
        print(f"Enabling unit {name} (user={user}) (now={now})")
        args = []
        if not user:
            args.append("sudo")
        args.extend(
            [
                "systemctl",
                "--user" if user else "--system",
                "enable",
            ]
        )
        if now:
            args.append("--now")
        args.extend(["--", name])
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)


class Pacman:
    @staticmethod
    async def install(packages, asdeps=False, asexplicit=False):
        """Install packages via pacman."""
        args = [
            "sudo",
            "pacman",
            "-S",
            "--noconfirm",
        ]
        if asdeps:
            args.append("--asdeps")
        if asexplicit:
            args.append("--asexplicit")
        args.extend(["--", *packages])
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)


class Flatpak:
    @staticmethod
    async def list_installed():
        """Get set of installed flatpak app IDs."""
        args = [
            "flatpak",
            "list",
            "--app",
            "--columns=application",
        ]
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.DEVNULL,
        )
        stdout, _ = await proc.communicate()
        if proc.returncode:
            return set()
        return {
            line.strip()
            for line in stdout.decode().splitlines()
            if line.strip()
        }

    @staticmethod
    async def get_permissions(app):
        """Get filesystem permissions for a flatpak app."""
        args = [
            "flatpak",
            "info",
            "--show-permissions",
            "--user",
            app,
        ]
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.DEVNULL,
        )
        stdout, _ = await proc.communicate()
        if proc.returncode:
            return set()

        filesystems = set()
        for line in stdout.decode().splitlines():
            line = line.strip()
            if line.startswith("filesystems="):
                perms = line.split("=", 1)[1]
                filesystems.update(
                    p.strip() for p in perms.split(";") if p.strip()
                )
        return filesystems

    @staticmethod
    async def install(remote, app):
        """Install flatpak app from remote."""
        args = [
            "flatpak",
            "install",
            "-y",
            "--user",
            remote,
            app,
        ]
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)

    @staticmethod
    async def override_filesystem(app, path):
        """Grant flatpak app filesystem access."""
        args = [
            "flatpak",
            "override",
            "--user",
            app,
            f"--filesystem={path}",
        ]
        proc = await asyncio.create_subprocess_exec(*args)
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)


class UserGroup:
    @staticmethod
    async def add_to_group(user, group):
        """Add user to group."""
        print(f"Adding user {user} to group {group}")
        args = [
            "sudo",
            "gpasswd",
            "-a",
            user,
            group,
        ]
        proc = await asyncio.create_subprocess_exec(
            *args,
            stdout=asyncio.subprocess.DEVNULL,
        )
        await proc.communicate()
        if proc.returncode:
            raise subprocess.CalledProcessError(proc.returncode, args)


HOSTNAME = os.environ["HOST_DOTFILES"]

EXPECTED_PACKAGES = {
    "logrotate",
}

if HOSTNAME in ("sol", "mars", "phobos"):
    EXPECTED_PACKAGES.update(
        {
            "7zip",
            "advancecomp",
            "aria2",
            "ast-grep",
            "bat",
            "bchunk",
            "binmerge",
            "busybox",
            "cabextract",
            "cdemu-client",
            "cuetools",
            "curlie",
            "dash",
            "devtools",
            "dosfstools",
            "e2fsprogs",
            "epub-tools-bin",
            "exfatprogs",
            "fd",
            "ffmpeg",
            "foot-terminfo",
            "fzf",
            "gifsicle",
            "git",
            "git-lfs",
            "github-cli",
            "guestfs-tools",
            "htop",
            "hugo",
            "hyperfine",
            "iftop",
            "inetutils",  # hostname command
            "innoextract",
            "iperf3",
            "jpegoptim",
            "jq",
            "ledger",
            "less",
            "libvips",
            "mac",
            "mediainfo",
            "moreutils",
            "mp3val",
            "mprime-bin",
            "mpv",
            "mpv-mpris",
            "ms-sys",
            "neovim",
            "nsz",
            "ntfs-3g",
            "ntfysh",
            "openbsd-netcat",
            "openssh",
            "opus-tools",
            "oxipng",
            "pacman-contrib",
            "pandoc-cli",
            "pbzip2",
            "perl-image-exiftool",
            "pigz",
            "pixz",
            "prettier",
            "pwgen",
            "pyalpm",
            "pyright",
            "python",
            "rdfind",
            "reflector",
            "ripgrep",
            "rsync",
            "ruff",
            "rust-analyzer",
            "shellcheck",
            "shntool",
            "speedtest-go",
            "sshfs",
            "sshuttle",
            "stylua",
            "svgo",
            "syncthing",
            "tmux",
            "transmission-cli",
            "tree-sitter-cli",
            "typescript-language-server",
            "unace",
            "unrar",
            "unshield",
            "unzip",
            "usbutils",
            "uv",
            "vim",
            "vorbis-tools",
            "wl-clipboard",
            "xsel",
            "yazi",
            "yt-dlp",
            "zip",
            "zsh",
        }
    )

if HOSTNAME in ("mars", "phobos", "lounge-htpc"):
    EXPECTED_PACKAGES.update(
        {
            "firefox",
            "gamescope",
            "gwenview",
            "haruna",
            "jellyfin-media-player-git",
            "kwalletmanager",
            "mangohud",
            "noto-fonts",
            "noto-fonts-cjk",
            "noto-fonts-emoji",
            "noto-fonts-extra",
            "proton-ge-custom-bin",
            "steam",
            "ttf-hack",
        }
    )

if HOSTNAME in ("mars", "phobos"):
    EXPECTED_PACKAGES.update(
        {
            "android-tools",
            "android-udev",
            "audacity",
            "base16-shell-preview",
            "chromium",
            "discover",
            "docker",
            "docker-compose",
            "dolphin",
            "element-desktop",
            "foliate",
            "foot",
            "gifski",
            "gimp",
            "gparted",
            "inkscape",
            "k9s",
            "kcolorchooser",
            "kdeconnect",
            "kid3",
            "krita",
            "kubectl",
            "mkvtoolnix-gui",
            "mtpfs",
            "ntfydesktop",
            "obs-studio",
            "okular",
            "plasma6-runners-emojirunner",
            "podman",
            "rawtherapee",
            "signal-desktop",
            "spectacle",
            "stern",
            "talosctl",
            "virt-manager",
            "vlc",
            "wine",
            "xboxdrv",
        }
    )

EXPECTED_FLATPAKS = {
    "flathub": set(),
}

if HOSTNAME in ("mars", "phobos"):
    EXPECTED_FLATPAKS["flathub"].update(
        {
            "com.bitwarden.desktop",
            "com.bitwig.BitwigStudio",
            "md.obsidian.Obsidian",
            "org.equeim.Tremotesf",
            "org.fooyin.fooyin",
        }
    )

EXPECTED_PACKAGE_DEPENDENCIES = {
    "cdemu-daemon": {
        "vhba-module-dkms",
    },
    "devtools": {
        "bat",
        "btrfs-progs",
        "nvchecker",
    },
    "digikam": {
        "darktable",
        "hugin",
        "qt6-imageformats",
    },
    "dolphin": {
        "ffmpegthumbs",
        "kde-cli-tools",
        "kdegraphics-thumbnailers",
        "kio-admin",
        "konsole",
        "purpose",
    },
    "gimp": {
        "alsa-lib",
        "cfitsio",
        "ghostscript",
        "gjs",
        "gutenprint",
        "gvfs",
    },
    "gwenview": {
        "kimageformats",
        "qt6-imageformats",
    },
    "gparted": {
        "btrfs-progs",
        "dosfstools",
        "exfatprogs",
        "f2fs-tools",
        "gpart",
        "mtools",
        "ntfs-3g",
        "polkit",
        "udftools",
        "xfsprogs",
        "xorg-xhost",
    },
    "libvips": {
        "imagemagick",
        "libheif",
        "libjxl",
        "openslide",
        "poppler-glib",
        "python",
    },
    "libvirt": {
        "dmidecode",
        "dnsmasq",
        "gettext",
        "iptables-nft",
        "lvm2",
        "qemu-desktop",
        "swtpm",
    },
    "krita": {
        "kimageformats5",
        "krita-plugin-gmic",
        "kseexpr",
        "libheif",
        "libjxl",
        "libmypaint",
        "poppler-qt5",
        "python-pyqt5",
    },
    "lutris": {
        "fluidsynth",
        "gamemode",
        "gvfs",
        "innoextract",
        "lib32-gamemode",
        "lib32-vkd3d",
        "lib32-vulkan-icd-loader",
        "python-protobuf",
        "vkd3d",
        "vulkan-icd-loader",
        "vulkan-tools",
        "wine",
        "xorg-xgamma",
    },
    "okular": {
        "ebook-tools",
        "kdegraphics-mobipocket",
        "unrar",
    },
    "perl-image-exiftool": {
        "perl-archive-zip",
        "perl-io-compress-brotli",
    },
    "print-manager": {
        "system-config-printer",
    },
    "proton-ge-custom-bin": {
        "kdialog",
        "lib32-vulkan-icd-loader",
        "python-kivy",
        "steam",
        "vulkan-driver",
        "wine",
        "winetricks",
        "xboxdrv",
        "zenity",
    },
    "python": {
        "python-setuptools",
        "python-pip",
        "sqlite",
        "xz",
        "tk",
    },
    "python-aiohttp": {
        "python-aiodns",
    },
    "udiskie": {
        "libappindicator",
    },
    "wine": {
        "alsa-plugins",
        "cups",
        "dosbox",
        "gnutls",
        "gst-plugins-bad",
        "gst-plugins-base",
        "gst-plugins-base-libs",
        "gst-plugins-good",
        "gst-plugins-ugly",
        "lib32-alsa-lib",
        "lib32-alsa-plugins",
        "lib32-gnutls",
        "lib32-gst-plugins-base",
        "lib32-gst-plugins-base-libs",
        "lib32-gst-plugins-good",
        "lib32-libcups",
        "lib32-libpulse",
        "lib32-libxcomposite",
        "lib32-libxinerama",
        "lib32-opencl-icd-loader",
        "lib32-pcsclite",
        "lib32-sdl2-compat",
        "lib32-v4l-utils",
        "libgphoto2",
        "libpulse",
        "libxcomposite",
        "libxinerama",
        "opencl-icd-loader",
        "pcsclite",
        "samba",
        "sane",
        "sdl2-compat",
        "unixodbc",
        "v4l-utils",
        "wine-gecko",
        "wine-mono",
    },
    "xdg-utils": {
        # needed to correctly identify .cbz as application/vnd.comicbook+zip
        "perl-file-mimeinfo",
    },
    "yazi": {
        "7zip",
        "chafa",
        "fd",
        "ffmpeg",
        "fzf",
        "imagemagick",
        "jq",
        "poppler",
        "ripgrep",
        "zoxide",
    },
    "yt-dlp": {
        "aria2",
        "atomicparsley",
        "ffmpeg",
        "python-brotli",
        "python-brotlicffi",
        "python-mutagen",
        "python-pycryptodome",
        "python-pycryptodomex",
        "python-pyxattr",
        "python-secretstorage",
        "python-websockets",
        "python-xattr",
        "rtmpdump",
    },
}

EXPECTED_GROUPS = {}

EXPECTED_SERVICES = {
    "fstrim.timer",
    "logrotate.timer",
    "systemd-timesyncd.service",
}

EFI_SHELL_HOSTS = ("mars", "phobos", "lounge-htpc", "sol")
if HOSTNAME in EFI_SHELL_HOSTS:
    EXPECTED_PACKAGES.add("edk2-shell")

if HOSTNAME in ("lounge-htpc"):
    EXPECTED_GROUPS.setdefault("lounge-htpc", set())
    EXPECTED_GROUPS["lounge-htpc"].update(
        {
            "audio",
            "games",
            "nopasswdlogin",
            "realtime",
            "video",
            "wheel",
        }
    )

if HOSTNAME in ("mars", "phobos"):
    EXPECTED_PACKAGE_DEPENDENCIES.setdefault("podman", set())
    EXPECTED_PACKAGE_DEPENDENCIES["podman"].update(
        {
            "apparmor",
            "btrfs-progs",
            "cni-plugins",
            "fuse-overlayfs",
            "podman-compose",
            "slirp4netns",
        }
    )

    EXPECTED_PACKAGE_DEPENDENCIES.setdefault("docker", set())
    EXPECTED_PACKAGE_DEPENDENCIES["docker"].update(
        {
            "btrfs-progs",
            "docker-buildx",
            "pigz",
        }
    )

    EXPECTED_GROUPS.setdefault("ar", set())
    EXPECTED_GROUPS["ar"].update(
        {
            "games",  # for proton to automatically set niceness
            "realtime",
            "libvirt",
            "libvirt-qemu",
            "storage",
            "video",
            "wheel",
        }
    )
    EXPECTED_PACKAGES.update(
        {
            "python-pytorch-opt-rocm",
        }
    )

if HOSTNAME in ("lounge-htpc", "mars"):
    EXPECTED_PACKAGES.update(
        {
            "linux",
            "linux-headers",
        }
    )

if HOSTNAME in ("lounge-htpc", "mars", "phobos"):
    EXPECTED_PACKAGES.update(
        {
            "plymouth",
        }
    )

if HOSTNAME == "phobos":
    EXPECTED_PACKAGES.update(
        {
            "linux-flowx13",
            "linux-flowx13-headers",
            "plasma-keyboard",
        }
    )

if HOSTNAME in ("lounge-htpc", "mars", "phobos", "sol"):
    EXPECTED_PACKAGES.update(
        {
            "linux-lts",
            "linux-lts-headers",
        }
    )
    EXPECTED_SERVICES.update(
        {
            "smb.service",
        }
    )


def sha256sum(path):
    hasher = hashlib.sha256()
    try:
        with open(path, "rb") as handle:
            while data := handle.read(65536):
                hasher.update(data)
    except OSError:
        print(f'error reading "{path}"', file=sys.stderr)
        raise
    return hasher.hexdigest()


async def install_efi_shell():
    source = pathlib.Path("/usr/share/edk2-shell/x64/Shell_Full.efi")
    target = pathlib.Path("/boot/shellx64.efi")

    if not target.exists() or sha256sum(source) != sha256sum(target):
        print("Installing", target)
        shutil.copyfile(source, target)


async def ensure_python_freethreaded():
    """Install Python 3.14+ freethreaded via uv if not already installed."""
    python_path = await UV.find_python("3.14t")

    if python_path is None:
        print("Installing Python 3.14 freethreaded via uv")
        await UV.install_python("3.14t")
        python_path = await UV.find_python("3.14t")

    local_bin = pathlib.Path.home() / ".local" / "bin"
    local_bin.mkdir(parents=True, exist_ok=True)

    for name in ("python3", "python"):
        link_path = local_bin / name
        if link_path.is_symlink() or link_path.exists():
            if link_path.resolve() == python_path:
                continue
            link_path.unlink()

        print(f"Linking {link_path} to {python_path}")
        link_path.symlink_to(python_path)


async def ensure_using_systemd_resolved():
    unit = "systemd-resolved"
    if await Systemctl.is_enabled(unit):
        await Systemctl.enable(unit)

    source = pathlib.Path("/run/systemd/resolve/stub-resolv.conf")
    target = pathlib.Path("/etc/resolv.conf")
    if target.resolve() != source:
        print(f"Linking {target} to {source}")
        try:
            target.unlink()
        except FileNotFoundError:
            pass
        target.symlink_to(source)


async def ensure_users_in_expected_groups():
    for user, expected_groups in EXPECTED_GROUPS.items():
        current_groups = {
            g.gr_name for g in grp.getgrall() if user in g.gr_mem
        }
        for group in expected_groups - current_groups:
            await UserGroup.add_to_group(user, group)


def all_packages():
    handle = pyalpm.Handle(".", "/var/lib/pacman")
    localdb = handle.get_localdb()
    return localdb.pkgcache


async def ensure_flatpak_permissions():
    """Configure persistent filesystem access for flatpaks."""
    # Note: using :ro will always result in a portal path like /run/user/1000/doc/74ae3507/Library
    flatpak_permissions = {}

    match HOSTNAME:
        case "mars":
            # portal paths are not consistent,
            # likely due to /storage being an NFS mount.
            # eg. it could initially be /run/user/1000/doc/74ae3507/Library, but change to /run/user/1000/doc/efd6054f after a reboot
            flatpak_permissions["org.fooyin.fooyin"] = [
                "/storage/Audio/Library",
            ]
        case "phobos":
            flatpak_permissions["org.fooyin.fooyin"] = [
                "/home/ar/Audio/Lossy_opus_128/:ro",
            ]

    installed_flatpaks = await Flatpak.list_installed()

    for app, paths in flatpak_permissions.items():
        if app not in installed_flatpaks:
            continue

        current_perms = await Flatpak.get_permissions(app)

        for path in paths:
            # Normalize path for comparison - remove slash before :ro/:rw suffix
            normalized_path = path.replace("/:", ":")
            if not any(p == normalized_path for p in current_perms):
                print(f"Granting {app} access to {path}")
                await Flatpak.override_filesystem(app, path)


async def ensure_flatpaks():
    if not shutil.which("flatpak"):
        return
    installed_flatpaks = await Flatpak.list_installed()

    for remote, expected_apps in EXPECTED_FLATPAKS.items():
        missing = expected_apps - installed_flatpaks

        if missing:
            print(f"Installing missing flatpaks from {remote} ...")
            for app in missing:
                print(f"  Installing {app}")
                await Flatpak.install(remote, app)

    await ensure_flatpak_permissions()


async def ensure_packages():
    expected_packages = set(EXPECTED_PACKAGES)
    installed_packages = {package.name: package for package in all_packages()}

    missing = set()
    for name in expected_packages:
        if name not in installed_packages:
            missing.add(name)
        elif installed_packages[name].reason != pyalpm.PKG_REASON_EXPLICIT:
            missing.add(name)

    if missing:
        print("Installing missing packages ...")
        await Pacman.install(missing, asexplicit=True)


async def ensure_package_dependencies():
    provided_packages = set()
    installed_packages = set()
    for package in all_packages():
        installed_packages.add(package.name)
        provided_packages.add(package.name)
        provided_packages.update(package.provides)

    missing = set()
    for package, expected_deps in EXPECTED_PACKAGE_DEPENDENCIES.items():
        if package not in installed_packages:
            continue
        for dep in expected_deps:
            if dep not in provided_packages:
                missing.add(dep)

    if missing:
        print("Installing missing dependencies ...")
        await Pacman.install(missing, asdeps=True)


async def run_mode(mode):
    args = []
    if mode == "root":
        args.extend(["sudo", "--preserve-env=HOST_DOTFILES"])
    args.extend([__file__, mode])
    proc = await asyncio.create_subprocess_exec(*args)
    await proc.wait()
    if proc.returncode:
        raise ProcessError(proc)


class ProcessError(Exception):
    def __init__(self, process, message=None):
        self.process = process
        self.message = message

    def __str__(self):
        proc = self.process

        text = f"exit {proc.returncode}"
        if self.message is not None:
            text = f"{text} - {self.message}"

        try:
            args = proc._transport._extra["subprocess"].args
        except (AttributeError, KeyError):
            pass
        else:
            text = f"{text}: {args}"
        return text


async def main():
    if not pathlib.Path("/etc/arch-release").exists():
        return

    modes = ["user", "root"]
    parser = argparse.ArgumentParser()
    parser.add_argument("mode", choices=modes, nargs="?")
    args = parser.parse_args()

    # TODO: always run as root
    match args.mode:
        case "user":
            await ensure_users_in_expected_groups()

            await ensure_packages()
            await ensure_package_dependencies()
            await ensure_flatpaks()

            if HOSTNAME in ("mars", "phobos", "sol"):
                await ensure_python_freethreaded()

            for service in EXPECTED_SERVICES:
                await Systemctl.enable(service, now=True)
        case "root":
            if HOSTNAME in ("mars", "phobos"):
                await ensure_using_systemd_resolved()
            if HOSTNAME in EFI_SHELL_HOSTS:
                await install_efi_shell()
        case _:
            for mode in modes:
                await run_mode(mode)


if __name__ == "__main__":
    asyncio.run(main())
